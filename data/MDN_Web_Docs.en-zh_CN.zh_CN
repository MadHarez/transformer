{{GamesSidebar}} 
本文从技术角度分析了一般电子游戏的结构和工作流程，就此介绍主循环是如何运行的。 
它有助于初学者了解在现代游戏开发领域构建游戏时需要什么，以及如何将 JavaScript 这样的 Web 标准工具作为自己的工具使用。 
游戏开发经验丰富但不熟悉 Web 开发的开发者也能从中受益。 
呈现、接收、解释、计算、重复 
所有电子游戏的目标都是向用户呈现一个场景，接收他们的输入，将这些输入信号解释为动作，并计算出由这些动作产生的新场景。 
游戏不断地循环遍历，一遍又一遍，直到遇到某些终止条件（比如赢、输或者退出睡觉）。 
毫不奇怪，这种模式与游戏引擎的编程方式相呼应。 
具体情况取决于游戏本身。 
一些游戏通过用户输入来驱动这个循环。 
想象一下，你正在开发一种“大家来找茬”类型的游戏。 
这些游戏向用户呈现两张图片，游戏接收点击（或触摸）；将用户输入解释为成功，失败，暂停，菜单交互等。 
最后，游戏根据用户的输入计算并更新游戏场景。 
这种游戏是由用户的输入驱动，也就是说，它会在用户进行输入之后冻结画面，等待玩家进行新的输入。 
这是一种基于回合的游戏类型，它不需要每帧持续更新画面，只有当玩家作出反应时才会。 
另一些游戏需要尽可能控制每一个细微的时间片（动画）。 
与上述原理有点小区别：每个动画帧都将循环遍历，并在之后第一个可用的轮次捕获玩家输入的任何变化。 
这种每帧一次的模型是通过一个叫主循环的东西实现的。 
如果你的游戏循环是基于时间的，则必须保证对主循环精准的模拟。 
但它也可能不需要逐帧控制。 
你的游戏循环可能类似找不同的例子，并以输入事件作为基础。 
它可能需要输入和模拟时间片。 
它甚至可以基于其他的东西来循环。 
现代 JavaScript - 正如下一节中所描述的 - 它可以轻松开发出一个高效的，逐帧执行的主循环，这很值得庆幸。 
当然，你的游戏只会按照你所做的那样优化。 
如果某些东西看起来应该被添加到一个更罕见的事件里，那么将它从主循环中剥离出来通常是个好主意（但并非总是如此）。 
在 JavaScript 中构建一个主循环 
JavaScript 能很好的处理事件和回调函数。 
现代浏览器努力在需要的时候调用方法，并在间隙中闲下来（或做其他任务）。 
将你的代码附加到适合它们的时刻是一个很好的主意。 
考虑一下你的函数是需要在严格的时间周期内，还是每一帧，或者仅仅是在发生了其他情况之后执行。 
当你的函数需要被调用时，要更具体地使用浏览器，这样浏览器就可以在调用时进行优化。 
而且，这可能会让你的工作更轻松。 
有些代码需要逐帧运行，所以应将其附加到浏览器的重绘周期中，没有比这更好的了！ 
在 Web 中，通常 {{domxref(“window.requestAnimationFrame()”)}} 方法是大多数良好的逐帧循环的基础。 
在调用该方法时必须传入一个回调函数，这个回调函数将在下一次重新绘制之前执行。 
下面是一个简单的主循环的例子： 
window.main = () => { 
window.requestAnimationFrame(main); 
// 无论你的主循环需要做什么 
}; 
main(); // 开始循环 
备注： 在这里讨论的每个 main() 方法中，在执行循环内容之前，我们会递归调用一个新的 requestAnimationFrame，这不是随意的，它被认为是最佳实践。 
如果你的当前帧错过了它的垂直同步窗口的周期，你也在下一个帧通过 requestAnimationFrame 尽早的调用 main()，从而确保浏览器能够及时地执行。 
上面的代码块有两个语句。 
第一个语句创建一个名为 main() 中的全局变量的函数。 
这个函数做一些工作，也告诉浏览器在下一帧通过 window.requestAnimationFrame() 调用本身。 
第二个语句调用第一个语句中定义的 main() 函数。 
因为 main()中在第二个语句中被调用一次，而每次调用都将自身又放置到下一个帧的执行队列中，因此 main() 的调用与你的帧率同步。 
当然，这个循环并不完美。 
不过在讨论如何改善之前，让我们先讨论一下它已经做好了什么。 
将主循环的时机安排在浏览器每次的绘制显示中，允许你能像浏览器想要绘制的那样频繁的运行你的循环。 
你能够控制每一帧动画，并且 main() 是循环中唯一执行的函数，所以这很简单。 
主视角射击游戏（或类似的游戏）每一帧都会出现一个新的场景。 
没有比这种方法更平滑并绘制及时的了。 
但是不要马上认为动画必需要帧帧控制。 
通过 CSS 动画或浏览器中的其他工具，可以很容易实现简单的动画，甚至 GPU 加速。 
有很多这样的东西，它们会让你的工作更轻松。 
在 JavaScript 中构建一个更好的主循环 
在前面的主循环中有两个明显的问题：main() 污染了 {{domxref(“window”)}} 对象（所有全局变量存储的对象），并且示例代码没有给我们留下一个停止循环的方法，除非整个浏览器选项卡被关闭或刷新。 
对于第一个问题，如果你希望主循环只运行，并且不需要被简单（直接）访问它，你可以将它作为一个立即调用的函数表达式（IIFE）创建。 
/* 
* 以分号开头是为了以防此示例上方的代码行依赖于自动分号插入（ASI）。 

{{GamesSidebar}} 
游戏是最流行的计算机活动之一。 
新技术不断涌现，使得开发者有可能开发出更好、更强大、可以在任何符合标准的 web 浏览器运行的游戏。 
开发网页游戏 
在网站的这一模块，我们为想要开发游戏的 web 开发者提供了资源。 
你可以在左侧主菜单中找到很多有用的教程和技术文档，尽情去探索吧。 
我们同样提供了参考部分，因此你可以轻易地找到有关游戏开发所有常用的 API。 
备注： 在创建一个网页游戏之前你至少需要掌握几种核心的 web 技术，例如 HTML、CSS 和 Javascript。 
: 比较不同的框架中的 JavaScript 打砖块游戏，以帮助你作出正确的选择。 Tuts+ 游戏开发 
Mozilla Hacks 博客 : Mozilla Hacks 博客包含关于游戏类别的有趣的游戏开发的相关文章。 
wiki.mozilla.org 上的游戏部分 

{{GamesSidebar}} 
现代的 web 已经高速发展成为一个可行可靠的平台，它不仅能够用来创建高质量的酷炫游戏，同时也能够用来发布和传播这些游戏。 
采用现代网页技术和较新的浏览器，完全有可能做出令人印象深刻的顶级页面游戏。 
它能够制作的游戏种类可以和桌面端以及原生系统相当。 
我们这里所说的，并不是很久之前就采用 Flash® 制作出的简单卡牌游戏或者多人社交游戏。 
得益于 JavaScript 实时编译技术性能的大幅提升，以及新开放的 API。 
在制作运行在浏览器（或者是基于类似 Firefox OS 的 HTML5技术支持的设备）上的游戏时，我们不用妥协。 
HTML5 游戏平台 
你可以真正地为你的游戏考虑下 Web 来作为更好的目标平台。 
我们总是喜欢说，“the Web is the platform.” 
让我们浏览下 Web 平台的核心部分： 
功能 
技术 
音频 
Web Audio API 
图形 
WebGL (OpenGL ES 2.0) 
输入 
Touch events, Gamepad API, 设备传感器，WebRTC, Full Screen API, Pointer Lock API 
语言 
JavaScript (或是 C/C++ 使用 Emscripten 来编译成 JavaScript) 
网络 
WebRTC 和/或 WebSockets 
存储 
IndexedDB 或是 “云 (存储)” 
Web 
HTML, CSS, SVG, Social API (还有其他很多很多东西！) 

{{GamesSidebar}} 
优点 
使用 HTML5 构建的游戏可以在智能手机，平板电脑，个人电脑和智能电视上工作。 
通过网络以及其他媒体广告宣传你的游戏。 
付款。 
收取你想要的，并使用任何你喜欢的付款处理服务。 
随时更新游戏。 
收集你自己的分析！ 
更密切地与客户联系。 
玩家可随时随地玩游戏。 
网络技术 
Function 
Technology 
Audio 
Web Audio API 
Graphics 
WebGL (OpenGL ES 2.0) 
Input 
Touch events, Gamepad API, device sensors, WebRTC, Full Screen API, Pointer Lock API 
Language 
JavaScript (or C/C++ using Emscripten to compile to JavaScript) 
Networking 
WebRTC and/or WebSockets 
Storage 
IndexedDB or the “cloud” 
Web 
HTML, CSS, SVG, Social API (and much more!) 

{{GamesSidebar}} 
包括自己建立网站，在公开的应用市场上线，或是发布到 Google Play 或 IOS 的 App Store。 
不过你仍需考虑你的游戏的大小是否可能会让用户花一点时间来加载资源，以及你的游戏对网速的需求。 
总之，如果你把你的游戏按照你的设想构建，并且在开玩之前没有那么多弯弯绕绕，推广它还是很容易的 
电脑还是手机？ 
当你要发行游戏时，通常有三种主要的方式可供选择 自运营 
发行商代理 
你可以有一个免费的主机，可控制的版本，以及可能的贡献者——如果这个项目足够有趣的话。 发行商和门户网站 
一些网站会把你的文件放在他们的服务器上运营，而其他网站则只链接到你的网站或将你的游戏嵌入他们的网站，这样的曝光可能只是为你的游戏提供宣传，如果你的游戏旁边有广告 (或其他赚钱的选项)，它也可能为你的游戏提供收益化。 网络和应用商店 
备注： 这些是最流行的发行平台，但这并不是说这些是唯一的选择。 
你也可以尝试找到一个对口的平台，并直接向那些对你的游戏感兴趣的观众推广你的游戏。 
网络商店 
Firefox OS 是 HTML5 游戏的完美硬件平台，因为系统本身是用 JavaScript 编写的，而且是开源的。 
你可以快速访问控制硬件的核心应用程序，Firefox Marketplace 是推广你的游戏的好地方，你也可以更进一步，允许人们直接从网络上安装你的游戏。 
他们的商店是另一个可用的选择。 
CocoonIO — 为多个本地商店构建 HTML5 游戏的最流行的工具。 
它对画布上呈现的游戏有自己的性能优化，并支持许多游戏框架。 Ejecta — 一个专门用于为 iOS 打包使用the ImpactJS框架创建的游戏的工具，由 ImpactJS 作者构建。 
NW.js — 这款游戏的前身是 Node-Webkit，它是开发适用于 Windows、Mac 和 Linux 的桌面游戏的首选。 
Manifold.js — 微软团队的这个工具可以从 iOS、Android 和 Windows 创建 HTML5 游戏的本地发行版。 总结 

{{GamesSidebar}} 
当你花时间创造一个游戏的时候，从发布和促销中赚钱是你应该考虑的事。 
如果你正做出大量努力去成为一个能够以此为生的独立游戏开发者，接下去，看看你有哪些选择。 
技术手段已经足够成熟; 接下来只是选择正确的方法。 
付费游戏 
你可能想到的第一个，也是最明显的选择便是以面向 AAA 级游戏的方式销售游戏——即固定的预付款。 
即使数字市场是关键，你也不需要打印封面，也不需要将游戏放在实体店的盒子里，但要想以固定的价格销售游戏赚取可观的利润，你必须将时间和金钱投入到市场营销中去。 
只有最好的游戏才能做到收支平衡，或者赚得比制作成本还要多，你仍然需要很多的运气。 
你为你的游戏收取多少费用取决于市场，游戏的质量和许多其他小因素。 
一款街机 iOS 游戏售价为 0.99 美元，但一款更长的 rpg 风格的 Steam 桌面游戏售价为 20 美元;两个价格都可以。 
你必须跟随市场，做自己的研究——迅速从错误中吸取教训是很重要的。 
应用内购买内容 
你可以提供一款带有应用内购买功能（IAP）的免费游戏，而不是让人们预先为你的游戏付费。 
在这种情况下，玩家不需要花一分钱就可以获得游戏——将游戏交给玩家，但要提供游戏内的货币、奖金或福利。 
具体的例子可以包括奖金水平，更好的武器或咒语，或补充所需的能量发挥。 
设计一个好的 IAP 系统本身就是一门艺术。 
记住，你需要下载数千次游戏才能使 IAPs 有效——只有一小部分玩家会真正为 IAPs 付费。 
多小？ 
情况各不相同，但大约每千人中就有一个人处于平均水平。 
玩你的游戏的人越多，别人就越有可能付钱，所以你的收入很大程度取决于你的推广方式。 
免费增值模式 
带有 IAPs 功能的游戏通常被称为免费增值游戏——免费增值游戏可以免费取得与游玩，但你可以为额外的 (高级) 功能、虚拟物品或其他好处付费。 
在大公司专注于创造游戏后，这个词本身就带有负面含义，其主要目的是为了从玩家那里获得尽可能多的钱，而不是提供一种有趣的体验。 
最糟糕的情况是，你可以用真金实银来获得相对于其他玩家的优势，或限制玩家进入游戏的下一阶段，除非玩家付费。“ 
为赢付费”这个术语是被创造出来的，并且这种方法不受许多玩家和开发者的欢迎。 
如果你想要实现 IAPs，那就试着用玩家喜欢的东西来为游戏增加价值，而不是把它拿出来然后收费。 
扩展包 (Add-on) 和可下载内容 (DLC) 
扩展包和可下载内容是为已经发行的游戏提供额外价值的好方法，但请记住，你必须提供体面的、有趣的内容来吸引人们购买它。 
一套全新的带有新角色、武器和故事的关卡对于 DLC 来说是一个很好的素材，但要想获得足够的销量，游戏本身必须是受欢迎的，否则就不会有玩家愿意将他们辛苦赚来的钱花在这上面。 
推广 
除了积极销售游戏以外，你也可以尝试被动销售 — 投放广告和开展相关活动或许有益于推广你的游戏，但你的游戏必须让人上瘾，这并不像听起来那么容易。 
你仍然需要计划好，在某种程度上，你也需要一些运气。 
如果你的游戏像病毒一样传播开来，人们开始分享它，你就能从广告中获得大量的下载和收益。 
有许多公司提供广告系统——你注册后，允许他们展示广告，以换取一定比例的利润。 
谷歌 AdSense 被认为是最有效的一个，但它不是为游戏而设计的，使用它来达到这个目的是一个非常糟糕的做法。 
不要冒着让你的账户被封禁，资产被冻结的风险，游戏开发者们更青睐门户网站，如LeadBolt。 
他们提供了易于实现的系统，以在你的游戏显示广告并与你分享收益。 
视频广告正变得越来越受欢迎，特别是以预播放的形式——它们会在游戏开始时显示，而此时游戏还在加载中。 
至于在游戏中放置广告的位置，这完全取决于你自己。 
它应该尽可能的微妙，以避免过多地惹恼玩家，但又足够的可见性让玩家点击它或至少注意到它。 
通过屏幕在游戏会话之间添加广告是一种流行的方法。 
授权证书 
有一种方法可以作为自己的盈利模式，即出售游戏发行许可。 
越来越多的门户网站有兴趣在他们的网站上展示你的游戏。 
他们遵循各种策略来通过你的游戏赚钱，但你不必担心所有这些，因为出售许可通常是一次性的交易。 
你得到了钱，他们就可以创造性地使用你的游戏来赚钱。 
一开始寻找发行商是件困难的事情 — 你可以在HTML5 Gamedevs forums联络他们.。 
如果你很有名，他们可能会联系你。 
大多数交易都是通过电子邮件与出版商一方的专业人士进行沟通的。 
一些出版商的网站很容易获得这些信息，而另一些则很难找到。 
当接触出版商的时候，尽量友好而直接——他们都是很忙的人。 
独家许可 
独家性许可是针对一个发行商的一种许可类型——你创造了一款游戏，并将其所有权利出售给了一个实体，同时还拥有重新发行该游戏的权利 — Softgames就是这样一家发行商。 
在出版商拥有版权的情况下，你不能再以任何形式出售它——这就是独家交易价值不菲的原因。 
到底是多少？ 
这取决于游戏的质量，游戏类型，发行商，以及其他许多因素，但通常价格在 2000 到 5000 美元之间。 
一旦你卖出了独家授权，你就不用再参与推广这款游戏了，因为你赚不到更多钱，所以只有在你确信这款游戏足够盈利的情况下，你才会参与这样的交易。 
独家许可 
这种方法不那么严格——你可以将许可证出售给多个发布者。 
这是最受欢迎的方法，因为对于每一个新的发行商 (总会有的)，你都可以以非独家的条款出售你的游戏。 
请记住，有了这个许可，发行商就不能再对其进行重新发行了——这通常被称为站点锁定交易，因为他们购买了在自己的门户网站上发布游戏的权利。 
非独家许可的通常成本约为 500 美元。 
定期付费 
此外，用户还可以通过购买服务来月付你的游戏而不是一次性付款，每一款游戏每月都能为你提供一定的钱——大约 20-50 美元。 
你可以决定是一次性付清一段时间还是每月付一次。 
记住它可以被随时取消，所以它不是一个通解。 
推广收入 
你可以在自己的游戏中发布广告，并试图找到流量来赚取一些钱，但你也可以与发行商达成收益分成协议。 
他们将负责吸引流量，并将分享收益——通常是每月 73 开或者五五开的交易。 
请记住，许多新的、低质量的发行商会希望你的游戏获得广告收入而不是授权，因为这对他们来说更便宜，并且你可能只会在整个交易中获得每款游戏约 2 美元的收益。 
在与新出版商打交道时要小心——有时候，降低已知出版商的许可成本比冒着被未知出版商骗钱的风险要好。 
发行商从你的游戏中获取收益分成，以及/或许可可能需要实现他们自己的 API，这可能需要额外的工作，所以你也要考虑到这一点。 
品牌 
你可以出售你的游戏的品牌使用权，也可以用你自己的游戏来招揽其他人的品牌。 
在第一种情况下，它几乎类似于非独占许可，但是你的客户通常会购买代码的权限并构建自己的游戏。 
在第二种情况下，它就像一个自由的交易，但你将会在代码中加入客户的品牌图形，或有时会按照他们的指示实现需求。 
举个例子，如果你有一个游戏，玩家点击食物，你可以把食物换成客户的产品来给他们做广告。 
这个模型中的价格根据品牌、客户和工作量的不同而有很大的差异。 
其他不以游戏为主题的变现手段 
在开发 HTML5 游戏时，你还可以通过其他方式赚钱，而这甚至不需要与游戏相关。 
销售资源 
如果你是一名平面设计师，你可以出售你所创造的游戏的资产，或一些全新的专为这一目的的在线商店，如Envato Market. 
虽然卖的钱并不多，但如果你是一个著名的设计师，它就是一个额外的被动收入流。 
撰写文章和教程 
你可以写一些关于你的游戏的文章，甚至可以从中获得报酬。 
可以同时取得游戏推广和收益化的双赢，如果你不滥用它与太多的广告，读者将享受阅读他们以及学习一两个东西。 
如果你专注于先分享知识，并将游戏作为例子来使用，这应该是可以的。 
浏览Tuts+ Game Development 或相似的网站来找寻协作机会 
周边商品 
你可以售卖 T 恤，贴纸或其他周边 — 有些开发者从这些商品中赚的钱比从游戏本身中赚的钱还多，但它只适用于像愤怒的小鸟这样非常受欢迎且易于识别的游戏。 
不过，这也可能是另一种小的被动收入来源。 
你的收入越多样化，你的生意就越稳定。 
捐助 
当其他方法都失败时，你可以尝试在你的游戏页面上放置一个捐赠按钮并寻求社区的支持。 
有时候它是有效的，但前提是玩家了解你并觉得它能够帮助你。 
这就是为什么小心管理你的社区是如此重要。 
这在js13kGames比赛中很管用 — 每个参与者都得到了一件免费的 t 恤，有些人甚至还退了一些钱，以帮助它在未来几年继续运行下去。 
小结 
赚钱的方法有很多种——所有适用于“普通”AAA 级游戏世界的东西，或多或少都可以应用于休闲 HTML5 游戏。 
然而，你也可以专注于销售许可证，做品牌，或者从广告中获得收入分成。 
你要走哪条路完全取决于你自己。 

{{GamesSidebar}} 
开发与发行你的游戏并不是全部.。 
你应该让大家知道你有个大家会喜欢玩的游戏。 
这儿有很多方法去推广你的游戏——大部分方法是免费的，所以即使即使你正努力以一名零预算的独立开发者的身份谋生，你也可以让人们知道你的新游戏.。 
推广游戏也对之后的游戏收益化大有裨益，所以正确地推广游戏是很重要的。 
竞赛 
参加竞赛不仅将提升你的游戏开发技能，让你认识新朋友、学习开发，它还将让你参与到社区之中。 
如果你在比赛中做了一个好的游戏并赢得了一些奖品，你的游戏就会自然而然地被组织者和其他参与者推广开来。 
你会变得富有和出名，至少他们是这么说的。 
许多优秀的游戏都是从一个游戏制作比赛上的 demo 开始的。 
如果你的想法和执行力都足够好，你就会成功。 
另外，比赛通常要求游戏有一个固定的主题，所以如果你一筹莫展，你也可以围绕这个主题进行创作。 
网站与博客 
你应该创建自己的网站，包含所有关于游戏的信息，这样人们就可以看到你在做什么。 
你能包含的信息越多越好 — 包括截图，简报，预告，宣传资料，需求，可用的平台，赞助以及其他。 
让你的用户在网上直接玩你的游戏——或者说测试版可以让你得到许多电子。 
同时，为了让你的用户能够更好的玩游戏，你应该做些网站优化（SEO） 
你也应该在博客公布所有与你游戏开发有关的动作，写下你的开发历程，严重的 bug，有趣的事情，经验教训，以及作为游戏开发者的起起伏伏。 
坚持发布信息有助于他人从中学习，提高你在社区中的声誉，改进你的网站优化。 
另一种选择是发布每月报告——总结你所有进展的报告——它能够帮助你看到你在整个月都完成了什么，还有什么需要去做，并不断提醒人们你的游戏即将发行——创造口碑总是好的。 
社交媒体 
你的社交媒体的风格很重要 — 选择正确的标签，交朋结友，参与交流，帮助其他开发者。 
保持真诚，这是你与人结交的关键，因为没有人喜欢无聊的新闻发布或者硬广告.。 
一旦游戏完成，你的社区会帮助你宣传你的小宝贝游戏的 
你应该至少使用推特（Twitter）和脸书（Facebook）之中的一个，并且入驻一个合适的论坛，最出名的就是 HTML5GameDevs.com. 
分享你的游戏开发信息，回答别人的问题，这样人们会在心里衡量你所做的一切并且知道你做的很好.。 
记住也别逢人就说你的游戏——你可不是行走的广告 
发展你的粉丝，你可以与他们交流，分享一些小贴士，提供一些福利，在比赛中分发奖品，或者只是抱怨天气或者浏览器的问题，举止冷静，慷慨大方，做你自己，去帮助别人，你就会得到尊重。 
游戏门户网站 
设立门户网站主要与收益化挂钩，但是如果你不打算售卖许可来让人们可以购买你的游戏而是打算发布广告 , 在免费的门户网站上推广游戏会更有效。 
你可以在公共门户网站，比如HTML5Games.com发布游戏，比起传统的游戏发行平台，它更像一个宣传平台。 
免费的门户网站带来了流量，但是，只有最好的广告才足够受欢迎，能够从发布的广告中获得一些业绩。 
另一方面，如果你没有预算和有限的时间，门户网站也是一个完美的工具，它可以让更多人看到你的游戏 
媒体宣传 
你可以试着联系媒体去宣传你的游戏，不过要记住，他们每天都在处理成吨的请求，所以如果它们没有及时回复你，请保持耐心，在于他们交流时保持礼貌。 
一定要先检查他们是否只接纳特定类型的游戏或平台，这样你才不会发送与之无关的内容。 
如果你方式恰当并且你的游戏很好，那么你就有更多的成功机会 
如果你想了解更多关于联系媒体的礼仪，你可以阅读 How To Contact Press - 由 Pixel Prospector 编写的一篇很棒的指南，还有Video Game Journaliser，他们创建的一个记录媒体联络名单的网站。 
教程 
与其他开发者互通有无是很好的 — 毕竟你可能也曾在网上的一两篇文章上学到了些东西，所以你要花时间把这些知识传递出去。 
谈论或写一些你取得的成就或克服的问题是人们会感兴趣的事情。 
你可以拿你自己的游戏做例子，特别是当你展示你已经实现的事情. 
这样每个人都会受益——人们学习新的技能，你的游戏会得到推广，如果你足够幸运，你甚至可以因为编写教程而获得报酬 
但并不是所有的主旨都会被接受。 当你在写教程的时候，记住要把重点放在给读者提供一些有价值的东西上。 
他们想要学习一些东西——提供你的专业知识并将你的游戏作为案例研究。 
专注于一个方面，并试图解释它的全部和细节。 
如果你联系的门户网站因你未写过教程而未采纳你的教程，可以在自己的博客先发布教程，这是锻炼你的写作技巧的最简单的方式。 YouTuber 视频主 (YouTubers) 
这是一种趋势 — 别低估了 YouTuber 视频主（YouTubers）们对游戏的影响力，与他们交流，让他们做游戏实况会极大的宣传你的游戏。 
有两种方法可以让 Youtubers 选择你的游戏：第一种方法是你直接联系他们，并通过电子邮件或私人信息向他们发送游戏链接。 
这个YouTuber 的名单是个很好的开始。 
活动 
如果你已经完成了上面列出的所有选项，你仍然可以找到新的、创造性的方式去推广你的游戏——活动便是另一个很好的例子。 
参加本地和全球的活动，让你能够面对面地与你的粉丝以及开发社区的其他成员见面。 
别辜负了他们专程花时间来看你的心思。. 
会议 
在许多会议上，你可以发表演讲，解释你克服的一些技术困难，或者如何实现特定的 API;其次，以你的游戏为例。 
专注于知识部分并降低市场营销是很重要的——开发者对这个问题很敏感，如果你只是想向他们推销一些东西，他们可能会对此不满。. 
展会 
另一个与活动相关的选项是展会 (或博览会)——在这样的活动中，你可以在其他开发者中获得一个摊位，并向所有经过的参与者推广你的游戏。 
如果你这样做了，那就试着做得独特而有创意，这样你就很容易从人群中脱颖而出。 
以正确的方式去做，每个人都会谈论你和你的游戏。 
有一个展台可以让你与你的粉丝直接互动——除了推广部分，你还可以在普通人身上测试你的游戏的新版本，并修复他们发现的任何 bug(或包含任何反馈)。 
你无法想象人们在玩你的游戏时可能会想到什么，以及你在花费数小时打磨游戏时错过了哪些明显的问题。 
优惠码 
如果你是在销售游戏，那么你应该发行优惠码让人们免费游玩你的游戏 (或至少是一个演示版或限时版)，并把它们发送到各地——给媒体，Youtuber，作为比赛奖品等等。 
如果游戏符合某些人的胃口，就相当于为成千上万人打了一次免费广告。 
如果你幸运的话，它比任何其他东西都能提高人们对你的游戏的兴趣 
培养社区 
你可以帮助社区成长，同时推广你自己和你的游戏。 
发布每周时事通讯，组织在线竞赛或者线下聚会，这些都能让别人知道你对自己的工作充满激情，他们可以依靠你。 
当你需要帮助的时候，他们会在你身边 
总结 
任何推广你的游戏的方法都是好的。 
你有很多选择，其中大部分都是免费的，所以关键在于你的热情和可用时间。 
有时候你不得不花更多的时间去推广一款游戏，而不是真正去开发它。 
记住，如果没有人知道世界上最好的游戏的存在，那么拥有它是没有任何意义的。 
现在让我们进入游戏收益化部分，然后挣口饭吃吧。 

{{GamesSidebar}} 
HTML5 游戏在发布和分发上具有极大的优势–你可以通过网络自由地发布，推广，获利，并且不受分发商的限制。 
你可以实现通过多种平台获利。 
这一系列的案例关注在当你想要发布，推广你的游戏，并当游戏变得有名时获取一些回报。 
游戏发布 
Game distribution提供了你发布游戏时所需的一切知识。 
包括如何在线托管游戏，提交游戏到开放的游戏市场，或封闭的游戏市场，如 Google Play，iOS App Store. 
游戏推广 
开发完成游戏并不是结束。 
你必须让世界知道你制作了一些有趣的东西能使他们乐在其中。 
这些游戏推广技术— 有些是免费的 — 即使你作为一名 0 预算的独立开发者为生活奔波，你依旧可以让很多人知道你制作的这个新游戏。 
推广游戏或许能够使你获得收入。 高效的推广非常重要。 
游戏获利 
当你开发，发布并推广你的游戏后，你可以考虑通过游戏来获得收入。 游戏获利对于考虑从业余转为全职并以此为生的开发者来说是必要的一个手段。 
现在来看看你的选择，技术已经足够成熟，现在只差一个合适的机会了。 



{{GamesSidebar}} 
这篇文章解释了当你开始使用 3D 工作的时候需要的所有有用的基本理论 
坐标系统 
3D 指的是有关在 3D 空间中所有形状的表示，并且可以使用坐标系统来计算其位置。 
Coordinate system 
WebGL 使用右手坐标系统 — x 轴向右，y 轴向上 z 轴指向屏幕外，在上图可以看到。 
物体 
使用顶点建立不同类型的物体。 
一个顶点是在 3D 坐标系中拥有坐标位置的一个点以及一些额外可以定义它的信息。 
每个点都包含这些属性： 
位置: 在 3D 空间用来辨认 (x, y, z). 
颜色: 包含 RGBA (R, G 和 B 分别是红，绿，蓝和 alpha 通道，alpha 通道控制透明度 — 所有通道值的范围都是 0.0 到 1.0). 
法线： 描述顶点朝向。 
纹理: 顶点用来装饰模型表面的一张 2D 图片，它是代替简单颜色的选择之一。 
你可以使用这些信息建立几何体 — 这是一个立方体的例子： 
Cube 
给定形状的一个面是顶点之间的一个平面。 
例如，一个立方体有 8 个不同的顶点和 6 个不同的面 每个面由 4 个顶点构成。 
一条法线定义面的朝向。 
同时，连接这些点可以创建立方体的边。 
这个几何体通过点和面构成，材质使用的是一张纹理贴图，这里使用一个纯蓝色或一张图片。 
该物体的几何形状 (geometry) 由顶点和面构成，而材质 (material) 则是由纹理构成。 
如果我们将几何体和材质连接起来会得到一个网格 (mesh). 渲染流程 
渲染流程是个将之前准备好的模型输出到屏幕的过程。 
3D 渲染流程会接受使用顶点描述 3D 物体的原始数据作为输入用于处理，并计算其片段 (fragment), 然后渲染为像素 (pixels) 输出到屏幕。 
Rendering pipeline 
上图中用到了如下术语： 
原始数据: 渲染流程中的输入 — 用顶点生成，它可能是三角形，点或线。 
片段: 一个像素的 3D 投射，有着和像素一样的属性。 
像素: 屏幕上的 2D 网格中的点布置的点，包含 RGBA. 
顶点和片段处理是可编程的 — 你可以编写自己的着色器 来控制输出。 
顶点处理 
顶点处理是将独立的顶点信息组合成原始数据并设置其在 3D 空间中的坐标，方便显示器识别。 
就像是对你准备的场景进行拍照 — 你必须先放置物品，设置相机参数，然后开拍。 
Vertex processing 
这个过程分为四步：第一步是筹备世界坐标中的物体，也被称为模型转换 (model transformation). 
然后是视图转换 (view transformation) , 这一步只关心位置和 3D 空间中摄像机的朝向设置。 
摄像机有三个参数 (位置，方向和朝向), 在新创建的场景中必须定义这三个参数。 
Camera 
投射转换(projection transformation), 也被称作透视转换 (perspective transformation), 这一步定义摄像机设置，在此过程会设置哪些在摄像机中可见，配置包含视野 (field of view), 宽高比例 (aspect ratio) 和可选的近裁剪和远裁剪参数。 
阅读 Three.js 文章摄像机了解更多。 
最后一步是视图窗口转换(viewport transformation), 这一步会将一切都输出给渲染流程中的下一步。 
栅格化 
栅格化将原始数据 (从顶点信息转换过来的) 转换为一系列的片段。 
Rasterization 
那些片段 (2D 像素的 3D 投射) 是对应到像素网格的，所以在渲染合成阶段最后他们会被 2D 的屏幕直接打印到像素点上。 
片段合成 
片段合成关注关注的是纹理和光照 — 它会基于给定参数计算最终的颜色。 
Fragment processing 
纹理 
纹理是在 3D 空间中用了是模型看起来更加真实的 2D 图片。 
纹理是由称为纹素的单个纹理元素组合，和像素组合的原理一样。 
如果必要的话，在渲染流程中的片段处理阶段添加纹理到模型上允许我们使用包装 (wrapping) 和过滤 (filtering) 进行适配。 
纹理包装允许你在 3D 模型上重复使用 2D 图片。 
纹理过滤是纹理贴图的原始分辨率和将要呈现的片段的分辨率不同的时候，会根据情况对纹理进行缩放。 
光照 
我们在屏幕上看到的颜色是光照和模型颜色，材质进行交互之后的最终结果。 
灯光会被吸收和反射，在 WebGL 中实现的标准Phong 光照模型 有以下四种光照参数： 
漫反射: 遥远的直接光照，就像太阳。 
高光: 点光源，就像房间的白炽灯或闪光灯。 
环境色: 常量灯光，可影响场景中的所有模型。 
自发光: 模型自身发出的光。 
输出合成 
在输出操作阶段所有来自 3D 空间的原始数据的片段会被转换到 2D 像素网格中，然后打印到屏幕像素上。 
Output merging 
在输出合成阶段同样可以忽略不必要的信息，例如在屏幕外的模型参数或者被其他模型遮挡的模型，因为是不可见的所以不会被计算。 
总结 
现在你知道了 3D 操作背后的基本原理。 
如果你想去练习或者看学习 demo, 看看下面的教程： 
用 Three.js 创建基本 demo 
用 Babylon.js 创建基本 demo 
用 PlayCanvas 创建基本 demo 
用 A-Frame 创建基本 demo 
继续，去创建一些炫酷 3D 实验吧！ 

{{GamesSidebar}} 
游戏中一个典型的 3D 场景 (最简单的那种) 包含标准的物品比如在坐标轴中的形状，一个实际可看到他们的摄像机，灯光和材质让其看起来不错，动画使其生动等等。 Three.js, 和其他 3D 库一样，提供内置的 helper 函数来帮助你尽可能快地实现通用的 3D 功能 . 
在这篇文章我们会带你了解使用 Three 的基本知识，包含设置开发者环境，必要的 HTML 结构，Three.js 对象基础，以及如何创建一个基本的 demo. 
备注： 我们选择 Three.js 因为它是最流行的WebGL 库之一，并且很容易上手。 
我们不会介绍任何其他更好的 WebGL 库，你可以自由选择其他库做尝试，比如 CopperLicht, GLGE, OSG.js, O3D, 或者其他你喜欢的库。 
环境设置 
开始用 Three.js, 你不需要准备太多，只需： 
确保使用的支持 WebGL 的现代浏览器，例如最新版的 Firefox 或 Chrome. 
创建一个目录保存例子。 
复制最新的压缩版 Three.js 到你的目录。 
用单独的浏览器 tab 打开 Three.js 文档 — 对应参考很有用。 
HTML 结构 
这是将用到的 HTML 结构。 
<! 
doctype html> 
<html> 
<head> 
meta charset="utf-8"> 
<title>MDN Games: Three.js demo</title> 
<style> 
body { 
margin: 0; 
padding: 0; 
} 
canvas { 
width: 100%; 
height: 100%; 
} 
</style> 
</head> 
<body> 
<script src="three.min.js"></script> 
<script> 
var WIDTH = window.innerWidth; 
var HEIGHT = window.innerHeight; 
/* all our JavaScript code goes here */ 
</script> 
</body> 
</html> 
It contains some basic information like the document {{htmlelement(“title”)}}, and some CSS to set the width and height of the {{htmlelement(“canvas”)}} element that Three.js will insert on the page to 100% so that it will fill the entire available viewport space. 
The first {{htmlelement(“script”)}} element includes the Three.js library in the page, and we will write our example code into the second one. 
There are two helper variables already included, which store the window’s width and height. 
Before reading on, copy this code to a new text file, and save it in your working directory as index.html. 
渲染器 
A renderer is a tool that displays scenes right in your browser. 
There are a few different renderers: WebGL is the default one, and the others you can use are Canvas, SVG, CSS and DOM. 
They differ in a way everything is rendered, so the WebGL implementation will work differently than the CSS one, but the idea is to have it look exactly the same for the end user. 
Thanks to this approach, a fallback can be used if the primary technology is not supported by the browser. 
var renderer = new THREE.WebGLRenderer({ antialias: true }); 
renderer.setSize(WIDTH, HEIGHT); 
renderer.setClearColor(0xdddddd, 1); 
document.body.appendChild(renderer.domElement); 
We are creating a new WebGL renderer, setting it’s size to fit the whole available space on the screen and appending the DOM structure to the page. 
You probably noticed the antialias parameter in the first line — this enables the edges of the shapes to be rendered a little more smoothly. 
The setClearColor() method sets our background to a light gray colour instead of the default black one. 
Add this code into the second {{htmlelement(“script”)}} element, just below the JavaScript comment. 
场景 
A scene is the place where everything happens. 
When creating new objects in the demo, we will be adding them all to the scene to make them visible on the screen. 
In three.js, the scene is reperesented by a Scene object. 
Let’s create it, by adding the following line below our previous lines: 
var scene = new THREE.Scene(); 
Later on we will be using the .add() method to add objects to the scene. 
摄像机 
我们有渲染场景，但是我们仍然需要一个摄像机来观察场景 - 想象没有摄像机的电影场景。 
下面的代码将摄像机放在三维坐标系中，并将其指向我们的场景，这样人们就能看到一些东西： 
var camera = new THREE.PerspectiveCamera(70, WIDTH / HEIGHT); 
camera.position.z = 50; 
scene.add(camera); 
Add these lines to your code, below the prevous ones. 
There are other types of camera available (Cube, Orthographic), but the simplest is the Perspective one. 
To initialize it we have to set its field of view and aspect ratio — the first one is used to set how much is seen, and a proper aspect ratio is important for the objects on the screen to have the right proportions when rendered and not look stretched. 
Let’s explain the values we are setting in the code above: 
The value we set for the field of view, 70, is something we can experiment with — the higher the value, the greater the amount of scene the camera will show. 
Imagine a normal camera view, versus a fish eye effect, which allows a lot more to be seen. 
The default value is 50. 
The aspect ratio is set to the current width and height of the window so it will be dynamically adjusted. 
We could set a fixed ratio — for example 16 ⁄ 9, which is the aspect ratio of a widescreen TV. 
The default value is 1. 
The z position with the value of 50 units is the distance between the camera and the center of the scene on the z axis — here we’re moving the camera back so the objects on the scene can be viewed. 50 feels ok as it’s not too near and not too far and the sizes of the objects allow them to stay on the scene within the given field of view. 
The x and y values, if not specified, will default to 0. 
You should experiment with these values and see how they change what you see in the scene. 

{{GamesSidebar}} 
使用 GLSL 的着色器（shader），GLSL 是一门特殊的有着类似于 C 语言的语法，在图形管道 (graphic pipeline) 中直接可执行的 OpenGL 着色语言。 
着色器有两种类型——顶点着色器 (Vertex Shader) 和片段着色器（Fragment Shader）。 
前者是将形状转换到真实的 3D 绘制坐标中，后者是计算最终渲染的颜色和其他属性用的。 
GLSL 不同于 JavaScript, 它是强类型语言，并且内置很多数学公式用于计算向量和矩阵。 
快速编写着色器非常复杂，但创建一个简单的着色器并不难。 
在这篇文章我们将介绍使用着色器的基础知识，并且构建一个使用 Three.js 的例子来加速代码编写。 
你可能记得基本原理那篇文章，一个顶点 (vertex) 是在空间中有自己 3D 坐标的点，并且通常包含些被定义的其他信息。 
空间本身会被坐标系统定义。 
在那个 3D 空间中一切都是关于形状的呈现。 
着色器类型 
一个着色器实际上就是一个绘制东西到屏幕上的函数。 
着色器运行在 GPU 中，它对这些操作进行了很多的优化，这样你就可以卸载很多不必要的 CPU, 然后集中处理能力去执行你自己的代码。 
顶点着色器 
顶点着色器操作 3D 空间的坐标并且每个顶点都会调用一次这个函数。 
其目的是设置 gl_Position 变量——这是一个特殊的全局内置变量，它是用来存储当前顶点的位置： void main() { gl_Position = makeCalculationsToHaveCoordinates; } 
这个 void main() 函数是定义全局gl_Position 变量的标准方式。 
所有在这个函数里面的代码都会被着色器执行。 
如果将 3D 空间中的位置投射到 2D 屏幕上这些信息都会保存在计算结果的变量中。 
片段着色器 
片段 (或者纹理) 着色器 在计算时定义了每像素的 RGBA 颜色 — 每个像素只调用一次片段着色器。 
这个着色器的作用是设置 gl_FragColor 变量，也是一个 GLSL 内置变量： void main() { gl_FragColor = makeCalculationsToHaveColor; } 
计算结果包含 RGBA 颜色信息。 
示例 
让我们构建一个简单的例子来解释这些着色器的动作。 
假设你已经看过Three.js 教程并掌握了场景，物体和材质的基本概念。 
备注： 记住你没必要使用 Three.js 或者其他库来编写着色器——纯WebGL 完全够了。 
我们这里使用 Three.js 来制作背景代码更简单和易理解。 所以你只需关注着色器代码。 
Three.js 和其他 3D 库给你抽象了很多东西出来——如果你想要用纯 WebGL 创建这个例子，你得写很多其他的代码才能运行。 
环境设置 
要开始编写 WebGL 着色器你不需要做太多，只需： 
确保你在使用对 WebGL 有良好支持的现代浏览器，比如最新版的 Firefox 或 Chrome. 
创建一个目录保存你的实验。 
拷贝一份的 压缩版的 Three.js 库 到你的目录。 
HTML 结构 
这是将用到的 HTML 结构。 
<! 
doctype html> 
<html> 
<head> 
<meta charset="utf-8" /> 
<title>MDN Games: Shaders demo</title> 
<style> 
body { 
margin: 0; 
padding: 0; 
font-size: 0; 
} 
canvas { 
width: 100%; 
height: 100%; 
} 
</style> 
<script src="three.min.js"></script> 
</head> 
<body> 
<script id="vertexShader" type="x-shader/x-vertex"> 
// 顶点着色器代码在这里 
</script> 
<script id="fragmentShader" type="x-shader/x-fragment"> 
// 片段着色器代码在这里 
</script> 
<script> 
// 场景设置在这里 
</script> 
</body> 
</html> 
其包含了一些基本信息比如文档的 {{htmlelement(“title”)}}，并且设置了 {{htmlelement(“canvas”)}} 元素 css 样式的宽高，Three.js 会插入到页面中占满整个可视区域。{{ 
htmlelement(“script”)}} 元素在包含 Three.js 库的 {{htmlelement(“head”)}} 中。 
我们的代码将写在 {{htmlelement(“body”)}} 标签中的 script 标签中： 
首先将包含顶点着色器。 
最后会包含一些生成实际场景的 JavaScript 代码。 
阅读之前，复制这些代码到一个新的文本文件中，保存到你的工作目录作为 index.html. 
我们将在这个文件中创建一个简单的立方体来解释着色器是如何工作的。 
立方体源代码 
我们可以复用Building up a basic demo with Three.js 中立方体的源代码，大多数元素例如渲染器，摄像机和灯光都没有发生改变，但是基本的材质会用到自己写的着色器。 
去cube.html file on GitHub中，复制第二个{{htmlelement(“script”)}}元素中所有的 JavaScript 代码，粘贴到当前例子中的第三个<script> 标签中。 
保存并运行 index.html — 然后你会看到一个蓝色立方体 
顶点着色器代码 
让我们继续编写顶点着色器 — 添加下面这段代码到你 body 的第一个 <script> 标签： 
void main() { 
gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x+10.0, position.y, position.z+5.0, 1.0); 
} 
每次的gl_Position 的结果是计算 model-view 矩阵和投射矩阵和投射矩阵相乘并得到最后的顶点位置。 
备注： 你可以在 顶点处理中学到更多关于模型，视图和投射变换，并且你可以在文末看到更多学习链接。 
projectionMatrix 和 modelViewMatrix 两个函数都是 Three.js 提供的，并且传入了一个新的 3D 位置向量，转成着色器之后直接导致立方体向 x 轴移动 10 个单位，向z 轴移动了 5 个单位。 
我们可以忽略第四个参数并且保持为默认的1.0 ; 这是用来控制 3D 空间中订单位置裁剪的，这个例子中不需要。 
纹理着色器代码 
现在我们将添加纹理着色器代码 — 将以下代码复制到第二个 <script> 标签中： 
void main() { 
gl_FragColor = vec4(0.0, 0.58, 0.86, 1.0); 
} 
这将设置一个 RGBA 颜色来重建当前的蓝色灯光 — 前三个浮点数 (范围是 0.0 到 1.0) 代表红，绿，蓝，第四个值代表 alpha 通道，控制透明度 (0.0 完全透明，1.0 是完全不透明). 
设置着色器 
实际上是创建了一个新的着色器给立方体，先用 basicMaterial 来定义： 
// var basicMaterial = new THREE.MeshBasicMaterial({color: 0x0095DD}); 
然后创建 shaderMaterial: 
var shaderMaterial = new THREE.ShaderMaterial({ 
vertexShader: document.getElementById("vertexShader").textContent, 
fragmentShader: document.getElementById("fragmentShader").textContent, 
}); 
这个着色器材质使用脚本中的代码并将它们赋予给材质所赋予的物体 
然后，在定义立方体材质那一行我们需要替换basicMaterial : 
var cube = new THREE.Mesh(boxGeometry, basicMaterial); 
使用新创建的 shaderMaterial: 
var cube = new THREE.Mesh(boxGeometry, shaderMaterial); 
Three.js 编译和运行这两个这两个着色器到材质所在的网格 (mesh) 上。 
在这个例子中，为立方体添加了有顶点和纹理着色器。 
好了，你已经创建了最简单的着色器，祝贺！ 
下图是立方体最终效果： 
Three.js blue cube demo 
它看起来好像和 Three.js 的立方体 demo 一样，但不同的是，位置有点轻微变化，而且同样的蓝色使用的是着色器实现。 
你可以看看实际操作，这里有最终代码:{{JSFiddleEmbed(“https://jsfiddle.net/end3r/LL55bhrz/”,““,”350”)}} 
你也可以在 GitHub 看这个例子。 
总结 
本文教了你最基本的着色器实现。 
我们虽然只能做这么多，但你可以用着色器做很更多炫酷的事情 — 在 ShaderToy 上去看真正炫酷的例子找找灵感吧 
其他链接 
学习 WebGL — 基本 WebGL 知识 
WebGL 着色器和 WebGL 中的 GLSL 基础 — GLSL 特定信息 

{{GamesSidebar}} 
为了 web 上丰富的游戏体验，一个好武器是 webGL，并呈现在 HTML 的 {{htmlelement(“canvas”)}}元素上。 
WebGL 基本上是 Web 的 OpenGL ES 2.0 版本 — 作为一个 JavaScript API，它提供了能构建丰富的交互式动画和游戏的工具。 
你可以使用硬件加速的 JavaScript 生成和呈现动态 3D 图像。 
文档和浏览器支持 
WebGL项目的文档和规范由Khronos Group 维护，而非大部分 Web APIs 采用的 W3C。 
它很好地支持了现代浏览器甚至是移动手机，由此你无需担心太多。 
主流浏览器均支持 WebGL，你需要关注的仅仅是在你使用的设备上进行优化。 
目前进行的尝试是在不久的将来促成 WebGL 2.0 版本（基于 OpenGL ES 3.0 版本）的发布，WebGL 2.0 版本将会带来许多改进，并且将会帮助开发者使用现在强大的硬件，为现代 Web 开发游戏。 
对基本 3D 理论的解释 
基本 3D 理论的核心围绕在 3D 空间的形状呈现上，通过使用坐标系计算出它们的位置。 
寻找你所要的信息，请参考我们的文章 Explaining basic 3D theory 。 
预先概念 
你可以使用 WebGL 做很多事情。 
你需要深入了解和学习一些预先的理念——像着色器、碰撞检测或最新的热门话题——Web 上的虚拟现实。 
着色器 
值得提及的是着色器，着色器本身就是一个独立的故事。 
着色器使用 GLSL，一个特殊的和 C 语言相似的 OpenGL 着色语言，但 C 语言直接通过图像管道执行。 
碰撞检测 
很难想象没有碰撞检测的游戏——我们总是需要计算出一个物体什么时候会撞击到另一个物体。 
我们有一些可利用的信息供你学习： 
2D 碰撞检测 3D 碰撞检测 
Web 虚拟现实 
虚拟现实这一概念并不新鲜，但由于硬件的进步，它大有席卷网络之势，如Oculus Rift和（目前实验性的） WebVR API，它们从 VR 硬件中捕获信息并使其可在 JavaScript 中应用。 
有关的详细信息请阅读 WebVR-Web 虚拟现实。 
还有一篇用 A-Frame 构建基本 demo的文章，向你展示了使用A-Frame框架构建 3D 环境的虚拟现实是多么的简单。 
库和框架的兴起 
编码原生 WebGL 是相当复杂的，但从长远来看，你需要了解它，如果你的项目变得更加先进（请从参阅我们的WebGL 文档开始）。 
对于现实世界中的项目，你可能还会使用框架来加快开发，并帮助你管理正在处理的项目。 
使用 3D 游戏框架还有助于优化性能，因为你使用的工具会处理很多问题，因此你可以专注于构建游戏本身。 
最流行的 JavaScript 3D 库是Three.js，这是一个多用途工具，它使常见的 3D 技术更易于实现。 
还有其他流行的游戏开发库和框架值得检查。 A-Frame、PlayCanvas和Babylon.js是最容易辨认的，拥有丰富的文档、在线编辑器和活跃的社区。 
使用 A-Frame 搭建一个基础 Demo 
A-Frame 是一个用于搭建 3D 和 VR 体验的 Web 框架。 
在内部，它是一个具有已声明的实体组件模式的 three.js 框架，也就是说我们只需借助 HTML 即可搭建场景。 
请参阅Building up a basic demo with A-Frame子页面来了解创建 Demo 的步骤。 
使用 Babylon.js 搭建一个基础 Demo 
Babylon.js 是最受开发者欢迎的 3D 游戏引擎之一。 
与其他任何 3D 库一样，它提供了内置函数，帮助你更快地实现常见的 3D 功能。 
请参阅 Building up a basic demo with Babylon.js 子页，其中包括建立一个开发环境，构建必要的 HTML，以及编写 JavaScript 代码。 
使用 PlayCanvas 搭建一个基础 Demo 
PlayCanvas 是一个流行的 GitHub 开源 3D WebGL 游戏引擎，有在线编辑器和良好的文档。 
更多详细信息 请参阅Building up a basic demo with PlayCanvas ，文章将进一步介绍如何使用 PlayCanvas 库和联机编辑器搭建例子。 
使用 Three.js 搭建一个基础 Demo 
Three.js，与任何其他库一样，它给了你一个巨大的便利：不必编写数百行 WebGL 代码来构建任何有趣的东西，你可以使用内置的 helper 函数来轻松、快速地完成任务。 
请参阅 Building up a basic demo with Three.js 子页 逐步创建 Demo。 
使用 Whitestorm.js 搭建一个基础 Demo 
请参阅 Building up a basic demo with Whitestorm.js 了解更多信息、教程和例子制作基本的，甚至配合 Three.js 制作更复杂的应用程序或游戏。 其他工具 
Unity 和 Unreal 可以将你的游戏通过 asm.js 输出到 WebGL，因此你可以自由地使用这些工具与技术来构建可被输出到 Web 上的游戏。 
Where to go next 
With this article we just scratched the surface of what’s possible with currently available technologies. 
You can build immersive, beautiful and fast 3D games on the Web using WebGL, and the libraries and frameworks build on top of it. 
Source code 
You can find all the source code for this series demos on GitHub. 
APIs 
Canvas API 
WebGL API 
WebVR API 
Frameworks 
Three.js 
PlayCanvas 
Babylon.js 
A-Frame 
Tutorials 
Building up a basic demo with Three.js 
Building up a basic demo with Whitestorm.js 
Building up a basic demo with Babylon.js 
Building up a basic demo with A-Frame 

{{GamesSidebar}} 
每个中型或大型游戏都应编译asm.js代码作为异步脚本的一部分，以便浏览器能够最大限度地灵活地优化编译过程。 
在 Gecko 中，异步编译允许 JavaScript 引擎在游戏加载时缓存主线程的 asm.js，并缓存生成的机器代码，这样游戏就不需要在随后的加载中编译（从 Firefox 28 开始）。 
要查看差异，请切换javascript.options.parallel_parsing in about:config. 
异步执行 
获取异步编译非常简单：编写 JavaScript 时，只需使用 async 属性即可： 
<script async src="file.js"></script> 
或者，通过脚本来做同样的事情： 
const script = document.createElement("script"); 
script.src = "file.js"; 
document.body.appendChild(script); 
（从脚本中创建的脚本默认为异步。） 
默认的 HTML shell Emscripten 生成后者。 
什么时候用 async 或者不用？ 
两种常见的情况下是脚本是非异步的（由HTML 规范定义） 
<script async>code();</script> 
以及 
const script = document.createElement("script"); 
script.textContent = "code()"; 
document.body.appendChild(script); 
两者都被视为“内联”脚本，阻塞其余所有任务，进行编译，编译完成后立即执行。 
如果你的代码是一个 JS 字符串呢？ 
你应该使用带有对象 URL（object URL）的 Blob 对象，而不是使用 eval 或 innerHTML，这两者都会触发同步编译： 
const blob = new Blob([codeString]); 
const script = document.createElement("script"); 
const url = URL.createObjectURL(blob); 
script.onload = script.onerror = () => URL.revokeObjectURL(url); 
script.src = url; 
document.body.appendChild(script); 
使用src而不是innerHTML，则该脚本是异步的。 

{{GamesSidebar}} 
One of HTML5’s main advantages as a game development platform is the ability to run on various platforms and devices. 
Streamlining cross device differences creates multiple challenges, not least when providing appropriate controls for different contexts. 
In this series of articles we will show you how you can approach building a game that can be played using touchscreen smartphones, mouse and keyboard, and also less common mechanisms such as gamepads. 
Case study 
We’ll be using the Captain Rogers: Battle at Andromeda demo as an example. 
Captain Rogers: Battle at Andromeda - cover of the game containing Enclave Games and Blackmoon Design logos, Roger’s space ship and title of the game. 
Captain Rogers was created using the Phaser framework, the most popular tool for simple 2D game development in JavaScript right now, but it should be fairly easy to reuse the knowledge contained within these articles when building games in pure JavaScript or any other framework. 
If you’re looking for a good introduction to Phaser, then check the 2D breakout game using Phaser tutorial. 
In the following articles we will show how to implement various different control mechanisms for Captain Rogers to support different platforms — from touch on mobile, through keyboard/mouse/gamepad on desktop, to more unconventional ones like TV remote, shouting to or waving your hand in front of the laptop, or squeezing bananas. 
Setting up the environment 
Let’s start with a quick overview of the game’s folder structure, JavaScript files and in-game states, so we know what’s happening where. 
The game’s folders look like this: 
Captain Rogers: Battle at Andromeda - folder structure of the games’ project containing JavaScript sources, images and fonts. 
As you can see there are folders for images, JavaScript files, fonts and sound effects. 
The src folder contains the JavaScript files split as a separate states — Boot.js, Preloader.js, MainMenu.js and Game.js — these are loaded into the index file in this exact order. 
The first one initializes Phaser, the second preloads all the assets, the third one controls the main menu welcoming the player, and the fourth controls the actual gameplay. 
Every state has its own default methods: preload(), create(), and update(). 
The first one is needed for preloading required assets, create() is executed once the state had started, and update() is executed on every frame. 
For example, you can define a button in the create() function: 
create: function() { 
// ... 
var buttonEnclave = this.add.button(10, 10, 'logo-enclave', this.clickEnclave, this); 
// ... 
} 
It will be created once at the start of the game, and will execute this.clickEnclave() action assigned to it when clicked, but you can also use the mouse’s pointer value in the update() function to make an action: 
update: function() { 
// ... 
if(this.game.input.mousePointer.isDown) { 
// do something 
} 
// ... 
} 
This will be executed whenever the mouse button is pressed, and it will be checked against the input’s isDown boolean variable on every frame of the game. 
That should give you some understanding of the project structure. 
We’ll be playing mostly with the MainMenu.js and Game.js files, and we’ll explain the code inside the create() and update() methods in much more detail in later articles. 
Pure JavaScript demo 
There’s also a small online demo with full source code available on GitHub where the basic support for the control mechanisms described in the articles is implemented in pure JavaScript. 
It will be explained in the given articles themselves below, but you can play with it already, and use the code however you want for learning purposes. 
The articles 
JavaScript is the perfect choice for mobile gaming because of HTML5 being truly multiplatform; all of the following articles focus on the APIs provided for interfacing with different control mechanisms: 
Mobile touch controls — The first article will kick off with touch, as the mobile first approach is very popular. 
Desktop mouse and keyboard controls — When playing on a desktop/laptop computer, providing keyboard and mouse controls is essential to provide an acceptable level of accessibility for the game. 
Desktop gamepad controls — The Gamepad API rather usefully allows gamepads to be used for controlling web apps on desktop/laptop, for that console feel. 
Unconventional controls — The final article showcases some unconventional control mechanisms, from the experimental to the slightly crazy, which you might not believe could be used to play the game. 

{{GamesSidebar}} 
{{NextMenu(“Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard”, “Games/Techniques/Control_mechanisms”)}} 
未来手游一定是 Web 的天下，许多开发在游戏开发过程中首先选择手游 — 既然如此，触摸控制是不可少的。 
我们将在本教程中了解怎样简单地在移动端 H5 游戏中实现触摸控制，只要移动端支持触摸，你就可以尽情的玩。 
说明：游戏 Captain Rogers: Battle at Andromeda 是基于Phaser 和 Phaser-based 管理控制，但它也可以用纯 JavaScript 实现。 
使用 Phaser 的好处它提供了辅助变量和方法可以直接调用，有助于快速的开发游戏，这需要根据项目实际情况选择。 
纯 JavaScript 方式实现 
我们可以实现自己的触摸事件 — 给 document 添加事件监听，并传入自定义功能的方法，非常简单： 
var el = document.getElementsByTagName("canvas")[0]; 
el.addEventListener("touchstart", handleStart); 
el.addEventListener("touchmove", handleMove); 
el.addEventListener("touchend", handleEnd); 
el.addEventListener("touchcancel", handleCancel); 
这样，在移动设备上屏幕上触摸游戏的 {{htmlelement(“canvas”)}} 将触发这些事件，因为我们就可以随意操控游戏（如：移动太空船）。 
事件如下所示： 
touchstart 当用户手指放在屏幕上触发。 
touchmove 当他们在屏幕上移动手指时触发。 
touchend 当用户在屏幕上停止移动时触发。 
touchcancel 触摸被取消是触发，例如当用户将他们的手指移动到屏幕之外时。 
备注： 这篇 touch events 参考文章提供了更多的实例和介绍。 
纯 JavaScript 示例 
这个实现了移动端触摸的little demo代码已经放到了 GibHub 上，我们下载这个示例就可以实现在移动端屏幕上移动飞船。 
我们将两种事件：touchstart 和touchmove 放到一个方法里处理。 
为什么呢？ 
touchHandler 方法定义的飞船位置变量适合下面两种情况下：当玩家触摸时，但不移动它（touchstart）和当手指在屏幕上开始移动（touchmove）： 
document.addEventListener("touchstart", touchHandler); 
document.addEventListener("touchmove", touchHandler); 
touchHandler 方法的代码如下： 
function touchHandler(e) { 
if (e.touches) { 
playerX = e.touches[0].pageX - canvas.offsetLeft - playerWidth / 2; 
playerY = e.touches[0].pageY - canvas.offsetTop - playerHeight / 2; 
output.innerHTML = "Touch: " + " x: " + playerX + ", y: " + playerY; 
e.preventDefault(); 
} 
} 
If the touch occurs (touches object is not empty), then we will have all the info we need in that object. 
We can get the first touch (e.touches[0], our example is not multitouch-enabled), extract the pageX and pageY variables and set the player’s ship position on the screen by subtracting the Canvas offset (distance from the Canvas and the edge of the screen) and half the player’s width and height. 
Touch controls for the player’s ship, with visible output of the x and y position. 
To see if it’s working correctly we can output the x and y positions using the output element. 
The preventDefault() function is needed to prevent the browser from moving — without it you’d have the default behaviour, and the Canvas would be dragged around the page, which would show the browser scroll bars and look messy. 
Touch events in Phaser 
We don’t have to do this on our own; frameworks like Phaser offer systems for managing touch events for us — see managing the touch events. 
Pointer theory 
A pointer represents a single finger on the touch screen. 
Phaser starts two pointers by default, so two fingers can perform an action at once. 
Captain Rogers is a simple game — it can be controlled by two fingers, the left one moving the ship and the right one controlling the ship’s gun. 
There’s no multitouch or gestures — everything is handled by single pointer inputs. 
You can add more pointers to the game by using; this.game.input.addPointer up to ten pointers can be managed simultaneously. 
The most recently used pointer is available in the this.game.input.activePointer object — the most recent finger active on the screen. 
If you need to access a specific pointer, they are all available at, this.game.input.pointer1, this.game.input.pointer2, etc. 
They are assigned dynamically, so if you put three fingers on the screen, then, pointer1, pointer2, and pointer3 will be active. 
Removing the second finger, for example, won’t affect the other two, and setting it back again will use the first available property, so pointer2 will be used again. 
You can quickly get the coordinates of the most recently active pointer via the this.game.input.x and this.game.input.y variables. 
Input events 
Instead of using the pointers directly it is also possible to listen for this.game.input events, like onDown, onUp, onTap and onHold: 
this.game.input.onDown.add(itemTouched, this); 
function itemTouched(pointer) { 
// do something 
} 
The itemTouched() function will be executed when the onDown event is dispatched by touching the screen. 
The pointer variable will contain the information about the pointer that activated the event. 
This approach uses the generally available this.game.input object, but you can also detect the actions on any game objects like sprites or buttons by using onInputOver, onInputOut, onInputDown, onInputUp, onDragStart, or onDragStop: 
this.button.events.onInputOver.add(itemTouched, this); 
function itemTouched(button, pointer) { 
// do something 
} 
That way you’ll be able to attach an event to any object in the game, like the player’s ship, and react to the actions performed by the user. 
An additional advantage of using Phaser is that the buttons you create will take any type of input, whether it’s a touch on mobile or a click on desktop — the framework sorts this out in the background for you. 
Implementation 
The easiest way to add an interactive object that will listen for user input is to create a button: 
var buttonEnclave = this.add.button( 
10, 
10, 
"logo-enclave", 
this.clickEnclave, 
this, 
); 
This one is formed in the MainMenu state — it will be placed ten pixels from the top left corner of the screen, use the logo-enclave image, and execute the clickEnclave() function when it is touched. 
This will work on mobile and desktop out of the box. 
There are a few buttons in the main menu, including the one that will start the game. 
For the actual gameplay, instead of creating more buttons and covering the small mobile screen with them, we can use something a little bit different: we’ll create invisible areas which respond to the given action. 
From a design point of view, it is better to make the field of activity bigger without covering half of the screen with button images. 
For example, tapping on the right side of the screen will fire the weapon: 
this.buttonShoot = this.add.button( 
this.world.width * 0.5, 
0, 
"button-alpha", 
null, 
this, 
); 
this.buttonShoot.onInputDown.add(this.goShootPressed, this); 
this.buttonShoot.onInputUp.add(this.goShootReleased, this); 
The code above will create a new button using a transparent image that covers the right half of the screen. 
You can assign functions on input down and input up separately if you’d like to perform more complicated actions, but in this game touching the right side of the screen will simply fire the bullets to the right — this is all we need in this case. 
Moving the player could be managed by creating the four directional buttons, but we can take the advantage of touch screens and drag the player’s ship around: 
var player = this.game.add.sprite(30, 30, "ship"); 
player.inputEnabled = true; 
player.input.enableDrag(); 
player.events.onDragStart.add(onDragStart, this); 
player.events.onDragStop.add(onDragStop, this); 
function onDragStart(sprite, pointer) { 
// do something when dragging 
} 
We can pull the ship around and do something in the meantime, and react when the drag is stopped. 
Hauling in Phaser, if enabled, will work out of the box — you don’t have to set the position of the sprite yourself manually, so you could leave the onDragStart() function empty, or place some debug output to see if it’s working correctly. 
The pointer element contains the x and y variables storing the current position of the dragged element. 
Dedicated plugins 
You could go even further and use dedicated plugins like Virtual Joystick — this is a paid, official Phaser plugin, but you can find free and open source alternatives. 
The initialization of Virtual Joystick looks like this: 
this.pad = this.game.plugins.add(Phaser.VirtualJoystick); 
this.stick = this.pad.addStick(30, 30, 80, "generic"); 
In the create() function of the Game state we’re creating a virtual pad and a generic stick that has four directional virtual buttons by default. 
This is placed 30 pixels from the top and left edges of the screen and is 80 pixels wide. 
The stick being pressed can be handled during the gameplay in the update function like so: 
if (this.stick.isDown) { 
// move the player 
} 
We can adjust the player’s velocity based on the current angle of the stick and move him appropriately. 
摘要 
这篇文章主要讲解如何在移动端实现触摸控制; 下一篇文章我们将看到怎样添加键盘和鼠标支持。 
{{NextMenu(“Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard”, “Games/Techniques/Control_mechanisms”)}} 


{{GamesSidebar}} 
这个页面为想要使用开放的网页技术来开发游戏的人列举出了必要的核心技术。 
使用 asm.js 中的异步脚本 
: 尤其在制作中大型游戏时，异步脚本是一项必备技术，你游戏中的 JavaScript 因此可以在主进程之外被编译，并被缓存以之后游戏的运行，这会带来显著的性能提升。 
这篇文章解释了如何做到。 
Optimizing startup performance 
: How to make sure your game starts up quickly, smoothly, and without appearing to lock up the user’s browser or device. 
Using WebRTC peer-to-peer data channels 
: In addition to providing support for audio and video communication, WebRTC lets you set up peer-to-peer data channels to exchange text or binary data actively between your players. 
This article explains what this can do for you, and shows how to use libraries that make this easy. 
Efficient animation for web games 
: Audio is an important part of any game — it adds feedback and atmosphere. 
Web-based audio is maturing fast, but there are still many browser differences to negotiate. 
This article provides a detailed guide to implementing audio for web games, looking at what works currently across as wide a range of platforms as possible. 
2D collision detection 
: A concise introduction to collision detection in 2D games. 
Tilemaps 
: Tiles are a very popular technique in 2D games for building the game world. 
These articles provide an introduction to tilemaps and how to implement them with the Canvas API. 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Extra_lives”, “Games/Workflows/2D_Breakout_game_Phaser/Buttons”)}} 
这是Gamedev Phaser 教程 16 的第 14 步。 
你可以在Gamedev-Phaser-Content-Kit / demos / lesson14.html完成本课程后找到源代码。 
为了使游戏看起来更加多汁和活泼，我们可以使用动画和补间。 
这将导致更好，更有趣的体验。 
让我们来探讨如何在游戏中实现 Phaser 动画和补间。 
动画 
在 Phaser，动画中，涉及从外部来源获取 spritesheet 并依次显示 sprites。 
作为一个例子，当碰到一些东西时，我们会让球摇摆。 
首先，从 Github 抓取 spritesheet并将其保存在你的/img目录中。 
接下来，我们将加载 spritesheet - 将以下行放在preload()函数的底部： 
game.load.spritesheet("ball", "img/wobble.png", 20, 20); 
而不是加载单个图像的球，我们可以加载整个 spritesheet - 不同图像的集合。 
我们将按顺序显示精灵，创造动画的幻觉。 
该spritesheet()方法的两个额外的表格确定给定 spritesheet 文件中每个单个框架的宽度和高度，指示程序如何切割以获取单个框架。 
加载动画 
接下来，进入你的 create() 函数，找到加载球精灵的行，下面的调用animations.add()如下所示： 
ball = game.add.sprite(50, 250, "ball"); 
ball.animations.add("wobble", [0, 1, 0, 2, 0, 1, 0, 2, 0], 24); 
要向对象添加动画，我们使用该animations.add()方法，其中包含以下参数 
我们为动画选择的名称 
一个数组，定义在动画过程中显示帧的顺序。 
如果你再次查看wobble.png图像，你会看到有三个框架。 
Phaser 提取它们并将它们存储在数组中 - 位置 0，1 和 2. 
上面的数组表示我们显示帧 0，然后是 1，然后是 0 等。 
帧速率，以 fps 为单位。 
由于我们以 24fps 运行动画，有 9 帧，动画每秒将显示三次以下。 
当球击中桨时应用动画 
在arcade.collide()处理球和桨（第一行内部update()，见下文）之间的碰撞的方法调用中，我们可以添加一个额外的参数，该参数指定每次发生碰撞时执行的功能，与该ballHitBrick()功能相同。 
更新内部的第一行update()，如下所示： 
function update() { 
game.physics.arcade.collide(ball, paddle, ballHitPaddle); 
game.physics.arcade.collide(ball, bricks, ballHitBrick); 
paddle.x = game.input.x || game.world.width * 0.5; 
} 
然后我们可以创建ballHitPaddle()函数（具有ball和paddle作为默认参数），在调用时播放摆动动画。 
在结束</script>标签之前添加以下方法： 
function ballHitPaddle(ball, paddle) { 
ball.animations.play("wobble"); 
} 
每次球击中桨时都会播放动画。 
你也可以animations.play()在ballHitBrick()函数内添加调用，如果你觉得它会使游戏看起来更好。 
补间 
而动画依次播放外部精灵，补间游戏中物体的属性平滑，如宽度或不透明度。 
让我们在游戏中增加一个补间，使砖块在被球击中时顺利消失。 
转到你的ballhitBrick()功能，找到你的brick.kill();行，并将其替换为以下内容： 
var killTween = game.add.tween(brick.scale); 
killTween.to({ x: 0, y: 0 }, 200, Phaser.Easing.Linear.None); 
killTween.onComplete.addOnce(function () { 
brick.kill(); 
}, this); 
killTween.start(); 
让我们来看看这里，看看这里发生了什么： 
当定义一个新的补间时，你必须指定哪些属性将被补间 - 在我们的例子中，而不是在被球击中时立即隐藏砖块，我们将把它们的宽度和高度缩放到零，所以它们将很好地消失。 
最后，我们使用该add.tween()方法，指定brick.scale为参数，因为这是我们想要补间。 
该to()方法定义补间结束时对象的状态。 
它需要一个包含所选参数的期望结束值的对象（比例取尺度值，1 为大小的 100％，0 为大小的 0％等），补间的时间（以毫秒为单位）以及使用的宽松类型补间。 
我们还将添加可选的onComplete事件处理程序，该处理程序定义了在补间程序完成时要执行的函数。 
最后一件事是立即开始补间start()。 
这是补间定义的扩展版本，但是我们也可以使用速记语法： 
game.add 
.tween(brick.scale) 
.to({ x: 2, y: 2 }, 500, Phaser.Easing.Elastic.Out, true, 100); 
这个补间将使用弹性宽松在半秒内将砖的比例翻倍，将自动启动，延迟 100 毫秒。 
比较你的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/9o4pakrb/”,““,”400”)}} 
下一步 
动画和 tweens 看起来很不错，但我们可以添加更多的我们的游戏 - 在下一节我们将看看处理按钮输入。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Extra_lives”, “Games/Workflows/2D_Breakout_game_Phaser/Buttons”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Physics”, “Games/Workflows/2D_Breakout_game_Phaser/Player_paddle_and_controls”)}} 
这是Gamedev Phaser 教程的第 6 步。 
在Gamedev-Phaser-Content-Kit / demos / lesson06.html完成本课后，你可以找到源代码。 
现在已经介绍了物理引擎，我们可以开始在游戏中实现碰撞检测 - 首先我们来看看墙壁。 
反弹边界 
让我们的球从墙壁上弹起的最简单的方法是告诉框架，我们想要将 <canvas> 元素的边界视为墙壁，而不是让球移过它们。 
在 Phaser 中，可以使用该 collideWorldsBound 属性轻松实现。 
在现有 game.physics.enable() 方法调用之后添加此行： 
ball.body.collideWorldBounds = true; 
现在球将停在屏幕的边缘，而不是消失，但它不会弹起。 
为了使这种情况发生，我们必须设置它的 bounciness。 
在上一行下面添加以下行： 
ball.body.bounce.set(1); 
再次尝试重新加载 index.html - 现在你应该看到球从墙壁上弹起并在画布区域内移动。 
比较你的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/dcw36opz/”,““,”400”)}} 
下一步 
现在开始看起来更像是一个游戏，但是我们无法以任何方式控制它 - 现在是介绍玩家挡板和控制的时候了。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Physics”, “Games/Workflows/2D_Breakout_game_Phaser/Player_paddle_and_controls”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Game_over”, “Games/Workflows/2D_Breakout_game_Phaser/Collision_detection”)}} 
这是Gamedev Phaser 教程 16 的第 9 步。 
在Gamedev-Phaser-Content-Kit / demos / lesson09.html完成本课后，你可以找到源代码。 
建立砖块比将单个对象添加到屏幕要复杂一点，尽管使用 Phaser 还是比纯 JavaScript 更容易。 
我们来探讨如何创建一组砖块，并使用循环在屏幕上打印。 
定义新变量 
首先，我们定义所需的变量 - 在以前的变量定义中添加以下内容： 
var bricks; 
var newBrick; 
var brickInfo; 
该bricks变量将用于创建一个组，newBrick将在循环的每次迭代中添加到组中的新对象，brickInfo并将存储我们需要的所有数据。 
渲染砖图像 
接下来，我们加载砖的图像 - load.image()在其他地方添加以下调用： 
function preload() { 
// ... 
game.load.image("brick", "img/brick.png"); 
} 
你还需要从 Github 抓取砖图像并将其保存在你的/img目录中。 
画砖 
我们将将所有用于绘制砖块的代码放在一个initBricks函数中，以使其与其余代码分离。 
initBricks在create()函数末尾添加一个调用： 
function create() { 
// ... 
initBricks(); 
} 
现在到函数本身。 
initBricks()在我们的游戏代码末尾添加功能，就在关闭</ script>标签之前，如下所示。 
首先我们已经包括了这个 brickInfo对象，因为这很快就会派上用场： 
function initBricks() { 
brickInfo = { 
width: 50, 
height: 20, 
count: { 
col: 3, 
}, 
offset: { 
top: 50, 
left: 60, 
}, 
padding: 10, 
}; 
} 
这个brickInfo对象将包含我们需要的所有信息：单个砖的宽度和高度，我们将在屏幕上看到的砖的行数和列数，顶部和左边的偏移量（画布上我们将开始绘制的位置）砖块）和每一列和砖块之间的填充。 
现在，让我们开始创建砖块 - 首先添加一个空组来包含砖块，在initBricks()函数底部添加以下行： 
bricks = game.add.group(); 
我们可以循环遍历行和列，以便在每次迭代中创建新的砖块 - 在上一行代码下面添加以下嵌套循环： 
for (c = 0; c < brickInfo.count.col; c++) { 
for (r = 0; r < brickInfo.count.row; r++) { 
// create new brick and add it to the group 
} 
} 
这样我们将创建我们需要的确切数量的砖，并将它们全部包含在一个组中。 
现在我们需要在嵌套循环结构中添加一些代码来绘制每个砖块。 
填写内容如下图所示： 
for (c = 0; c < brickInfo.count.col; c++) { 
for (r = 0; r < brickInfo.count.row; r++) { 
var brickX = 0; 
var brickY = 0; 
newBrick = game.add.sprite(brickX, brickY, "brick"); 
game.physics.enable(newBrick, Phaser.Physics.ARCADE); 
newBrick.body.immovable = true; 
newBrick.anchor.set(0.5); 
bricks.add(newBrick); 
} 
} 
在这里，我们循环遍历行和列，创建新的砖块并将其放在屏幕上。 
新创建的砖块为 Arcade 物理引擎启用，它的身体被设置为不可移动（所以当球被击中时它不会移动），我们还将锚点放在中间并添加砖到集团。 
目前的问题是，我们在一个地方绘制所有的砖，坐标（0,0）。 
我们需要做的是将每个砖块绘制在自己的 x 和 y 位置。 
更新brickX和brickY行如下： 
var brickX = r * (brickInfo.width + brickInfo.padding) + brickInfo.offset.left; 
var brickY = c * (brickInfo.height + brickInfo.padding) + brickInfo.offset.top; 
每个brickX位置都是brickInfo.width加brickInfo.padding号乘以行号r，加上brickInfo.offset.left; 用于所述逻辑brickY是不同之处在于它使用的值列号相同c，brickInfo.height和brickInfo.offset.top。 
现在每个砖都可以放置在正确的位置，每个砖块之间填充，并从左侧和顶部画布边缘偏移绘制。 
检查 initBricks() 代码 
这是功能的完整代码initBricks()： 
function initBricks() { 
brickInfo = { 
width: 50, 
height: 20, 
count: { 
col: 3, 
}, 
offset: { 
top: 50, 
left: 60, 
}, 
padding: 10, 
}; 
bricks = game.add.group(); 
for (c = 0; c < brickInfo.count.col; c++) { 
for (r = 0; r < brickInfo.count.row; r++) { 
var brickX = 
r * (brickInfo.width + brickInfo.padding) + brickInfo.offset.left; 
var brickY = 
c * (brickInfo.height + brickInfo.padding) + brickInfo.offset.top; 
newBrick = game.add.sprite(brickX, brickY, "brick"); 
game.physics.enable(newBrick, Phaser.Physics.ARCADE); 
newBrick.body.immovable = true; 
newBrick.anchor.set(0.5); 
bricks.add(newBrick); 
} 
} 
} 
如果你现在重新加载index.html，你应该看到在屏幕上打印的砖块彼此相距甚远。 
比较你的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/cck2b9e8/”,““,”400”)}} 
下一步 
有些东西丢失了 球不经停，经过砖块 - 我们需要适当的碰撞检测。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Game_over”, “Games/Workflows/2D_Breakout_game_Phaser/Collision_detection”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Animations_and_tweens”, “Games/Workflows/2D_Breakout_game_Phaser/Randomizing_gameplay”)}} 
这是Gamedev Phaser 教程 16 的第 15 步。 
你可以在Gamedev-Phaser-Content-Kit / demos / lesson15.html完成本课程后找到源代码 
而不是立即开始游戏，我们可以通过添加他们可以按的开始按钮将该决定留给玩家。 
我们来调查如何做到这一点。 
新变量 
我们需要一个变量来存储表示游戏当前是否正在播放的布尔值，另一个代表我们的按钮。 
将以下行添加到其他变量定义之下： 
var playing = false; 
var startButton; 
加载按钮 spritesheet 
我们可以加载按钮 spritesheet 与我们加载球的摆动动画相同的方式。 
将以下内容添加到preload()函数底部： 
game.load.spritesheet("button", "img/button.png", 120, 40); 
单个按钮框架宽 120 像素，高 40 像素。 
你还需要从 Github 抓取按钮 spritesheet，并将其保存在你的/img目录中。 
将按钮添加到游戏中 
使用该add.button方法可以将新的按钮添加到游戏中。 
将以下行添加到create()函数的底部： 
startButton = game.add.button( 
game.world.width * 0.5, 
game.world.height * 0.5, 
"button", 
startGame, 
this, 
1, 
0, 
2, 
); 
startButton.anchor.set(0.5); 
该button()方法的参数如下： 
按钮的 x 和 y 坐标 
要显示按钮的图形资产的名称 
按下按钮时将执行的回调函数 
this指定执行上下文的引用 
将用于过度，超出和向下事件的框架。 
备注： 超越事件与悬停相同，当指针从按钮中移出时，当按下按钮时，向下移动。 
现在我们需要定义startGame()上面代码中引用的函数： 
function startGame() { 
startButton.destroy(); 
ball.body.velocity.set(150, -150); 
playing = true; 
} 
当按下按钮时，我们删除按钮，设置球的初始速度并将playing变量设置为true。 
最后对于这一部分，回到你的create()函数，找到ball.body.velocity.set(150, -150);一行，并删除它。 
你只需要按下按钮时移动球，而不是之前！ 
在游戏开始之前仍然保持桨 
它按预期工作，但是当游戏尚未开始时，我们仍然可以移动桨，这看起来有点愚蠢。 
为了阻止这一点，我们可以利用playing变量，使得桨只有在游戏开始时才能移动。 
要做到这一点，调整update()功能如下所示： 
function update() { 
game.physics.arcade.collide(ball, paddle, ballHitPaddle); 
game.physics.arcade.collide(ball, bricks, ballHitBrick); 
if (playing) { 
paddle.x = game.input.x || game.world.width * 0.5; 
} 
} 
这样一来，在所有的装载和准备之后，但在实际游戏开始之前，桨是不可移动的。 
比较你的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/1rpj71k4/”,““,”400”)}} 
下一步 
在本系列文章中我们将做的最后一件事情是，通过添加一些随机化的方式，球从球上弹起来，使游戏更有趣。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Animations_and_tweens”, “Games/Workflows/2D_Breakout_game_Phaser/Randomizing_gameplay”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Build_the_brick_field”, “Games/Workflows/2D_Breakout_game_Phaser/The_score”)}} 
这是Gamedev Phaser 教程 16 的第 10 步。 
你可以在Gamedev-Phaser-Content-Kit / demos / lesson10.html完成本课程后找到源代码。 
现在接下来的挑战 - 球和砖块之间的碰撞检测。 
幸运的是，我们可以使用物理引擎来检查单个对象（如球和桨）之间的碰撞，也可以检测对象和组之间的碰撞。 
砖/球碰撞检测 
物理引擎使一切都变得更容易 - 我们只需要添加两个简单的代码。 
首先，在你的update()函数中添加一行，检查球和砖之间的碰撞检测，如下所示： 
function update() { 
game.physics.arcade.collide(ball, paddle); 
game.physics.arcade.collide(ball, bricks, ballHitBrick); 
paddle.x = game.input.x || game.world.width * 0.5; 
} 
球的位置是根据组中所有砖的位置计算的。 
第三个可选参数是发生冲突时执行的功能ballHitBrick()。 
创建这个新功能作为代码的底部，就在结束</script>标签之前，如下所示： 
function ballHitBrick(ball, brick) { 
brick.kill(); 
} 
就是这样！ 
重新加载你的代码，你应该看到新的碰撞检测工作正常。 
感谢 Phaser，有两个参数传递给函数 - 第一个是球，我们在碰撞方法中明确定义，第二个是球碰撞的砖组中的单个砖。 
在功能内部，我们从屏幕上删除所讨论的砖块，只需运行其kill()上的方法即可。 
你将期望在使用纯 JavaScript时编写更多自己的计算机来实现碰撞检测。 
这是使用框架的好处 - 你可以为 Phaser 留下大量无聊的代码，并专注于制作游戏中最有趣和最有趣的部分。 
比较你的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/wwneakwf/”,““,”400”)}} 
下一步 
我们可以打砖块并删除它们，这已经是游戏的一个很好的补充。 
结果，更好地计算被毁砖增加得分。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Build_the_brick_field”, “Games/Workflows/2D_Breakout_game_Phaser/The_score”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Win_the_game”, “Games/Workflows/2D_Breakout_game_Phaser/Animations_and_tweens”)}} 
这是Gamedev Phaser 教程 16 的第 13 步。 
你可以在Gamedev-Phaser-Content-Kit / demos / lesson13.html完成本课程后找到源代码。 
我们可以通过增加生活使游戏更愉快。 
在这篇文章中，我们将实施一个生活系统，以便玩家可以继续玩，直到他们失去了三个生命，而不仅仅是一个人。 
新变量 
在代码中的现有添加下面添加以下新变量： 
var lives = 3; 
var livesText; 
var lifeLostText; 
这些分别将存储生命数，显示剩余生命数的文本标签，以及当玩家失去生命之后将在屏幕上显示的文本标签。 
定义新的文本标签 
定义文本看起来像我们已经在分数课上已经做的。 
scoreText在create()函数内的现有定义下方添加以下行： 
livesText = game.add.text(game.world.width - 5, 5, "Lives: " + lives, { 
font: "18px Arial", 
fill: "#0095DD", 
}); 
livesText.anchor.set(1, 0); 
lifeLostText = game.add.text( 
game.world.width * 0.5, 
game.world.height * 0.5, 
"Life lost, click to continue", 
{ font: "18px Arial", fill: "#0095DD" }, 
); 
lifeLostText.anchor.set(0.5); 
lifeLostText.visible = false; 
在livesText与lifeLostText物体看起来非常相似的scoreText一个 - 它们定义在屏幕上的位置，显示实际文本和字体样式。 
前者被锚定在其右上边缘上，与屏幕正确对齐，后者位于中心位置，两者均使用anchor.set()。 
该lifeLostText会表示，只有当生命消失，因此其知名度初始设置为false。 
使我们的文字造型干燥 
正如你可能已经注意到，我们使用相同的造型为三种文本：scoreText，livesText和lifeLostText。 
如果我们想要更改字体大小或颜色，我们必须在多个地方进行。 
为了使我们更容易维护，将来我们可以创建一个单独的变量来保存我们的样式，让我们textStyle将其调用并放在文本定义之前： 
textStyle = { font: "18px Arial", fill: "#0095DD" }; 
现在我们可以在使用文本标签的时候使用这个变量 - 更新你的代码，使文本样式的多个实例被替换为变量： 
scoreText = game.add.text(5, 5, "Points: 0", textStyle); 
livesText = game.add.text( 
game.world.width - 5, 
5, 
"Lives: " + lives, 
textStyle, 
); 
livesText.anchor.set(1, 0); 
lifeLostText = game.add.text( 
game.world.width * 0.5, 
game.world.height * 0.5, 
"Life lost, click to continue", 
textStyle, 
); 
lifeLostText.anchor.set(0.5); 
lifeLostText.visible = false; 
这样一来，改变一个变量中的字体将会将更改应用于每个使用的地方。 
生活处理代码 
为了在我们的游戏中实现生活，让我们先改变球对onOutOfBounds事件的影响。 
而不是执行匿名函数并立即显示警报： 
ball.events.onOutOfBounds.add(function () { 
alert("Game over!" 
); 
location.reload(); 
}, this); 
我们将分配一个所谓的新功能ballLeaveScreen; 删除以前的事件处理程序（如上所示），并将其替换为以下行： 
ball.events.onOutOfBounds.add(ballLeaveScreen, this); 
我们想减少每次球离开帆布的人数。 
ballLeaveScreen()在代码末尾添加函数定义： 
function ballLeaveScreen() { 
lives--; 
if (lives) { 
livesText.setText("Lives: " + lives); 
lifeLostText.visible = true; 
ball.reset(game.world.width * 0.5, game.world.height - 25); 
paddle.reset(game.world.width * 0.5, game.world.height - 5); 
game.input.onDown.addOnce(function () { 
lifeLostText.visible = false; 
ball.body.velocity.set(150, -150); 
}, this); 
} else { 
alert("You lost, game over!" 
); 
location.reload(); 
} 
} 
而不是立即打印警报，当你失去了一生，我们首先从当前的数字减去一个生命，并检查它是否是一个非零值。 
如果是，那么玩家还是有一些生命剩下，可以继续玩 - 他们会看到生命中的消息，球和桨的位置将被重置在屏幕上和下一个输入（点击或触摸），消息将被隐藏球将再次开始移动。 
当可用生活数量达到零时，游戏结束，并显示游戏过期警报消息。 
事件 
你可能已经注意到了add()，并addOnce()在上面的两个代码块的方法调用，并想知道它们的区别。 
不同之处在于，该add()方法绑定给定的函数，并使其在每次事件发生时执行，同时addOnce()当你希望绑定函数只执行一次，然后解除绑定时有用，因此不会再次执行。 
在我们的例子中，每个outOfBounds事件ballLeaveScreen都将被执行，但当球离开屏幕时，我们只想从屏幕上删除一次消息。 
比较你的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/yk1c5n0b/”,““,”400”)}} 
下一步 
生活让游戏更加宽容 - 如果你失去一个生命，你还剩下两个，可以继续玩。 
现在让我们通过添加动画和补间来扩展游戏的外观和感觉。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Win_the_game”, “Games/Workflows/2D_Breakout_game_Phaser/Animations_and_tweens”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Player_paddle_and_controls”, “Games/Workflows/2D_Breakout_game_Phaser/Build_the_brick_field”)}} 
这是Gamedev Phaser 教程 16 的第 8 步。 
在Gamedev-Phaser-Content-Kit / demos / lesson08.html完成本课后，你可以找到源代码。 
为了使游戏更有趣，我们可以引入失去的能力 - 如果在到达屏幕底部边缘之前没有击球，那么这个游戏将会结束。 
如何输 
为了提供丢失的能力，我们将禁用球与屏幕底部的碰撞。 
在create()函数内添加下面的代码; 刚刚定义球的属性就好了： 
game.physics.arcade.checkCollision.down = false; 
这将使三个墙壁（顶部，左侧和右侧）弹回球，但是第四个（底部）将消失，如果桨错过，则球从屏幕上脱落。 
我们需要一种方法来检测并相应地采取行动。 
在以前的新的下方添加以下行： 
ball.checkWorldBounds = true; 
ball.events.onOutOfBounds.add(function () { 
alert("Game over!" 
); 
location.reload(); 
}, this); 
添加这些行将使得球检查世界（在我们的例子中是画布）边界并执行绑定到onOutOfBounds事件的函数。 
当你点击生成的警报时，页面将被重新加载，以便你可以再次播放。 
比较你的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/436bckb7/”,““,”400”)}} 
下一步 
现在的基本游戏就是让我们通过引入砖块来更有趣的是 - 现在是建造砖块的时候了。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Player_paddle_and_controls”, “Games/Workflows/2D_Breakout_game_Phaser/Build_the_brick_field”)}} 

{{GamesSidebar}} 
{{Next(“Games/Workflows/2D_Breakout_game_Phaser/Initialize_the_framework”)}} 
在这个手把手的教程中，我们将使用 Phaser 框架制作一个使用 JavaScript 构建简单的 MDN 消除游戏。 
教程的每一步骤都会有可供修改的样品来玩，所以你可以看到开发的每一步中间步骤。 
你将学到如何使用 Phaser 框架来实现基础游戏机制的基本知识，诸如渲染和移动图像，碰撞检测，控制机制，框架特定的帮助器功能，动画和补间，以及获胜和失败状态等。 
为了充分理解这一系列的文章，你应该确保已有基本的中级 JavaScript 知识。 
学完本教程，你将有能力用 Phaser 构建简单的 Web 游戏。 
Gameplay screen from the game MDN Breakout created with Phaser where you can use your paddle to bounce the ball and destroy the brick field, with keeping the points and lives. 
教学清单 
所有的课程 — 以及我们接下来将一起做的各个版本的 MDN Breakout game 都能在 GitHub上找到 
初始化框架 
缩放 
加载资源并在屏幕上打印 
移动小球 
物理 
从墙上弹开 
弹块和控制 
游戏结束 
建立砖块 
碰撞检测 
得分 
胜利 
额外生命 
动画与补间 
按钮 
随机游戏 
学习路线的小提示 — 最好先熟悉使用原生 JavaScript 进行网页游戏开发，这样可以打下坚实的基础。 
如果你还不熟悉原生 javascript 开发，我们建议你先过一遍这个系列，使用原生 Javascript 开发 MDN 消除游戏. 
在那之后，你就能随意挑选框架并用在你的项目中;我们选择了 Phaser 这个稳定优越的框架，它有着好的支持和社区环境以及大量优秀的插件。 
框架加速了开发并能帮你管理无趣的部分，让你专注于有意思的事务。 
然而，框架也有不好的地方，所以当一些意想不到的事情发生了或者想实现一些框架没有提供的功能时，你就将需要原生的 JavaScript 知识了。 
备注： 本系列文章可用作实际游戏开发的材料。 
如果你想要使用 Phaser 讨论游戏开发，你还可以使用基于本教程的 Gamedev Phaser 内容套件. 
Next steps 
好了，那我们就开始吧！ 
前往系列第一部分 — 初始化框架. 
{{Next(“Games/Workflows/2D_Breakout_game_Phaser/Initialize_the_framework”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Tutorials/2D_Breakout_game_Phaser”, “Games/Tutorials/2D_Breakout_game_Phaser/Scaling”)}} 
这是Gamedev Phaser 教程系列的第一课。 
在课程完成之后，你可以在Gamedev-Phaser-Content-Kit/demos/lesson01.html找到源码。 
在我们开始写游戏的功能之前，我们需要创建一个用来内部渲染游戏的基础架构。 
使用 HTML 就能做到 — Parser 框架将生成所需的 {{htmlelement(“canvas”)}} 元素。 
游戏的 HTML 
HTML 文档结构非常的简单，这个游戏将整个被渲染在框架生成的{{htmlelement(“canvas”)}} 元素上。 
拿起你最爱的编辑器，挑一个好目录，创建一个 HTML 文档，存成 index.html，然后写下下面的代码： 
<! 
doctype html> 
<html> 
<head> 
<meta charset="utf-8" /> 
<title>Gamedev Phaser Workshop - lesson 01: Initialize the framework</title> 
<style> 
* { 
padding: 0; 
margin: 0; 
} 
</style> 
<script src="js/phaser.min.js"></script> 
</head> 
<body> 
<script> 
var game = new Phaser.Game(480, 320, Phaser.AUTO, null, { 
preload: preload, 
create: create, 
update: update, 
}); 
function preload() {} 
function create() {} 
function update() {} 
</script> 
</body> 
</html> 
下载 Phaser 
下面我们将下载 Phaser 的代码，并应用到我们的 HTML 文档中。 
进入 Phaser 下载页面. 
选择最适合你的下载项 — 我们建议选择 min.js，因为它最小，而且你不太可能想去看它的源码 
将 Phaser 的源码存到一个和 index.html 同级的 /js 的目录下 
在上面第一个 {{htmlelement(“script”)}} 标签里写下 phaser 的路径。 
捋一捋我们干了些啥 
这个时候我们在 {{htmlelement(“header”)}} 里定义了 charset、{{htmlelement(“title”)}} 和一些基础的 css 来重置默认的 margin 和 padding。 
我们也用 {{htmlelement(“script”)}} 标签向页面引入了 Phaser 源码。{{ 
htmlelement(“body”)}} 里也有一个 {{htmlelement(“script”)}} 标签，我们将在里面写 JavaScript 代码来渲染和控制游戏。 
{{htmlelement(“canvas”)}} 元素是由框架自动生成的。 
我们是通过 Phaser.Game 创建一个对象并赋给了 game 变量来完成初始化的。 
参数的含义是： 
width 和 height 设置了 {{htmlelement(“canvas”)}} 宽高。 
渲染方式。 
有三个选项分别是 AUTO，CANVAS 和 WEBGL。 
我们可以指定使用 Canvas 还是 WebGL 来渲染，如果使用了 Auto 则优先使用 WebGL，如果浏览器不支持则会选择 Canvas。 
{{htmlelement(“canvas”)}} 的 id。 如果该参数有值，则使用该值作为 canvas 标签的 id，我们传入 null，则 phaser 会决定 canvas 的 id 值。 
第四个参数指定了 phaser 的三个生命周期所对应的函数。 我们使用相同的名字来让程序更清晰 
preload 进行资源的加载。 
create 会在资源加载完成后执行一次。 
update 会一直循环执行来处理每一帧动画。 
完整示例 
以下是第一章的完整代码，可以直接在 JSFiddle 中运行： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/h6cwzv2b/”,““,”400”)}} 
下一步 
现在我们已经完成了一个简单的 HTML 页面，并且学习了如何安装 Phaser，让我们继续学习第二章： scaling. 
{{PreviousNext(“Games/Tutorials/2D_Breakout_game_Phaser”, “Games/Tutorials/2D_Breakout_game_Phaser/Scaling”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Scaling”, “Games/Workflows/2D_Breakout_game_Phaser/Move the ball”)}} 
这是Gamedev Phaser 教程 16 的第三步。 
你可以在Gamedev-Phaser-Content-Kit / demos / lesson03.html完成本课程后找到源代码 
我们的游戏将围绕屏幕滚动，弹出一个桨，摧毁砖块赚取积分 - 熟悉吗？ 
在本文中，我们将介绍如何将 sprite 添加到我们的 gameworld 中。 
有一个球 
我们开始创建一个 JavaScript 变量来表示我们的球 - 在游戏初始化代码（我们的var game...块）和preload()函数之间添加以下行： 
var ball; 
备注： 为了本教程，我们将使用全局变量。 
本教程的目的是教导 Phaser 特定的游戏开发方法，而不是主观的最佳方法。 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Load_the_assets_and_print_them_on_screen”, “Games/Workflows/2D_Breakout_game_Phaser/Physics”)}} 
这是Gamedev Phaser 教程 16 的第 4 步。 
在Gamedev-Phaser-Content-Kit / demos / lesson04.html完成本课后，你可以找到源代码。 
我们在屏幕上打印了我们的蓝色球，但它什么都不做，这样做会很酷。 
本文介绍如何做到这一点。 
在每个框架上更新球的位置 
记住update()功能及其定义？ 
其中的代码在每个框架上执行，所以它是一个完美的地方，将代码更新球的位置在屏幕上。 
在里面添加以下新行代码update()，如下所示： 
function update() { 
ball.x += 1; 
ball.y += 1; 
} 
上面的代码在每个框架上为表示画布上的球坐标的属性x和y属性添加了一个。 
重新加载 index.html，你应该看到球在屏幕上滚动。 
比较你的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/g1cfp0vv/”,““,”400”)}} 
下一步 
下一步是添加一些基本的碰撞检测，所以我们的球可以从墙壁反弹。 
这将需要几行代码 - 一个比我们迄今为止看到的更复杂的步骤，特别是如果我们也想添加桨和砖碰撞 - 但是幸运的是 Phaser 使我们比我们想要使用纯粹的方法更容易做到这一点 JavaScript 的。 
无论如何，在我们做所有的事情之前，我们将首先介绍 Phaser 的物理引擎，并做一些设置工作。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Load_the_assets_and_print_them_on_screen”, “Games/Workflows/2D_Breakout_game_Phaser/Physics”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Move_the_ball”, “Games/Workflows/2D_Breakout_game_Phaser/Bounce_off_the_walls”)}} 
这是Gamedev Phaser 教程 16 的第 5 步。 
你可以在Gamedev-Phaser-Content-Kit / demos / lesson05.html完成本课程后找到源代码 
为了在我们的游戏中的对象之间进行正确的碰撞检测，我们将需要物理学; 本文将向你介绍 Phaser 中的可用内容，以及演示典型的简单设置。 
添加物理效果 
Phaser 与三个不同的物理引擎（Arcade Physics，P2 和 Ninja Physics）捆绑在一起，第四个选项 Box2D 可作为商业插件使用。 
对于像我们这样的简单游戏，我们可以使用 Arcade Physics 引擎。 
我们不需要任何重的几何计算 - 毕竟只是一个球从墙壁和砖块弹起来。 
首先，让我们在游戏中初始化 Arcade Physics 引擎。 
physics.startSystem()在create函数开头添加方法（使其成为函数内的第一行），如下所示： 
game.physics.startSystem(Phaser.Physics.ARCADE); 
接下来，我们需要为物理系统启用我们的球 - 默认情况下，Phaser 对象物理不启用。 
在create()函数底部添加以下行： 
game.physics.enable(ball, Phaser.Physics.ARCADE); 
接下来，如果我们要在屏幕上移动我们的球，我们可以设置velocity它body。 
再次添加以下行create()： 
ball.body.velocity.set(150, 150); 
删除我们以前的更新说明 
记得删除添加值的我们的老方法x，并y从update()功能： 
function update() { 
ball.x += 1; 
ball.y += 1; 
} 
我们正在使用物理引擎正确处理。 
最终代码检查 
最新的代码应该如下所示： 
var ball; 
function preload() { 
game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL; 
game.scale.pageAlignHorizontally = true; 
game.scale.pageAlignVertically = true; 
game.stage.backgroundColor = "#eee"; 
game.load.image("ball", "img/ball.png"); 
} 
function create() { 
game.physics.startSystem(Phaser.Physics.ARCADE); 
ball = game.add.sprite(50, 50, "ball"); 
game.physics.enable(ball, Phaser.Physics.ARCADE); 
ball.body.velocity.set(150, 150); 
} 
function update() {} 
尝试重新加载index.html- 球应该在给定的方向上不断移动。 
目前，物理引擎的重力和摩擦力设定为零。 
增加重力将导致球落下，同时摩擦力最终会停止球。 
物理效果趣味 
你可以用物理学来做更多的事情，例如添加ball.body.gravity.y = 100;你将设置球的垂直重力。 
因此，它将向上发射，但是由于重力的作用而下降。 
这种功能只是冰山一角 - 有各种功能和变量可以帮助你操纵物理对象。 
查看官方物理文档，并使用Arcade和P2物理系统查看大量示例。 
比较你的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/bjto9nj8/”,““,”400”)}} 
下一步 
现在我们可以转到下一课，看看如何让球从墙上弹起。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Move_the_ball”, “Games/Workflows/2D_Breakout_game_Phaser/Bounce_off_the_walls”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Bounce_off_the_walls”, “Games/Workflows/2D_Breakout_game_Phaser/Game_over”)}} 
这是Gamedev Phaser 教程 16 的第 7 步。 
你可以在Gamedev-Phaser-Content-Kit / demos / lesson07.html完成本课程后找到源代码。 
我们有球从墙上移动并弹跳，但它很快变得无聊 - 没有互动！ 
我们需要一种介绍游戏的方法，所以在这篇文章中，我们将创建一个桨来移动并击中球。 
渲染桨 
从框架的角度看，桨非常类似于球 - 我们需要添加一个变量来表示它，加载相关的图像资源，然后做出魔法。 
装载桨 
首先，添加paddle我们将在我们的游戏中使用的ball变量，就在变量之后： 
var paddle; 
然后，在该preload功能中，paddle通过添加以下新load.image()调用来加载图像： 
function preload() { 
// ... 
game.load.image("ball", "img/ball.png"); 
game.load.image("paddle", "img/paddle.png"); 
} 
添加桨图形 
所以我们不要忘记，在这一点上，你应该从 Github 抓住这个图形，并保存在你的/img文件夹中。 
渲染桨用物理引擎 
接下来，我们将通过add.sprite()在create()函数中添加以下调用来初始化我们的桨，将其添加到底部： 
paddle = game.add.sprite( 
game.world.width * 0.5, 
game.world.height - 5, 
"paddle", 
); 
我们可以使用world.width和world.height值来将桨定位到我们想要的位置：game.world.width*0.5将在屏幕中间。 
在我们这个例子中，世界和画布是一样的，但是对于其他类型的游戏，例如侧滚滚，这个世界会变大，你可以修改它来创造有趣的效果。 
你会注意到，如果你index.html在这一点上重新加载，那么桨是目前不完全在中间的。 
为什么？ 
因为计算位置的锚总是从对象的左上角开始。 
我们可以改变它，使锚在桨的宽度的中间和它的高度的底部，所以更容易将其定位在底部边缘。 
添加以下新行以下的行： 
paddle.anchor.set(0.5, 1); 
桨现在位于我们想要的地方。 
现在，为了使它与球碰撞，我们必须为桨提供物理效果。 
继续添加以下新行，再次在create()函数的底部： 
game.physics.enable(paddle, Phaser.Physics.ARCADE); 
现在，魔法可以开始发生 - 该框架可以在每个框架上检查碰撞检测。 
要启用桨和球之间的碰撞检测，请将collide()方法添加到如下update()功能中： 
function update() { 
game.physics.arcade.collide(ball, paddle); 
} 
第一个参数是我们感兴趣的对象之一 - 球 - 第二个是另一个，桨。 
这有效，但不如我们预期的那样 - 当球击中桨时，桨从屏幕上掉下来！ 
我们想要的就是球从跳板上跳起来，而桨子停在同一个地方。 
我们可以将body桨设置成immovable球，所以当球击中它时不会移动。 
为此，请在create()函数底部添加以下行： 
paddle.body.immovable = true; 
现在它按预期工作。 
控制桨 
接下来的问题是我们不能移动桨。 
要做到这一点，我们可以使用系统的默认输入（鼠标或触摸，取决于平台），并将桨位置设置到位置的input位置。 
将以下新行添加到update()函数中，如下所示： 
function update() { 
game.physics.arcade.collide(ball, paddle); 
paddle.x = game.input.x; 
} 
现在在每个新的一帧上，桨的x位置将根据输入的x位置进行调整，但是当我们开始游戏时，桨的位置不在中间。 
这是因为输入位置尚未定义。 
要修复，我们可以将默认位置（如果输入位置尚未定义）设置为屏幕中间。 
更新上一行如下： 
paddle.x = game.input.x || game.world.width * 0.5; 
如果你还没有这样做，请重新加载index.html并尝试！ 
定位球 
我们有桨按预期工作，所以我们把球放在上面。 
它非常类似于定位桨 - 我们需要将其放置在屏幕中间水平和垂直的底部，与底部有一点偏移。 
要按照我们想要的方式放置它，我们将把锚定位到球的正中间。 
找到现有的行，并将其替换为以下两行：ball = game.add.sprite( ... ) 
ball = game.add.sprite(game.world.width * 0.5, game.world.height - 25, "ball"); 
ball.anchor.set(0.5); 
速度保持不变 - 我们只是将第二个参数的值从 150 改为 -150，所以球将通过向上移动而不是下降来开始游戏。 
查找现有ball.body.velocity.set( ... )行并将其更新为以下内容： 
ball.body.velocity.set(150, -150); 
现在球将从桨的中间开始。 
比较你的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/ogqza0ye/”,““,”400”)}} 
下一步 
我们可以移动桨，并将球反弹，但是如果球从屏幕的底部边缘反弹，那又有什么意义？ 
我们来介绍丢失的可能性 - 也称为游戏逻辑。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Bounce_off_the_walls”, “Games/Workflows/2D_Breakout_game_Phaser/Game_over”)}} 

{{GamesSidebar}} 
{{Previous(“Games/Workflows/2D_Breakout_game_Phaser/Buttons”)}} 
这是Gamedev Phaser 教程 16 中的第16 步。 
你可以在Gamedev-Phaser-Content-Kit / demos / lesson16.html完成本课程后找到源代码。 
我们的游戏似乎已经完成了，但是如果你看起来足够近，你会发现球在整个游戏中都以相同的角度从桨上弹起。 
这意味着每个游戏都非常相似。 
为了解决这个问题，提高可玩性，我们应该使反弹角度更加随机，在本文中我们将介绍一下如何。 
让篮板更随机 
我们可以根据撞击桨的确切位置来改变球的速度，通过使用沿着下方的线路运行功能来修改x速度ballHitPaddle()。 
现在添加这一行到你的代码，并尝试。 
function ballHitPaddle(ball, paddle) { 
ball.animations.play("wobble"); 
ball.body.velocity.x = -1 * 5 * (paddle.x - ball.x); 
} 
这有点魔法 - 新的速度越高，桨的中心和球撞到的地方之间的距离就越大。 
此外，方向（左或右）由该值确定 - 如果球击中桨的左侧，则其将向左反弹，而击球右侧将向右反弹。 
最终这样做是因为对某些值进行了一些实验，你可以进行自己的实验，看看会发生什么。 
这当然不是完全随机的，但它确实使游戏玩法变得更加不可预测，因此更有趣。 
比较你的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/3yds5ege/”,““,”400”)}} 
概要 
你已经完成了所有的课程 - 恭喜你！ 
在这一点上，你将了解到 Phaser 的基础知识和简单 2D 游戏背后的逻辑。 
练习跟随 
你可以在游戏中做更多的事情 - 添加任何你觉得最好的东西，使它更有趣和有趣。 
Phaser 提供的无数有用的方法的基本介绍。 
以下是关于如何扩展我们的小游戏的一些建议，让你开始： 
添加第二个球或桨。 
改变每次命中背景的颜色。 
更改图像并使用自己的图像。 
如果砖块被迅速摧毁，并排排列（或你选择的其他奖金），则可获得额外的奖励积分。 
创建不同砖块布局的水平。 
一定要检查越来越多的示例列表和官方文档，如果你需要任何帮助，请访问HTML5 Gamedevs 论坛。 
你也可以返回本教程系列的索引页。 
{{Previous(“Games/Workflows/2D_Breakout_game_Phaser/Buttons”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Tutorials/2D_Breakout_game_Phaser/Initialize_the_framework”, “Games/Tutorials/2D_Breakout_game_Phaser/Load_the_assets_and_print_them_on_screen”)}} 
这是Gamedev Phaser 教程系列的第二课。 
在课程完成之后，你可以在Gamedev-Phaser-Content-Kit/demos/lesson02.html找到源码。 
缩放是指游戏画布如何在不同的屏幕尺寸上进行显示。 
我们可以在预加载阶段自动使游戏规模适合任何屏幕尺寸，之后就可以不用再担心屏幕尺寸的问题了。 
Phaser 中 scale 对象 
Phaser 中有一个特殊的对象：scale，它包含一些特别的方法和属性。 
让我们来更改一下上一节中创建的的preload()函数： 
function preload() { 
game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL; 
game.scale.pageAlignHorizontally = true; 
game.scale.pageAlignVertically = true; 
} 
scaleMode 有几个不同的选项来指定 Canvas 应该如何缩放： 
NO_SCALE — 不进行任何缩放。 
EXACT_FIT — 拉伸，填充屏幕，不保留长宽比。 
SHOW_ALL — 等比缩放，填充屏幕，保留长宽比，剩余空间用黑色填充。 
RESIZE — 动态，每次都会根据屏幕生成画布，所以你需要在游戏运行时动态的放置游戏元素。 
这是一种进阶的模式。 USER_SCALE — 自定义，允许你自己计算大小和比例。 
这也是一种进阶的模式。 
preload()中的其他两行代码负责水平和垂直居中画布，所以它始终以屏幕为中心，无论大小如何。 
设置背景颜色 
我们还可以给画布设置背景颜色来替代磨人的黑色背景。 
通过更改stage对象的backgroundColor属性来添加，我们可以使用 CSS 颜色定义语法进行设置。 
我们在刚才的代码下面添加以下代码： 
game.stage.backgroundColor = "#eee"; 
完整的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/6a64vecL/”,““,”400”)}} 
下一步 
现在我们设置了我们游戏的缩放比例，让我们继续第三课，并设计出如何加载资源并将其显示在屏幕上。 
{{PreviousNext(“Games/Tutorials/2D_Breakout_game_Phaser/Initialize_the_framework”, “Games/Tutorials/2D_Breakout_game_Phaser/Load_the_assets_and_print_them_on_screen”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Collision_detection”, “Games/Workflows/2D_Breakout_game_Phaser/Win_the_game”)}} 
这是Gamedev Phaser 教程 16 的第 11 步。 
你可以在Gamedev-Phaser-Content-Kit / demos / lesson11.html完成本课程后找到源代码。 
得分也可以使游戏更有趣 - 你可以尝试击败自己的高分，或者你的朋友。 
在这篇文章中，我们将为我们的游戏添加一个评分系统。 
我们将使用一个单独的变量来存储分数和 Phaser 的text()方法将其打印到屏幕上。 
新变量 
在以前定义的之后添加两个新变量： 
// ... 
var scoreText; 
var score = 0; 
将得分文字添加到游戏显示 
现在在create()函数末尾添加这一行： 
scoreText = game.add.text(5, 5, "Points: 0", { 
font: "18px Arial", 
fill: "#0095DD", 
}); 
该text()方法可以采用四个参数： 
x 和 y 坐标来绘制文本。 
将呈现的实际文本。 
用于呈现文本的字体样式。 
最后一个参数与 CSS 样式非常相似。 
在我们的例子中，乐谱文字将为蓝色，大小为 18 像素，并使用 Arial 字体。 
当砖块被破坏时更新分数 
每当球击中砖块时，我们将增加点数，更新scoreText显示当前得分。 
这可以使用setText()方法 - 添加以下两行新ballHitBrick()功能： 
function ballHitBrick(ball, brick) { 
brick.kill(); 
score += 10; 
scoreText.setText("Points: " + score); 
} 
这是现在 - 重新加载你的，index.html并检查得分更新每个砖击。 
比较你的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/n8o6rhrf/”,““,”400”)}} 
下一步 
我们现在有一个得分系统，但是如果你不能赢得，那么玩和保持分数是多少？ 
让我们看看我们如何能够增加胜利的状态，让我们赢得比赛。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/Collision_detection”, “Games/Workflows/2D_Breakout_game_Phaser/Win_the_game”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/The_score”, “Games/Workflows/2D_Breakout_game_Phaser/Extra_lives”)}} 
这是Gamedev Phaser 教程 16 的第 12 步。 
你可以在Gamedev-Phaser-Content-Kit / demos / lesson12.html完成本课程后找到源代码。 
在我们的游戏中实现获胜是相当容易的：如果你碰巧摧毁所有的砖块，那么你赢了。 
如何取胜？ 
将以下新代码添加到你的ballHitBrick()函数中： 
function ballHitBrick(ball, brick) { 
brick.kill(); 
score += 10; 
scoreText.setText("Points: " + score); 
var count_alive = 0; 
for (i = 0; i < bricks.children.length; i++) { 
if (bricks.children[i].alive == true) { 
count_alive++; 
} 
} 
if (count_alive == 0) { 
alert("You won the game, congratulations!" 
); 
location.reload(); 
} 
} 
我们循环使用组中的砖块bricks.children，检查每个砖块的.alive() 方法的活力。 
如果没有更多的砖块活着，那么我们会显示一个获胜的消息，一旦警报被关闭，重新启动游戏。 
比较你的代码 
你可以在下面的现场演示中查看本课程的完成代码，并使用它来更好地了解它的工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/u8waa4Lx/1/”,““,”400”)}} 
下一步 
失败和获胜都是实施的，所以我们的游戏的核心游戏就完成了。 
现在让我们添加一些额外的东西 - 我们会给玩家将 3 个生活的，而不是一个。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_Phaser/The_score”, “Games/Workflows/2D_Breakout_game_Phaser/Extra_lives”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Move_the_ball”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Paddle_and_keyboard_controls”)}} 
本篇是 Gamedev Canvas tutorial 10 节教程中的第三节。 
如果你完成了本篇教程之后，你可以从 Gamedev-Canvas-workshop/lesson3.html 看到源码。 
看到我们的球动起来很惊讶吧，但是它很快就从屏幕上消失了，当然我们是可以控制它的。 
我们会实现一些非常简单的碰撞检测 (详细后面解释),使球在画布的四周反弹回来。 
简单的碰撞 
我们将检查球体是否与边缘接触，如果有接触我们将相应的改变它的运动方向。 
为了运算方便我们定义一个名为 ballRadius 的变量，来存储球的半径。 
向代码中添加一下内容： 
var ballRadius = 10; 
现在更新绘制球的 drawBall() 函数： 
ctx.arc(x, y, ballRadius, 0, Math.PI * 2); 
从顶部和底部弹起 
我们需要判断球运动的每一帧，球体是否与画布的顶部边缘接触。 
如果有接触，我们将会改变球体的运动方向，使它向相反的方向移动，并保证它在画布的可见范围之内。 
记住坐标系统的左上角，让我们开始并加以下代码： 
if (y + dy < 0) { 
dy = -dy; 
} 
如果球的纵坐标（y 轴）值小于零，我们将在球体原有的运动方向上逆转。 
如果球体向上移动的速度是 2 像素/帧，现在就是向上移动速度是 -2 像素。 这相当于此时向下移动的速度是 2 像素/帧。 
上面的代码将处理球与画布顶部边缘的反射，现在让我们思考一下底部边缘如何处理： 
if (y + dy > canvas.height) { 
dy = -dy; 
} 
如果球的 y 位置大于canvas的高度（记住，我们从左上角计算 y 值，所以顶部边缘从 0 开始，底部边缘在 480 像素），然后通过像以前那样反转 y 轴运动而离开底部边缘。 
我们可以将这两句冗长的代码合二为一： 
if (y + dy > canvas.height || y + dy < 0) { 
dy = -dy; 
} 
如果其中一个判断为 true, 则反转球的运动。 
从左边和右边反弹 
我们有顶部和底部的边缘，所以我们来考虑一下左边和右边的边缘。 
实际上非常相似，你所要做的就是颠倒x而不是y: 
if (x + dx > canvas.width || x + dx < 0) { 
dx = -dx; 
} 
if (y + dy > canvas.height || y + dy < 0) { 
dy = -dy; 
} 
你应该把上面的代码块插入到 draw（）函数中，就在大括号之前。 
球部分消失在墙上！ 
测试你的代码，你会看到我们的球碰到任一边缘都会反弹！ 
然而，我们还发现了一个问题，当球碰撞到边缘，反弹之前： 
这是因为我们正在计算墙和球的中心碰撞点，而我们应该围绕它的周长来做。 
如果碰到墙壁，球应该会弹起来，而不是陷入墙壁一半时，所以让我们来调整一下我们的判断条件。 
更新你之前添加的代码： 
if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) { 
dx = -dx; 
} 
if (y + dy > canvas.height - ballRadius || y + dy < ballRadius) { 
dy = -dy; 
} 
当球的中心到墙的边缘之间的距离与球的半径完全相同时，它将改变运动的方向。 
比较你的代码 
让我们再次检查这个部分的代码与你之间有何差异： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/redj37dc/”,““,”370”)}} 
备注： 尝试修改你的代码，在每次碰到墙壁时都要把球的颜色改成随机的颜色。 
下一步 
现在我们已经到了我们的球正在移动和留在游戏板上的阶段。 
在第四章中，我们将看看如何实现一个可控制的 paddle - 参见paddle 和键盘控制。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Move_the_ball”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Paddle_and_keyboard_controls”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Game_over”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Collision_detection”)}} 
这是 Gamedev Canvas tutorial教程 10 节的第 6 节。 
你可以在完成本课程后在这里Gamedev-Canvas-workshop/lesson6.html找到源代码。 
在修改游戏机制后，我们可以输了 — 这样这游戏看起来终于像是一个游戏了，这真是太好了。 
但是，如果你总是让球与墙、板碰撞的话，很快就会感到无聊的。 
好游戏需要的是让球消灭砖，这就是我们即将要做的！ 
设置砖变量 
本课题的总体目标是使用一个二维数组嵌套的循环，给出砖的几行代码。 
首先我们需要设置一些变量定义的砖，如宽度和高度信息，行和列，等。 
在之前的变量声明处加入以下几行代码。 
var brickRowCount = 3; 
var brickColumnCount = 5; 
var brickWidth = 75; 
var brickHeight = 20; 
var brickPadding = 10; 
var brickOffsetTop = 30; 
var brickOffsetLeft = 30; 
在这里，我们定义了砖的行数和列，宽度和高度，砖块之间的填充物，这样它们就不会互相接触；有一个上、左偏移量，所以它们不会从画布的边缘开始绘制。 
我们将在一个二维数组容纳我们所有的砖。 
它将包含砖列（c），砖行（R），每一个包含一个对象，其中包含 x 和 y 位置，让每个砖显示在屏幕上。 
在变量下面添加以下代码： 
var bricks = []; 
for (c = 0; c < brickColumnCount; c++) { 
bricks[c] = []; 
for (r = 0; r < brickRowCount; r++) { 
bricks[c][r] = { x: 0, y: 0 }; 
} 
} 
上面的代码将通过行和列的循环和创造新砖。 
注意，砖块对象稍后也将用于碰撞检测。 
画砖的逻辑 
现在让我们创建一个函数来遍历数组中的所有砖块并在屏幕上绘制它们。. 
代码如下： 
function drawBricks() { 
for (c = 0; c < brickColumnCount; c++) { 
for (r = 0; r < brickRowCount; r++) { 
bricks[c][r].x = 0; 
bricks[c][r].y = 0; 
ctx.beginPath(); 
ctx.rect(0, 0, brickWidth, brickHeight); 
ctx.fillStyle = "#0095DD"; 
ctx.fill(); 
ctx.closePath(); 
} 
} 
} 
再次，我们遍历的行和列，给每一块砖的位置设置X和Y，我们也画布上画砖，—brickwidth X brickheight 。 
问题是我们都画在一个地方坐标（0,0）处。 
我们需要做的是增加一些计算，计算每个循环迭代后的砖块的 x 和 y 位置： 
var brickX = c * (brickWidth + brickPadding) + brickOffsetLeft; 
var brickY = r * (brickHeight + brickPadding) + brickOffsetTop; 
每个brickX位置是 brickWidth + brickPadding，乘以列数C，再加上brickOffsetLeft；对于砖brickY的逻辑相同，除了名称不同，使用行数R，brickHeight，和brickOffsetTop。 
现在，每一块砖都可以放在正确的地方，排成一排，每一块砖之间都有填充物，从左上角和顶部的帆布边缘偏移。 
在设置brickX和brickY作为对应砖的坐标之后，形成了 drawBricks()函数的最终版本。 将以下代码加在drawPaddle()函数后面： 
function drawBricks() { 
for (c = 0; c < brickColumnCount; c++) { 
for (r = 0; r < brickRowCount; r++) { 
var brickX = c * (brickWidth + brickPadding) + brickOffsetLeft; 
var brickY = r * (brickHeight + brickPadding) + brickOffsetTop; 
bricks[c][r].x = brickX; 
bricks[c][r].y = brickY; 
ctx.beginPath(); 
ctx.rect(brickX, brickY, brickWidth, brickHeight); 
ctx.fillStyle = "#0095DD"; 
ctx.fill(); 
ctx.closePath(); 
} 
} 
} 
到了展现真正画砖的时候了 
最后一件事就是在draw()中调用drawBricks(), 位置最好在函数开始处，在清除画布和画球之间。 
直接将下面代码加在drawBall() 处： 
drawBricks(); 
比较你的代码 
这样，游戏变得更有趣了 : 
{{JSFiddleEmbed(“https://jsfiddle.net/kundan333/myd4vbwg/2/”,““,”320”)}} 
备注： 练习：尝试在行或列上改变砖块数量，或者它们的位置。 
下一节 
现在，我们有砖啦！ 
但是球根本就没有和它们互动 —— 接下来的第七章我们将让球和砖产生碰撞：碰撞检测。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Game_over”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Collision_detection”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Build_the_brick_field”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Track_the_score_and_win”)}} 
本篇为Gamedev Canvas tutorial10 节教程中的第 7 节。 
在你完成这篇课程之后，你可以在Gamedev-Canvas-workshop/lesson7.html. 找到我们的源代码。 
我们已经在屏幕上画出了砖块，但游戏仍然没有那么有趣，因为球通过它们。 
我们需要考虑增加碰撞检测，这样球就可以弹击砖块并打破它们。 
当然，这是我们的决定如何实现的，但是计算球是否触及矩形是很困难的，因为在画布中没有辅助函数。 
为了这个教程，我们将尽可能地做到这一点。 
我们将检查球的中心是否与任何给定的砖块碰撞。 
这不会每次都给出一个完美的结果，而且有很多更复杂的方法来进行碰撞检测，但是这对指导你的基本概念很有效。 
撞击侦测函数 
踢掉这一切，我们想创建一个碰撞检测功能，将循环通过所有砖块，并比较每一个砖的位置与球的坐标，因为每个帧绘制。 
为了更好地理解代码，我们将定义用于在碰撞检测的每个循环中存储砖块对象的 B 变量： 
function collisionDetection() { 
for (c = 0; c < brickColumnCount; c++) { 
for (r = 0; r < brickRowCount; r++) { 
var b = bricks[c][r]; 
// calculations 
} 
} 
} 
如果球的中心在我们的一块砖块的坐标内，我们将改变球的方向。 
对于球的中心在砖块内，以下四个陈述都必须是正确的： 
球的 X 位置大于砖的 X 位置。 
球的 X 位置小于砖的 X 位置加上它的宽度。 
球的 Y 位置大于砖的 Y 位置。 
球的 Y 位置小于砖块的 Y 位置加上它的高度。 
让我们在代码中写下： 
function collisionDetection() { 
for (c = 0; c < brickColumnCount; c++) { 
for (r = 0; r < brickRowCount; r++) { 
var b = bricks[c][r]; 
if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) { 
dy = -dy; 
} 
} 
} 
} 
将上面的块添加到代码中，在 keyUpHandler() 函数下面。 
让砖块在被撞击之后消失 
上述代码将按需要工作，球改变其方向。 
问题是砖块留在原地。 
我们必须想出一个办法来摆脱那些我们已经用球打中的砖。 
我们可以通过添加一个额外的参数来指示我们是否想在屏幕上画每个砖块。 
在初始化砖块的代码的一部分中，让我们为每个砖块对象添加一个状态属性。 
更新代码的下面部分，如突出显示的行所示： 
var bricks = []; 
for (c = 0; c < brickColumnCount; c++) { 
bricks[c] = []; 
for (r = 0; r < brickRowCount; r++) { 
bricks[c][r] = { x: 0, y: 0, status: 1 }; 
} 
} 
接下来，我们将在绘制之前在 drawBricks() 中检查每个砖块的 status属性的值 - 如果 status是 1，然后画它，但是如果它是 0，那么它被球击中，我们不再希望它在屏幕上。 
更新你的 drawBricks() 函数如下： 
function drawBricks() { 
for (c = 0; c < brickColumnCount; c++) { 
for (r = 0; r < brickRowCount; r++) { 
if (bricks[c][r].status == 1) { 
var brickX = c * (brickWidth + brickPadding) + brickOffsetLeft; 
var brickY = r * (brickHeight + brickPadding) + brickOffsetTop; 
bricks[c][r].x = brickX; 
bricks[c][r].y = brickY; 
ctx.beginPath(); 
ctx.rect(brickX, brickY, brickWidth, brickHeight); 
ctx.fillStyle = "#0095DD"; 
ctx.fill(); 
ctx.closePath(); 
} 
} 
} 
} 
跟踪并更新在撞击侦测函数中的状态 
现在我们需要将砖块 status 属性包含在 collisionDetection()函数中：如果砖块是活动的（它的状态是 1），我们将检查碰撞是否发生；如果发生碰撞，我们将给定砖块的状态设置为 0，这样它就不会被绘制在屏幕上。 
更新你的 collisionDetection() 函数，如下所示： 
function collisionDetection() { 
for (c = 0; c < brickColumnCount; c++) { 
for (r = 0; r < brickRowCount; r++) { 
var b = bricks[c][r]; 
if (b.status == 1) { 
if ( 
x > b.x && 
x < b.x + brickWidth && 
y > b.y && 
y < b.y + brickHeight 
) { 
dy = -dy; 
b.status = 0; 
} 
} 
} 
} 
} 
调用我们的撞击侦测函数 
最后要做的是向 collisionDetection() 函数添加一个调用到我们的主要draw() 函数。 
将下面的行添加到 draw() 函数中，就在drawPaddle() 调用的下面： 
collisionDetection(); 
对比你的代码 
现在，在每一帧，每一块砖上都检查了球的碰撞检测。 
现在我们可以毁掉砖头：-！ 
{{JSFiddleEmbed(“https://jsfiddle.net/kundan333/myd4vbwg/5/”,““,”320”)}} 
备注： 练习：当球碰到砖头时，改变球的颜色。 
下一节 
我们现在肯定到了，继续前进吧！ 
在第八章中，我们将探讨如何跟踪得分和获胜。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Build_the_brick_field”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Track_the_score_and_win”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Move_the_ball”)}} 
本篇是 Gamedev Canvas tutorial 10 节教程中的第一节。 
如果你完成了本篇教程之后，你可以从 Gamedev-Canvas-workshop/lesson1.html 看到源码。 
在我们开始编写游戏功能之前，我们可以通过 HTML 的 canvas 标签创建支撑游戏的基本结构。 
页面部分 
HTML 文档的结构是非常简单的，我们的游戏将完全呈现在这个 HTML 的 canvas 标签中。 
你可以选择一款你最喜欢的文本编辑器，创建一个 HTML 文件，保存到你理想的位置，名称为 index.html。 并添加以下代码： 
<! 
doctype html> 
<html> 
<head> 
<meta charset="utf-8" /> 
<title>Gamedev Canvas Workshop</title> 
<style> 
* { 
padding: 0; 
margin: 0; 
} 
canvas { 
background: #eee; 
display: block; 
margin: 0 auto; 
} 
</style> 
</head> 
<body> 
<canvas id="myCanvas" width="480" height="320"></canvas> 
<script> 
// JavaScript code goes here 
</script> 
</body> 
</html> 
在 head 标签中我们需要定义字符集（charset），标题（title）和一些基本的样式。 
在 body 标签中包含 canvas 标签和 javascript 标签，我们将在 javascript 标签中使用 JavaScript 代码来控制 canvas 标签中的内容展现。 
在 canvas 标签有一个名为 myCanvas 的 Id，根据这个属性我们可以很容易的获取到这个元素并设置他的宽为 480 像素，高为 320 像素。 
之后我们会将所有的 JavaScript 代码全部写到 javascript 标签中（<script>…</script>）。 
画布的基本属性 
要想在 canvas 标签中呈现图像内容，我们必须在 JavaScript 代码中获取到这个元素。 
在 javascript 标签中添加以下代码； 
var canvas = document.getElementById("myCanvas"); 
var ctx = canvas.getContext("2d"); 
在这里我们可以声明一个变量保存 canvas 标签，然后我们需要创建变量 ctx, 这个变量可用来存储 2d 的渲染上下文，我们实际上就用它在 canvas 标签上绘制内容。 
让我们来看一个例子，打印在画布上的红色正方形。 
添加以下代码到你的 JavaScript 里，然后在浏览器中打开 index.html 来看看效果。 
ctx.beginPath(); 
ctx.rect(20, 40, 50, 50); 
ctx.fillStyle = "#FF0000"; 
ctx.fill(); 
ctx.closePath(); 
把全部指令放到 ctx.beginPath() 方法 和 ctx.closePath() 方法之间。 我们使用 ctx.rect() 方法创建了一个矩形。 
这个方法的第一组参数（20，40）是确定这个矩形的左上角在画布上的坐标，第二组参数（50, 50）是指定矩形的宽度和高度。 
例子中矩形左上角的 x 坐标为 20 像素，y 坐标为 40 像素；宽和高各为 50 像素，这样画出一个完美的正方形。 
ctx.fillStyle 属性是用于填充绘画的颜色，这里填充的颜色为红色。 ctx.fill() 方法是填充路径的内容区域生成实心的图形。 
我们不局限于绘制矩形 — 下面这段代码会绘制出一个绿色的圆；尝试添加到 JavaScript 代码的底部，保存并刷新： 
ctx.beginPath(); 
ctx.arc(240, 160, 20, 0, Math.PI * 2, false); 
ctx.fillStyle = "green"; 
ctx.fill(); 
ctx.closePath(); 
正如你所见，我们再一次使用了 ctx.beginPath() 方法 和 ctx.closePath() 方法；在这两个方法中间，最重要的部分是 ctx.arc() 方法。 
它需要六个参数： 
圆心的 x 和 y 轴坐标 
半径 
起始角度，结束角度。 以弧度计（弧的圆形的三点钟位置是 0 度） 
规定应该逆时针还是顺时针绘图。 
false = 顺时针，true = 逆时针。（ 
ctx.fillStyle 属性的值看起来和之前不大一样。 
这是因为它与 CSS 一样，颜色可以指定为十六进制值也可以指定为 rgba() 函数，或者任何其他可用的颜色值函数。 
当然我们也可以不使用 ctx.fill() 函数来填充图形和颜色，用 ctx.stroke() 函数来绘制定义图形的路径。 
试着将这段代码添加到你的 JavaScript: 
ctx.beginPath(); 
ctx.rect(160, 10, 100, 40); 
ctx.strokeStyle = "rgba(0, 0, 255, 0.5)"; 
ctx.stroke(); 
ctx.closePath(); 
上面的代码绘制出一个蓝色边框的空心矩形。 
由于 rgba() 函数的特性，边框为蓝色半透明的状态。 
比对你的代码 
以上是第一节的全部代码，可以运行在 JSFiddle（在线 JS 代码调试工具）上： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/x62h15e2/”,““,”370”)}} 
备注： 练习：尝试改变给定几何图形的大小和颜色。 
下一节 
现在我们已经创建了基本的 HTML 和关于画布的基本知识。 我们继续第二节，如何让球在游戏中动起来 — 让球动起来。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Move_the_ball”)}} 

{{GamesSidebar}} 
{{Previous(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Mouse_controls”)}} 
本篇为 Gamedev Canvas tutorial 10 节教程中的第 10 节也是最后一节。 
完成这篇课程后，你可以在 Gamedev-Canvas-workshop/lesson10.html 找到我们的源代码。 
不管我们做什么游戏，它总是存在优化的空间。 
例如，我们可以为玩家多提供几条命，让他们能在发生一两次失误的情况下顺利完成游戏。 
或者，我们也可以在渲染代码上下工夫。 
加入生命机制 
在游戏中实现生命机制的思路很直接。 
让我们先新增一个变量，用来存储其生命值。 把下面这行代码和我们声明其他变量的代码放在一起： 
var lives = 3; 
在 canvas 上绘制生命值计数的做法几乎和绘制分数一样——把下面的函数添加到drawScore() 函数后面： 
function drawLives() { 
ctx.font = "16px Arial"; 
ctx.fillStyle = "#0095DD"; 
ctx.fillText("Lives: " + lives, canvas.width - 65, 20); 
} 
当玩家失误时，我们不立即结束游戏，而是减少生命计数，直到为零。 
在玩家用掉一条命后，我们也可以重置小球和球板位置。 
那么，在函数 draw() 中将下面三行： 
alert("GAME OVER"); 
document.location.reload(); 
clearInterval(interval); // Needed for Chrome to end game 
替换为下面的代码，注意到我们加入了一点点逻辑控制： 
lives--; 
if (! 
lives) { 
alert("GAME OVER"); 
document.location.reload(); 
clearInterval(interval); // Needed for Chrome to end game 
} else { 
x = canvas.width / 2; 
y = canvas.height - 30; 
dx = 2; 
dy = -2; 
paddleX = (canvas.width - paddleWidth) / 2; 
} 
现在，当小球碰到屏幕底边时，我们让变量lives 的值减一。 
如果生命用尽，游戏就宣告结束；否则就重置小球与球板的位置，以及小球的速度。 
渲染生命值 
现在只需在 draw() 函数内调用drawLives() 即可。 让我们把它加到drawScore() 的下一行： 
drawLives(); 
用 requestAnimationFrame() 优化渲染 
现在让我们处理一些与游戏机制无关，但与画面渲染相关的东西。 和我们目前使用{{domxref(“windowTimers.setInterval()”, “setInterval()”)}} 实现的固定帧率渲染相比，{{domxref(“window.requestAnimationFrame”, “requestAnimationFrame”)}} 能让浏览器更好地渲染画面。 
让我们把下面这行代码： 
var interval = setInterval(draw, 10); 
替换为： 
draw(); 
再把代码中的每一处 
clearInterval(interval); // Needed for Chrome to end game 
删除。 然后，在 draw() 函数的最下方（右花括号之前）加入下面这行代码。 它的作用是使 draw() 函数递归调用自身： 
requestAnimationFrame(draw); 
现在 draw() 函数在 requestAnimationFrame() 的循环中被反复调用，之先前做法最大的不同是，我们将帧率的控制权交给浏览器，而不是固定的 10 毫秒。 
浏览器会在适当的时机同步帧率，并且只在必要的时候才刷新渲染的图形。 
这使得我们的动画比之前的 setInterval() 方法更加流畅且高效。 
比较你的代码 
我们的游戏的最终版本已经完成！ 以上。 
{{JSFiddleEmbed(“https://jsfiddle.net/raymondjplante/dfh2tpu1/”,““,”395”)}} 
备注： 试着改变生命的数目和球从球板上反弹的角度。 
祝贺你——你完成了本教程的所有小节！ 
现在，你应该已经掌握 canvas 操纵的基础和 2D 游戏背后的逻辑了。 
是时候去学习一些框架，继续你的游戏开发之旅了！ 
你可以看看本系列的姊妹篇：用 Phaser 制作 2D 打砖块游戏 或者 Cyber Orb built in Phaser 。 
或者，你也可以在 MDN 游戏区 中获得灵感和更多知识。 
你也可以回到本教程的目录页。 
祝编程愉快！ 
{{Previous(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Mouse_controls”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Paddle_and_keyboard_controls”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Build_the_brick_field”)}} 
这是 Gamedev Canvas tutorial教程的第五章。 
你可以在完成本课程后在这里Gamedev-Canvas-workshop/lesson5.html找到源代码。 
看球从墙上反弹，并能够移动球盘是很有趣的。 
但除此之外，游戏什么都不做，也没有任何进展或最终目标。 
从游戏的角度来看，我们需要一个 game over。 
如果你的球拍错过了球，并且球到达屏幕的底部边缘，那么游戏就结束了。 
实现游戏失败 
让我们在代码中实现，下面是第三章里的一段代码，让球从墙上反弹： 
if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) { 
dx = -dx; 
} 
if (y + dy > canvas.height - ballRadius || y + dy < ballRadius) { 
dy = -dy; 
} 
我们不需要让球从四面墙上反弹，应该只允许三个 - 左，上，右。 
击中底部墙将结束游戏。 
我们将编辑第二个 if 代码块，这是一个 if else 块，当球碰撞到画布的底部边缘时，它会触发我们的“游戏结束”状态。 
现在我们将保持简单，显示一条警告消息，并通过重新加载页面重新开始游戏。 
第一步，把你最开始使用的 setInterval() 函数 
setInterval(draw, 10); 
替换成： 
var interval = setInterval(draw, 10); 
然后将第二个 if 块替换为以下内容： 
if (y + dy < ballRadius) { 
dy = -dy; 
} else if (y + dy > canvas.height - ballRadius) { 
alert("GAME OVER"); 
document.location.reload(); 
} 
让球拍接住球 
本课中最后要做的是在球和球拍之间创建一些碰撞检测，以便它可以反弹并返回到游戏区域。 
最简单的方法是检查球的中心是否在球拍的左边和右边之间。 
再次更新你修改的代码的最后一位（第二个 if 块），如下所示： 
if (y + dy < ballRadius) { 
dy = -dy; 
} else if (y + dy > canvas.height - ballRadius) { 
if (x > paddleX && x < paddleX + paddleWidth) { 
dy = -dy; 
} else { 
alert("GAME OVER"); 
document.location.reload(); 
} 
} 
如果球击中画布的底部边缘，我们需要检查它是否碰到球拍。 
如果是的话，就像你所期望的那样反弹。 如果没有，那么游戏就像以前一样结束。 
代码对比 
这里是完整例子，对比一下代码吧！ 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/z4zy79fo/”,““,”320”)}} 
备注： 当球碰到球拍时，让球移动得更快 
下一步 
到目前为止，我们的表现相当不错，游戏变得更有趣，并且现在你可以输了！ 
但它仍然缺少一些东西。 
让我们继续前进到第六章 - 建造砖块 - 并创造一些砖块来消灭它们。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Paddle_and_keyboard_controls”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Build_the_brick_field”)}} 

{{GamesSidebar}} 
{{Next(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Create_the_Canvas_and_draw_on_it”)}} 
在这里我们将完全使用 JavaScript 语言基于 HTML5 的 canvas 标签，一步一步的绘制一个简单的 MDN 消除游戏。 
过程中的每一步都会有例子可供体验，让你更清晰的了解他的制作过程。 
你将学习到如何使用 canvas 标签的基本语法去实现简单游戏的渲染、动画、碰撞、控制胜负。 
为了更快速高效的学习本系列教程，你需要掌握 JavaScript 的一些基础知识。 
学习完本教程之后你就可以创建自己的网页小游戏了。 
Gameplay screen from the game MDN Breakout where you can use your paddle to bounce the ball and destroy the brick field, with keeping the score and lives. 
教程详情 
全部教程 — MDN 消除小游戏 的各个版本我们正一起管理并托管到 GitHub 上： 
创建、绘制画布 
让球动起来 
反弹的墙 
游戏结束 
创建砖块 
撞击处理 
统计得分、获得胜利 
鼠标控制 
完成 
对于实现一个网页游戏而言，最好的方式是从纯 JavaScirpt 着手，那样可以让我们建立更坚实的基础。 
之后你可以在你的项目中选择你喜欢的框架。 
框架也只是用 JavaScript 语言实现的工具；如果你想要在项目中使用框架，你必须先了解语言本身。 
框架可以帮你提高开发效率并生成一些基础的内容；但是如果没有达到你的预期，你只能慢慢调试或者使用原生 JavaScript 去实现解决方案。 
备注： 如果你对使用第三方游戏资源库开发 2d 网页游戏感兴趣，可以参考本系列教程的 2D breakout game using Phaser. 
备注： 本系列教程可以用作游戏开发工作室的素材资源。 
如果你想探讨普通的游戏开发，你可以利用Gamedev Canvas Content Kit以及本教程的内容。 
下一步 
好，让我们开始吧。 
第一步 — 创建、绘制画布 
{{Next(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Create_the_Canvas_and_draw_on_it”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Track_the_score_and_win”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Finishing_up”)}} 
本篇为 Gamedev Canvas tutorial 10 节教程中的第 9 节。 
在你完成这篇课程之后，你可以在 Gamedev-Canvas-workshop/lesson9.html 找到我们的源代码。 
这个游戏实际已经完成，现在让我们着手去润色。 
我们已经添加过键盘控制，而加入鼠标控制也同样简单。 
监听鼠标移动 
监听鼠标移动甚至比监听按键更简单：只需监听 {{domxref(“Element/mousemove_event”, “mousemove”)}} 这个事件即可。 
把下面这行代码和其他事件监听代码放在一起，在 keyup event 的下一行： 
document.addEventListener("mousemove", mouseMoveHandler, false); 
将球板移动绑定到鼠标移动 
我们可以根据鼠标光标位置来更新球板位置——下面这个函数正是做这件事的。 
把这个函数加到你的代码中，接在你刚刚加入的那行后面： 
function mouseMoveHandler(e) { 
var relativeX = e.clientX - canvas.offsetLeft; 
if (relativeX > 0 && relativeX < canvas.width) { 
paddleX = relativeX - paddleWidth / 2; 
} 
} 
在这个函数中，我们首先计算 relativeX 的值，它等于鼠标在视窗中的水平位置 (e.clientX) 减去 canvas 元素左边框到视窗左边框的距离 (canvas.offsetLeft) —— 这就得到了 canvas 元素左边框到鼠标的距离。 
若这个值大于零，且小于 canvas 的宽度，说明鼠标指针落在 canvas 边界内，这时就把 paddleX （等于球板左边缘的坐标）设为 relativeX 减速去球板宽度的一半。 这样就确保位移是相对于球板中心进行的。 
现在球板将跟随鼠标指针。 不过由于我们将球板移动限制在 canvas 大小范围内，它不会从两边完全消失。 
比较你的代码 
以下是我们的示例代码，以便与你进行比较： 
{{JSFiddleEmbed(“https://jsfiddle.net/raymondjplante/vt7y5hcp/”,““,”395”)}} 
练习：调整球板移动的范围，使得整个球板总是可见，而不是在移动到边缘时被遮住一半。 
下一步 
现在我们已经拥有一个完整的游戏。 
我们的系列教程将以一些细节上的调整作为结束。 

{{GamesSidebar}}{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Create_the_Canvas_and_draw_on_it”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Bounce_off_the_walls”)}} 
本篇是 Gamedev Canvas tutorial 10 节教程中的第二节。 
如果你完成了本篇教程之后，你可以从 Gamedev-Canvas-workshop/lesson2.html 看到源码。 
从上一节中你已经知道如何去绘制一个球。 现在让我们使它动起来。 
从技术上讲，我们将在画布上绘制一个球，之后让它消失，然后在一个稍微不用的位置上再绘制一个一样的球。 
就想电影里的每一帧动起来的感觉。 
我们需要定义一个绘图函数，每次使用一组不同的变量改变球体的位置；循环调用以保持画布上每一帧不断更新。 
你可以使用 JavaScript 时间函数 {{domxref(“WindowTimers.setInterval()”, “setInterval()”)}} 或者 {{domxref(“window.requestAnimationFrame()”)}}。 
在你的 HTML 文件只保留前两行，删除其他所有的 JavaScript 代码并在 draw() 函数中添加以下内容保证每 10 毫秒执行一次 draw() 函数： 
function draw() { 
// drawing code 
} 
setInterval(draw, 10); 
得益于 setInterval 的无限性，使得 draw() 函数将每 10 毫秒就会被调用，除非我们停止它。 
现在，我们来绘制小球吧，在 draw() 函数中添加以下内容： 
ctx.beginPath(); 
ctx.arc(50, 50, 10, 0, Math.PI * 2); 
ctx.fillStyle = "#0095DD"; 
ctx.fill(); 
ctx.closePath(); 
现在，尝试更新你的代码，球会在每一帧画面被绘制 
让球动起来 
你不会注意到球正在不停地被重新刷，因为它没有移动。 
让我们改变这种情况。 
首先，我们不再使用固定位置 (50,50)，而是用 x 和 y 的变量来定义画布底部的起始点，然后使用这些变量来定义圆被绘制的位置。 
首先，在draw()函数上方添加以下两行，以定义x和y： 
var x = canvas.width / 2; 
var y = canvas.height - 30; 
接下来更新 draw() 函数，在 arc() 方法中使用 x 和 y 变量，如下面高亮行所示： 
function draw() { 
ctx.beginPath(); 
ctx.arc(x, y, 10, 0, Math.PI * 2); 
ctx.fillStyle = "#0095DD"; 
ctx.fill(); 
ctx.closePath(); 
} 
现在到了最重要的部分：我们想要在每一帧都被绘制出来之后，给 x 和 y 添加一个较小的值，让它看起来像是在移动。 
让我们将这些值定义为 dx 和 dy，并将它们的值分别设为 2 和 -2。 
在你的 x 和 y 变量声明下方添加以下内容： 
var dx = 2; 
var dy = -2; 
最后要做的是在每一帧上更新 x 和 y，在每一次更新中，把球画在新的位置上。 
将下面的两条新线添加到你的 draw() 函数： 
function draw() { 
ctx.beginPath(); 
ctx.arc(x, y, 10, 0, Math.PI * 2); 
ctx.fillStyle = "#0095DD"; 
ctx.fill(); 
ctx.closePath(); 
x += dx; 
y += dy; 
} 
再次保存代码，并在浏览器中尝试。 
很好，尽管看起来球在后面留下了痕迹： 
在每一帧更新之前清空画布 
球移动时留下了轨迹，因为我们在每一帧上都画了一个新的圆，而没有去掉之前的一个圆。 
不要担心，因为有一个方法来清空画布的内容：clearRect()。 
该方法有四个参数：矩形左上角的 x 和 y 坐标，以及矩形的右下角的 x 和 y 坐标。 
这个矩形覆盖的整个区域里，之前所画的任何内容将被清除。 
将下列高亮显示行添加到 draw() 函数： 
function draw() { 
ctx.clearRect(0, 0, canvas.width, canvas.height); 
ctx.beginPath(); 
ctx.arc(x, y, 10, 0, Math.PI * 2); 
ctx.fillStyle = "#0095DD"; 
ctx.fill(); 
ctx.closePath(); 
x += dx; 
y += dy; 
} 
保存你的代码并再次尝试，这次你将看到球移动后没有留下轨迹。 
每隔 10 毫秒，画布就会被清除，蓝色的圆圈 (我们的球) 将被绘制在一个给定的位置上，而 x 和 y 的值将在下一个帧被更新。 
保持代码整洁 
在接下来的几篇文章中，我们将在 draw() 函数中添加越来越多的命令，因此尽可能保持简单和整洁是很好的。 
让我们从把绘制球的代码移至一个单独的函数。 
用以下两个函数替换现有的 draw() 函数： 
function drawBall() { 
ctx.beginPath(); 
ctx.arc(x, y, 10, 0, Math.PI * 2); 
ctx.fillStyle = "#0095DD"; 
ctx.fill(); 
ctx.closePath(); 
} 
function draw() { 
ctx.clearRect(0, 0, canvas.width, canvas.height); 
drawBall(); 
x += dx; 
y += dy; 
} 
比较你的代码 
你可以在下面的实时演示中查看本文的代码，并使用它来更好地了解其工作原理： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/3x5foxb1/”,““,”415”)}} 
练习：尝试改变移动球的速度，或者移动球的方向。 
下一步 
我们已经画了我们的球，并将其移动，但它仍然消失在画布的边缘。 
在第三章中，我们将探讨如何使其 从墙壁上反弹. 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Create_the_Canvas_and_draw_on_it”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Bounce_off_the_walls”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Bounce_off_the_walls”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Game_over”)}} 
这是Gamedev Canvas tutorial中的第四章。 
完成本课程后，你可以在Gamedev-Canvas-workshop/lesson4.html找到源码。 
你可以看到球自由的、无限次的在墙壁上反弹，但是没有和我们发生任何交互。 
如果我们没有对它的控制操作，这仍然不是一个游戏。 
下面，我们新增一些用户操作：一个可以控制球的球板。 
定义一个球板去接球 
我们需要添加一个球板去接球：为此需要先定义一些变量。 
在你的代码的顶部的其他变量下方添加下列代码： 
var paddleHeight = 10; 
var paddleWidth = 75; 
var paddleX = (canvas.width - paddleWidth) / 2; 
然后定义球拍的长和宽，以及为了之后的处理同时定义 x 轴上的初始位置。 
新建一个方法来在页面上描绘球板。 
把下列代码添加到你的 drawBall() 方法里去： 
function drawPaddle() { 
ctx.beginPath(); 
ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight); 
ctx.fillStyle = "#0095DD"; 
ctx.fill(); 
ctx.closePath(); 
} 
允许用户控制球板 
我们可以如愿的描绘出球板，也需让它听从用户的控制。 
是时候实现用键盘控制它了。 
我们需要： 
两个变量以保存左右方向键是否被按下的信息。 
两个事件监控器来捕捉按键的按下和松开动作。 
我们需要运行一些代码以在按键被按下时可以控制球拍的移动 
两个用于处理按键被按下或松开后的事件处理方法 
实现左右移动球拍 
按键可以使用 boolean 变量来初始定义。 
在你的其他变量附近添加下列代码： 
var rightPressed = false; 
var leftPressed = false; 
这两个变量的默认值都是 false，因为在开始时按键没有被按下。 
为了监听按键的按下动作，我们需要添加两个监听器。 
把下列代码添加到底部的 setInterval() 的上一列去： 
document.addEventListener("keydown", keyDownHandler, false); 
document.addEventListener("keyup", keyUpHandler, false); 
当你按下任何键盘上的按键，按下事件被激活时 keyDownHandler() 方法会被调用。 
对于松开时的处理也是类似的：当松开按键时 keyUpHandler() 方法会被调用。 
把下列代码添加到 addEventListener() 下方： 
function keyDownHandler(e) { 
if (e.keyCode == 39) { 
rightPressed = true; 
} else if (e.keyCode == 37) { 
leftPressed = true; 
} 
} 
function keyUpHandler(e) { 
if (e.keyCode == 39) { 
rightPressed = false; 
} else if (e.keyCode == 37) { 
leftPressed = false; 
} 
} 
当按下一个按键，这个信息会被储存在一个变量中。 
每种情况下的相关变量都设置为true。 
当松开按键时，对应变量被设置回false。 
两个函数都以一个事件作为参数，由e(event) 变量表示。 
从这里你可以得到有用的信息：keyCode 属性是被按下的键的信息。 
例如，keyCode 为 37 是左箭头键，而 39 是右箭头键。 
如果按下左键，那么 leftPressed 变量设置为 true，当松开时，leftPressed 变量设置为 false。 
右键同理。 
球拍移动逻辑 
我们现在有用于存储按键，事件监听器和相关功能的信息的变量。 
现在我们将看到实际的代码来使用这些变量，并在屏幕上移动球拍。 
在 draw（）函数内部，我们将检查每一帧被渲染的同时是否按下左或右键。 
我们的代码如下： 
if (rightPressed) { 
paddleX += 7; 
} else if (leftPressed) { 
paddleX -= 7; 
} 
如果按一下左键，球拍将向左移动 7 个像素，如果按一下右键，球拍将向右移动 7 个像素。 
目前这个功能可以正常工作，但是如果我们按任意一个键的时间太长，球拍就会从画布的边缘消失。 
我们可以通过改变代码来改善这种情况，并且只能在画布的边界内移动球拍，如下所示： 
if (rightPressed && paddleX < canvas.width - paddleWidth) { 
paddleX += 7; 
} else if (leftPressed && paddleX > 0) { 
paddleX -= 7; 
} 
我们使用在Canvas左侧的 0 和右侧的canvas.width-paddleWidth之间的paddleX位置移动，这会让球拍按预期的要求移动。 
将上面的代码块添加到底部的draw()函数中，在右大括号的上方。 
现在唯一要做的就是在draw()函数内调用drawPaddle()函数，将其实际渲染在屏幕上。 
在draw()函数内添加下面一行，就在调用drawBall()的那一行的下面： 
drawPaddle(); 
比较你的代码 
以下是我们的示例代码，以便与你进行比较： 
{{JSFiddleEmbed(“https://jsfiddle.net/end3r/tgn3zscj/”,““,”320”)}} 
备注： 让球拍变快变慢，或者改变它的大小。 
下一步 
现在我们有一些类似于游戏的东西。 
唯一的麻烦就是无论如何你都可以继续用球拍击球。 
这一切都将在第五章中改变，游戏结束时，我们会为游戏添加一个最后的状态。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Bounce_off_the_walls”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Game_over”)}} 

{{GamesSidebar}} 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Collision_detection”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Mouse_controls”)}} 
本篇为Gamedev Canvas tutorial10 节教程中的第 8 节。 
在你完成这篇课程之后，你可以在Gamedev-Canvas-workshop/lesson8.html找到我们的源代码。 
破坏砖块真的很酷，但更酷的是，游戏可以给每个用户击破的砖块奖励分数，并保持总分。 
计算分数 
如果你能在整个游戏中看到你的分数，最终你会给你的朋友留下深刻印象。 
你需要一个变量来记录分数。 
在变量的其余部分之后，将下面的内容添加到 JavaScript 中： 
var score = 0; 
你还需要一个 drawScore() 函数来创建和更新分数显示。 
在 collisionDetection() 函数之后添加以下内容： 
function drawScore() { 
ctx.font = "16px Arial"; 
ctx.fillStyle = "#0095DD"; 
ctx.fillText("Score: " + score, 8, 20); 
} 
在画布上绘制文本类似于绘制形状。 
字体定义看起来与 CSS 中的字体定义完全一样——可以在{{domxref(“CanvasRenderingContext2D.font”,“font()”)}} 方法中设置大小和字体类型。 
然后使用{{domxref(“CanvasRenderingContext2D.fillStyle()”,“fillStyle()”)}} 来设置字体的颜色，{{domxref(“CanvasRenderingContext2D.fillText”,“fillText()”)}} 来设置将放置在画布上的实际文本，和其放置位置。 
第一个参数是文本本身——上面的代码显示当前点的数量——最后两个参数是文本将放置在画布上的坐标。 
若要在每次击中砖块时评分，则在 collisionDetection()中添加计分规则，以在每次检测到碰撞时增加得分变量的值。 
将下面突出显示的行添加到代码中： 
function collisionDetection() { 
for (var c = 0; c < brickColumnCount; c++) { 
for (var r = 0; r < brickRowCount; r++) { 
var b = bricks[c][r]; 
if (b.status == 1) { 
if ( 
x > b.x && 
x < b.x + brickWidth && 
y > b.y && 
y < b.y + brickHeight 
) { 
dy = -dy; 
b.status = 0; 
score++; 
} 
} 
} 
} 
} 
从 draw() 函数调用 drawScore() ，使每一个新帧的分数都保持最新，在 draw()中添加下面的行，在 drawPaddle() 下面调用： 
drawScore(); 
当所有砖块被破坏时显示获胜消息 
收集这些点很有效，但是你不会永远添加它们 - 当所有的砖头都被破坏的时候呢？ 
毕竟这是游戏的主要目的，所以如果收集到所有可用的点，你应该显示一个获胜的消息。 
将下面突出显示的部分添加到 collisionDetection() 函数中： 
function collisionDetection() { 
for (var c = 0; c < brickColumnCount; c++) { 
for (var r = 0; r < brickRowCount; r++) { 
var b = bricks[c][r]; 
if (b.status == 1) { 
if ( 
x > b.x && 
x < b.x + brickWidth && 
y > b.y && 
y < b.y + brickHeight 
) { 
dy = -dy; 
b.status = 0; 
score++; 
if (score == brickRowCount * brickColumnCount) { 
alert("YOU WIN, CONGRATULATIONS!" 
); 
document.location.reload(); 
} 
} 
} 
} 
} 
} 
谢谢你做的这些，你的用户可以真正赢得游戏时，他们也摧毁了所有的砖块。 
当用户来到游戏还有一点非常重要，用户一旦点击了警告按钮， document.location.reload()函数将重新加载页面并重新启动游戏。 
比较你的代码 
最新的代码是这样（和工程），如果你想比较和对比它与你写的： 
{{JSFiddleEmbed(“https://jsfiddle.net/yumetodo/2m74vr9r/1/”,““,”395”)}} 
备注： 在每一个砖头击破后添加更多的分数，打印出收集到的点数在游戏结束警告框中。 
下一节 
游戏到这一步看起来相当不错。 
在下一课中，你将通过添加鼠标控件来扩大游戏的吸引力：Mouse controls.。 
{{PreviousNext(“Games/Workflows/2D_Breakout_game_pure_JavaScript/Collision_detection”, “Games/Workflows/2D_Breakout_game_pure_JavaScript/Mouse_controls”)}} 

{{GamesSidebar}} 
本页面包含多个教程系列，重点介绍高效创建不同类型的 Web 游戏的不同工作流程。 
使用纯 JavaScript 实现 2D 打砖块游戏 
: 在该手把手教程中，你将使用纯 JavaScript 来实现一个简单的打砖块游戏。 
在这个过程中，你将学习使用 {{htmlelement(“canvas”)}} 元素来实现基本的游戏机制，如渲染和移动图像、碰撞检测、控制机制以及获胜和失败状态。 
使用 Phaser 实现 2D 打砖块游戏 
: 在该手把手教程中，你将实现与之前的教程系列中相同的打砖块游戏，只不过这次你将使用 Phaser HTML 游戏框架来实现。 
这里的想法是教授一些使用框架的基础知识（及优势），以及基本的游戏机制。 
使用设备方向的 2D 迷宫游戏 
: 该教程展示如何使用 HTML，结合碰撞检测及在 {{htmlelement(“canvas”)}} 中放置精灵的基础知识来创建一个 2D 迷宫游戏。 
这是一个移动端游戏，它使用设备方向和振动 API 来增强游戏体验，并使用 Phaser 框架构建。 
使用 Phaser 构建 2D 平台游戏 
: 本教程系列展示了如何使用 Phaser 创建一个简单的平台游戏，涵盖了精灵、碰撞、物理、收集物品等基础知识。 

{{GlossarySidebar}} 
在{{Glossary(“computer programming”, “计算机编程”)}}领域中，抽象编程指在研发大型复杂软件系统时，通过抽象的方法来降低编程复杂度，实现系统快速高效设计和开发的编程模式。 
它将系统各功能实现的技术细节隐藏在相对简单的 {{Glossary(“API”, “API 接口”)}}之后。 
数据抽象的好处 
使用户避免撰写低等级代码。 
避免代码重复，增加代码的复用性。 
在不影响用户的前提下可以独立修改类的内部实现。 
有效提升应用程序的安全性，因为只向用户提供重要的细节。 
示例 
class ImplementAbstraction { 
// 设置一系列内部成员的值的方法 
set(x, y) { 
this.a = x; 
this.b = y; 
} 
display() { 
console.log(`a = ${this.a}`); 
console.log(`b = ${this.b}`); 
} 
} 
const obj = new ImplementAbstraction(); 
obj.set(10, 20); 
obj.display(); 
// a = 10 
// b = 20 
参见 
维基百科上的抽象化 

{{GlossarySidebar}} 
强调色（accent）通常为一种明亮的颜色，与颜色方案中更实用的背景和前景色形成对比。 
这些颜色存在于很多平台（但不是所有平台）的视觉样式中。 
在 web 上，强调色有时用于 {{HTMLElement(“input”)}} 元素中控件的活跃部分，例如勾选的复选框的背景。 
参见 
与强调色相关的 CSS 
为设置指定元素的强调色，可以将元素的 CSS {{CSSXref(“accent-color”)}} 属性设置为合适的 {{CSSXref(“<color>”)}} 值。 

{{GlossarySidebar}} 
无障碍网页（Web Accessibility，缩写：A11Y）指在物理条件和技术条件限制下，保证网站达到最佳可用性的实践。{{ 
Glossary(“W3C”)}} 组织的 {{Glossary(“WAI”,“Web 无障碍倡议”)}}（WAI）正式定义和论述了 Web 无障碍技术。 
参见 
MDN 上的无障碍资源 
维基百科的 Web 无障碍词条 
学习无障碍 
Web Accessibility In Mind 
MDN 上的 ARIA 文档 
Web 无障碍倡议主页 WAI-ARIA 推荐 

{{GlossarySidebar}} 
Flash 是一项由 Adobe 开发的技术，它用于富 Web 应用程序、矢量图形和多媒体的呈现，目前已经过时。 
自从 2021 年开始，Flash 技术已不受 Adobe 或任何主流 web 浏览器的支持。 
参见 
Adobe Flash end-of-life announcement 
Saying goodbye to Flash in Chrome 
Firefox Roadmap for Flash End-of-Life 
Microsoft Windows Flash Player removal 

{{GlossarySidebar}} 
AJAX（Asynchronous {{glossary(“JavaScript”)}} And {{glossary(“XML”)}} ）是一种使用 {{glossary(“XMLHttpRequest”)}} 技术构建更复杂，动态的网页的编程实践。 
AJAX 允许只更新一个 {{glossary(“HTML”)}} 页面的部分 {{glossary(“DOM”)}}，而无须重新加载整个页面。 
AJAX 还允许异步工作，这意味着当网页的一部分正试图重新加载时，你的代码可以继续运行（相比之下，同步会阻止代码继续运行，直到这部分的网页完成重新加载）。 
通过交互式网站和现代 Web 标准，AJAX 正在逐渐被 JavaScript 框架中的函数和官方的 {{domxref(“Fetch API”)}} 标准取代。 
参见 
Ajax 
{{DOMxRef(“XMLHttpRequest”)}} 
{{DOMxRef(“Fetch API”)}} 
使用 Fetch API 
维基百科上的 AJAX 

{{GlossarySidebar}} 
算法是一个良定义的具体计算步骤的一个序列。 
换句话说，一个算法就是由人或机器可重复的解决问题的方法。 
计算机科学家们使用算法的复杂度（又称 O 标记法）来表示算法的效率。 
例如： 
一道菜谱就是供人使用的算法 
一种编程中常用的排序算法就是用来描述计算机如何给数据排序的 
常用的算法有寻找最优路径算法，例如“旅行推销员问题”、“树的遍历算法”等。 
还有很多机器学习算法例如“线性回归”、“决策树”、“随机森林”、“支持向量机”、“循环神经网络（RNN）”、“长短时记忆（LSTM）神经网络”、“卷积神经网络（CNN）”、“深度卷积神经网络”等。 
更多详情 
Algorithm，维基百科 
Explanations of sorting algorithms 
Explanations of algorithmic complexity 

{{GlossarySidebar}} 
应用层协议协商（Application-Layer Protocol Negotiation，简称 ALPN）是由 RFC 7301 定义的一个 {{Glossary(“TLS”)}} 扩展，故而应用层协议在协商加密协议的过程中，避免了额外的往返通讯开销。 
协议 
标识符字节序列 
{{Glossary(“HTTP”, “HTTP/1.1”)}} 
0x68 0x74 0x74 0x70 0x2F 0x31 0x2E 0x31 (“http/1.1”) 
{{Glossary(“HTTP 2”, “HTTP/2”)}} 
0x68 0x32 (“h2”) 
HTTP/2 over cleartext {{Glossary(“TCP”)}} 
0x68 0x32 0x63 (“h2c”) 
参见 
IANA 注册的 ALPN 标识符 

{{GlossarySidebar}} 
在 Web 开发中，API 通常是开发者能用在应用（app）中的一系列代码特性（如 {{glossary(“method”,“方法”)}}、{{Glossary(“property”,“属性”)}}、事件 和 {{Glossary(“URL”,“URL”)}}），这些特性被用于与用户的 web 浏览器中的组件、用户电脑上的其他软硬件或者第三方软件与服务交互。 
Twitter APIs 能被用于从用户的 twitter 账户获取数据，然后可以在一个网页上展示他们最近的 tweet。 

{{GlossarySidebar}} 
Safari是苹果公司开发的{{Glossary(“Browser”,“Web browser”)}}，与 Mac OS X 和 iOS 绑定。 
它基于开源的WebKit引擎。 了解更多 
基本信息 
Safari on apple.com 
技术信息 
The WebKit project 
WebKit nightly build 
Reporting a bug for Safari 

{{GlossarySidebar}} 
argument 是一个作为函数输入的值（原始数据或对象）。 
学到更多 
基本知识 
Parameter 和 Argument 之间的差异 - 维基百科 
技术参考 
JavaScript 中的 arguments 对象 

{{GlossarySidebar}} 
ARIA (Accessible Rich {{glossary(“Internet”)}} Applications) 是向{{Glossary(“HTML”)}} 中添加语义和其他元数据的{{Glossary(“W3C”)}} 规范，以满足用户的辅助技术的需要。 
例如，你可以将 role="alert"添加到{{HTMLElement(“p”)}} {{glossary(“tag”)}}以通知视力有问题的用户该信息是重要的（否则你可能通过文字颜色传达）。 
更多 
ARIA 

{{GlossarySidebar}} 
.arpa (address and routing parameter area，地址路由参数域 ) 是专门用来互联网基础设施配置的顶级域{{glossary(“TLD”,“top-level domain”)}} ，尤其是 DNS 反向解析，即从 {{glossary(“IP 地址”)}}) 找出旗下的主机名 (i.e., find the {{glossary(‘domain name’)}} 。 
了解更多 
通用知识库 
官方网站 
.arpa，来自维基百科 

{{GlossarySidebar}} 
ARPAnet （高级研究计划署网络）是早期的一个计算机网络，于 1969 年建立，作为一个传送敏感军事数据和连接全美领先研究组的稳健媒介。 
ARPAnet 原先运行于 NCP（网络控制协议）之上，后来运行于第一个版本的互联网协议或 {{glossary(“TCP”)}}/{{glossary(“IPv6”,“IP”)}} 协议族，使 ARPAnet 成为初期 {{glossary(“Internet”, “互联网”)}} 中显著的一部分。 
ARPAnet 于 1990 年初关闭。 
了解更多 
基础知识 
维基百科上的 Arpanet 

{{GlossarySidebar}} 
数组对象是一个有序的数据（根据语言不同，数据可以是{{Glossary(“primitive”,“原始类型”)}}或{{Glossary(“object”,“对象类型”)}}）集合。 
相对于变量，数组可用于在一个变量中存储多个变量值。 
数组中的每一项都有可供访问的数字索引。 
在 JavaScript 中，数组索引从 0 开始，并可以使用多种{{Glossary(“Method”, “方法”)}}操作。 
JavaScript 中的数组形式如下： 
let myArray = [1, 2, 3, 4]; 
let catNamesArray = ["Jacqueline", "Sophia", "Autumn"]; 
//Javascript 数组可以包含不同类型的数据，如上所示。 

{{GlossarySidebar}} 
ASCII (American Standard Code for Information Interchange，美国信息交换标准码) 是计算机中最常用的编码方式，用于将字母，数字，标点符号和控制字符转换为计算机可以理解的数字形式。 
从 2007 年开始逐渐被{{Glossary(“UTF-8”)}} 代替。 
更多： 
ASCII on Wikipedia 

{{GlossarySidebar}} 
异步指两个或两个以上的对象或事件不同时存在或发生（或多个相关事物的发生无需等待其前一事物的完成）。 
在计算机技术中，“异步”一词被用于两大语境。 
网络与通信 
: 异步通信是一种在双方或多方之间交换消息的方式。 
其中每个参与方各自在他们方便或可操作的情况下接收并处理消息，而不是在收到消息后立即进行处理。 
另外，消息的发送无需等待确认信息，前提是如果出现问题，接收方将请求更正或以其他方式处理该情况。 
对人类来说，电子邮件就是一种异步通信方式；发送者发送了一封邮件，接着接收者会在方便时读取和回复该邮件，而不是马上这样做。 
双方可以继续随时发送和接收信息，而无需双方安排何时进行操作。 
在软件进行异步通信时，一个程序可能会向另一软件（如服务器）请求信息，并在等待回复的同时继续执行其他操作。 
例如，AJAX(Asynchronous JavaScript and {{Glossary(“XML”)}}) 编程技术（现在通常简写为”Ajax”，不过现在的应用不常用 XML，而是用{{Glossary(“JSON”)}}）就是这样一种机制，它通过 HTTP 从服务器请求较少的数据，当结果可被返回时才返回结果，而不是立即返回。 
软件设计 
: 异步软件设计通过构建代码扩展了异步的概念，按照这种设计编写的代码使得程序能够要求一个任务与先前的一个（或多个）任务一起执行，而无需为了等待它们完成而停止执行。 
当后来的任务完成时，程序将使用约定好的机制通知先前的任务，以便让它知道任务已经完成，以及如果有结果存在的话，这个结果是可用的。 
还有许多用来实现异步软件的编程技术。 
查看文章Asynchronous JavaScript来了解它们吧。 了解更多 
技术参考 
Fetching data from the server (Learning Area) 从服务器获取数据 
{{glossary(“Synchronous”)}} 同步 

{{GlossarySidebar}} 
Attribute （标签属性）用于拓展 HTML for paragraph. 
Note that the end tag’s name is preceded by a slash character, “</p>”, and that in empty elements the end tag is neither required nor allowed. 
If attributes are not mentioned, default values are used in each case.”>tag，可改变标签行为或提供元数据，属性总是以name = value的格式（属性的识别码后接与之相关的值） 
深入了解 
技术参考 
HTML attribute reference 
关于 HTML’s global attributes 的信息 

{{GlossarySidebar}} 
带宽是对于在给定时间内有多少的信息能够通过数据通道的一个度量。 
它经常以每秒钟多少 bits 的形式来表示，例如 Mb/s,Gb/s。 
了解更多 
Bandwidth on Wikipedia 


{{GlossarySidebar}} 
基线是指欧洲和西亚文字排版中，用于在上面放置字符的一条假想的基准线。 
字符下降的部分，比如 g 和 p，会向下超出基线，带弧形的会向上和向下扩展的字形（{{Glossary(“glyph”, “Glyph”)}}），比如 C 或 3，会略微向下超出基线。 
参见 
维基百科上的基线 

{{GlossarySidebar}} 
贝塞尔曲线是一种使用数学方法描述的曲线，被广泛用于计算机图形学和动画中。 
在矢量图中，贝塞尔曲线用于定义可无限放大的光滑曲线。 
贝塞尔曲线由至少两个控制点进行描述。 
Web 技术中使用的是三次贝塞尔曲线，即使用四个控制点 P0、P1、P2 和 P3 描述的曲线。 
在绘制曲线的过程中，需要先作两条辅助线：P0 到 P1 和 P1 到 P2；辅助线的端点沿着所在连线平滑地移动到连线的另一端；采用同样的方法在辅助线 P0-P1 和 P1-P2 上绘制第三条辅助线；在第三条辅助线上将一个点从一端平滑地移向另外一端，这个点的运动轨迹就是贝塞尔曲线。 
下面是这个绘图过程的动态演示： 
绘制一条贝塞尔曲线 
参见 
维基百科上的贝塞尔曲线词条 
CSS 中的贝塞尔时间函数 
{{SVGAttr(“keySplines”)}} SVG 属性 

{{GlossarySidebar}} 
BiDi (BiDirectional) 是指一篇文档中同时包含了从左至右和从右至左阅读的文本。 
即使在同一段落中同时出现这两种类型，也必须保证每种语言文本都以正确的方式呈现。 
参见 
维基百科的Bi-directional text 

{{GlossarySidebar}} 
在{{Glossary(“JavaScript”)}}中，BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数。 
而在其他编程语言中，可以存在不同的数字类型，例如：整数、浮点数、双精度数或大斐波数。 了解更多 
知识点 
维基百科：Numeric types 
JavaScript 数据结构：BigInt 
JavaScript 全局对象 {{jsxref(“BigInt”)}} 

{{GlossarySidebar}} 
Blink 是一个开源的浏览器布局引擎，由谷歌作为 Chromium 项目的一部分开发（因而也是 Chrome 的一部分）。 
具体而言，Blink 是一个派生自 {{glossary(“WebKit”)}} 项目中 WebCore 库的分支，用于处理布局、渲染以及 {{Glossary(“DOM”)}}。 
了解更多 
常识 
Blink 项目 主页（英文） 
Wikipedia 上的信息：Blink 
Blink 的 FAQ （英文） 

{{GlossarySidebar}} 
分组密码工作模式（Block cipher mode of operation）通常在上下文中称为“模式”，它指定应如何使用分组密码来加密或解密长于块大小的消息。 
当前使用的大多数对称密钥算法都是分组密码：这意味着它们一次加密一个块的数据。 
每个块的大小是固定的，并由算法确定：例如，AES 使用 16 字节的块。 
分组密码始终与一种模式一起使用，该模式指定了如何安全加密长度超过块大小的消息。 
例如，AES 是密码，而 CTR、CBC 和 GCM 都是模式。 
使用不合适的模式或不正确地使用模式会完全破坏基础加密算法提供的安全性。 

{{GlossarySidebar}} 

{{GlossarySidebar}} 
术语 block 在不同的上下文中有多种含义。 
这些含义可能是 
{{GlossaryDisambiguation}} 

{{GlossarySidebar}} 
在 CSS 中，参与块级布局的内容被称为块级内容（block-level content）。 
在块级布局中，从包含块的顶部开始，盒子总是一个接着一个地垂直放置。 
每个盒子的左外边缘触及包含块的左边缘。 
块级元素总是开始在新的行/列上。 
在水平书写模式中，像英语或者阿拉伯语，它占据父元素（容器）的整个水平空间和等于其内容高度的垂直空间，从而创建一个“区块”。 
备注： 如果包含块的 writing-mode 被设置为默认值之外的值，上述的块布局行为将发生改变。 
备注： HTML（超文本标记语言）元素历来被归类为“块级”元素或者“行级”元素。 
作为一种表现特性，现在这将由 CSS 来提供。 
示例 
在这个示例中，两个段落（{{HTMLElement(“p”)}}）元素被放置在 {{HTMLElement(“div”)}} 中。 
<div> 
<p>这是第一段。 
这些段落的背景颜色已着色，以将其与其父元素区分开。 
</p> 
<p>这是第二段。 </p> 
</div> 
段落（{{HTMLElement(“p”)}}）元素默认是块级的。 
这是它们显示在块布局中的原因： 
css hidden p { background-color: #8abb55; } 
{{EmbedLiveSample(“示例”)}} 
参见 
行级内容 
块格式化上下文 
{{cssxref(“display”)}} 
writing-mode 

{{GlossarySidebar}} 
在 {{glossary(“JavaScript”)}}中，函数块是指被大括号 (“{}”) 包裹住的相关联的{{glossary(“statement”,“statements”)}}的集合。 
例如，你可以在 {{jsxref(“Statements/if…else”,“if (condition)”)}}后声明一段函数块形式的代码，表明当条件判断为真时，解释程序应该运行上述函数块里的代码，或者当条件判断为假时跳过执行上述函数块里的代码。 了解更多 
了解关于 
JavaScript 函数块声明 

{{GlossarySidebar}} 
举个例子，JavaScript 中的 if 语句 需要一些判断条件来决定接下来的代码会否被执行，而这些条件，本质上会被解释成一个布尔值。 
又如 JavaScript 中的 for 循环，如果没有一个能够解释成布尔值的判断条件，循环将无法知道自己什么时候该结束。 
JavaScript if 语句 
if(boolean conditional) { 
//代码 
} 
if(true) { 
console.log("布尔值判断条件被解释为 真"); 
} else { 
console.log("布尔值判断条件被解释为 假"); 
} 
JavaScript for 循环 
for(control variable; boolean conditional; counter) { 
//代码 
} 
console.log("只有当布尔值判断条件为 真 的时候才，这段文字才会被打印"); } 
了解更多 通用知识 
维基百科上的布尔值 Boolean 
技术参考文档 
标准全局对象：{{jsxref(“Boolean”)}} 
JavaScript 数据类型和数据结构 

{{GlossarySidebar}} 
Brotli 是一种通用的无损压缩算法。 
它结合使用 LZ77 算法的一个现代变体、霍夫曼编码编码和二阶上下文建模来压缩数据，提供与目前可用的最佳通用压缩算法相当的压缩率。 
Brotli 提供比 {{glossary(“GZip_compression”, “gzip”)}} 更好（小）的压缩率，并具有与 deflate 相当的压缩速度。 但 brotli 压缩速度比 Gzip 压缩慢，因此 gzip 可能更适合于压缩不{{glossary(“Cache”, “可缓存”)}}的内容。 
Brotli 与大多数现代浏览器兼容，但同时仍需考虑回落机制。 
参见 
brotli.org 
Brotli 的 Github 仓库 
维基百科上的 Brotli 
Brotli on Caniuse 

{{GlossarySidebar}} 
网络浏览器或浏览器是一种从 {{Glossary(“World Wide Web”,“Web”)}} 获取和显示页面的程序，并且让用户通过{{Glossary(“hyperlink”,“超链接”)}}访问更多页面。 
浏览器是最常见的一种用户代理。 
参见 
维基百科上的浏览器 
{{Glossary(“user agent”, “用户代理”)}}（术语） 
{{HTTPHeader(“User-agent”)}}（HTTP 标头） 
Mozilla Firefox 
Google Chrome 
Microsoft Edge 
Opera Browser 

{{GlossarySidebar}} 
浏览上下文（browsing context）是浏览器（browser）展示{{domxref(“Document”,“文档”)}}的环境。 
在现代浏览器中，通常是一个标签页（tab），也可能是一个窗体（window）或只是页面的一部分，如 frame 或 iframe。 
每个浏览上下文都有一个活动文档的源（origin）和一个记录所有展示文档的有序历史（history）。 
浏览上下文之间的通讯被严格限制，只有两个同源的浏览上下文，才能打开和使用通讯接口（{{domxref(“BroadcastChannel”)}}）。 
参见 
参见 {{glossary(“origin”)}} 

{{GlossarySidebar}} 
缓冲区是物理内存中的一个存储区域，当数据进行转移时用来临时存放数据。 
参见 
维基百科上的缓冲器词条 

{{GlossarySidebar}} 
可缓存的响应是可以缓存的 HTTP 响应，它被存储起来以便后续的检索和使用，省去了对服务器的新的请求。 
并非所有的 HTTP 响应都可以被缓存，以下是 HTTP 响应被缓存的约束条件： 
请求中使用的方法本身就是可缓存的，即 {{HTTPMethod(“GET”)}} 或 {{HTTPMethod(“HEAD”)}} 方法。 
如果指示了有效期并且设置了 {{HTTPHeader(“Content-Location”)}} 标头，{{HTTPMethod(“POST”)}} 或 {{HTTPMethod(“PATCH”)}} 请求的响应也可以被缓存，但是这很少被实现。 
例如，Firefox 就不支持它（Firefox bug 109553）。 
其他方法，如 {{HTTPMethod(“PUT”)}} 或 {{HTTPMethod(“DELETE”)}} 是不可缓存的，其结果也不能被缓存。 
响应的状态码对应用程序的缓存可知，且被认为是可缓存的。 
以下状态代码是可缓存的：{{HTTPStatus(“200”)}}、{{HTTPStatus(“203”)}}、{{HTTPStatus(“204”)}}、{{HTTPStatus(“206”)}}、{{HTTPStatus(“300”)}}、{{HTTPStatus(“301”)}}、{{HTTPStatus(“404”)}}、{{HTTPStatus(“405”)}}、{{HTTPStatus(“410”)}}、{{HTTPStatus(“414”)}} 和 {{HTTPStatus(“501”)}}。 
响应中有一些特定的标头，如可以防止缓存的 {{HTTPHeader(“Cache-Control”)}}。 
请注意，对特定 URI 的一些不可缓存的请求/响应可能会使同一 URI 上先前缓存的响应失效。 
例如，对 pageX.html 的 {{HTTPMethod(“PUT”)}} 将使所有对同一 URI 的 {{HTTPMethod(“GET”)}} 或 {{HTTPMethod(“HEAD”)}} 的缓存请求失效。 
当请求的方法和响应的状态码都是可缓存的，对请求的响应就可以被缓存： 
GET /pageX.html HTTP/1.1 
(…) 
200 OK 
(…) 
{{HTTPMethod(“PUT”)}} 请求不能被缓存。 
此外，通过 {{HTTPMethod(“HEAD”)}} 或 {{HTTPMethod(“GET”)}} 对同一 URI 的请求，其缓存数据也会失效： 
PUT /pageX.html HTTP/1.1 
(…) 
200 OK 
(…) 
响应中的特定 {{HTTPHeader(“Cache-Control”)}} 标头可以阻止缓存： 
GET /pageX.html HTTP/1.1 
(…) 
200 OK 
Cache-Control: no-cache 
(…) 
参见 
HTTP 规范中提供了有关方法和缓存的详细说明。 
常见可缓存方法的描述：{{HTTPMethod(“GET”)}}、{{HTTPMethod(“HEAD”)}} 
常见不可缓存方法的描述：{{HTTPMethod(“PUT”)}}、{{HTTPMethod(“DELETE”)}}，最常见的是 {{HTTPMethod(“POST”)}} 

{{GlossarySidebar}} 
cache (web cache 或者 HTTP cache) 是临时存储 HTTP 响应的组件，只要它符合一定条件，就可以用于后续的 HTTP 请求。 深入了解 
基础知识 
维基百科上的Web cache 

{{GlossarySidebar}} 
CalDAV（{{Glossary(“WebDAV”)}} 的日历扩展 (Calendaring extensions to WebDAV)）是一种由 {{Glossary(“IETF”)}} 标准化的{{glossary(“protocol”, “协议”)}}，用于远程访问{{glossary(“server”, “服务器”)}}上的日历数据。 
参见 
维基百科上的 CalDAV 
RFC 4791: Calendaring extensions to WebDAV (CalDAV) 
RFC 6638: Scheduling Extensions to CalDAV 

{{GlossarySidebar}} 
被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数，称为回调函数。 
例如： 
function greeting(name) { 
alert("Hello " + name); 
} function processUserInput(callback) { 
callback(name); 
} 
processUserInput(greeting); 
以上示例为{{glossary(“synchronous”,“同步”)}}回调，它是立即执行的。 
然而需要注意的是，回调函数经常被用于在一个{{glossary(“asynchronous”,“异步”)}}操作完成后执行代码，它们被称为异步回调。 
一个常见的例子是在 promise 末尾添加的 .then 内执行回调函数（在 promise 被兑现或拒绝时执行）。 
这个结构常用于许多现代的 web API，例如 fetch()。 
参见 
维基百科上的回调函数 

{{GlossarySidebar}} 
调用栈是解释器（比如浏览器中的 JavaScript 解释器）追踪函数执行流的一种机制。 当执行环境中调用了多个{{glossary(“function”,“函数”)}}时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。 
每调用一个函数，解释器就会把该函数添加进调用栈并开始执行。 
正在调用栈中执行的函数还调用了其他函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。 
当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。 
当分配的调用栈空间被占满时，会引发“堆栈溢出”错误。 
function greeting() { 
// [1] Some codes here 
sayHi(); 
// [2] Some codes here 
} 
function sayHi() { 
return "Hi!" 
; 
} 
// 调用 `greeting` 函数 
greeting(); 
// [3] Some codes here 
忽略前面所有函数，直到 greeting() 函数被调用。 
把 greeting() 添加进调用栈列表。 
执行 greeting() 函数体中的所有代码。 
调用栈列表： - greeting 
代码执行到 sayHi() 时，该函数被调用。 
把 sayHi() 添加进调用栈列表。 
执行 sayHi() 函数体中的代码，直到全部执行完毕。 
调用栈列表： - sayHi - greeting 
返回来继续执行 greeting() 函数体中 sayHi() 后面的代码。 
删除调用栈列表中的 sayHi() 函数。 
当 greeting() 函数体中的代码全部执行完毕，返回到调用 greeting() 的代码行，继续执行剩下的 JS 代码。 
调用栈列表： - greeting 
删除调用栈列表中的 greeting() 函数。 
一开始，我们得到一个空空如也的调用栈。 
随后，每当有函数被调用都会自动地添加进调用栈，执行完函数体中的代码后，调用栈又会自动地移除这个函数。 
最后，我们又得到了一个空空如也的调用栈。 
了解更多 
基础知识 
Wikipedia 上的 调用栈 
MDN Web 文档中的术语 
{{Glossary(“Call stack”)}} 
{{Glossary(“Function”)}} 

{{GlossarySidebar}} 
{{Glossary(“HTML”)}} 的 {{HTMLElement(“canvas”)}} 元素提供了一个空白绘图区域，可以使用 {{Glossary(“API”,“APIs”)}} （比如 Canvas 2D 或 {{Glossary(“WebGL”)}}）来绘制图形。 更多信息 
常规信息 
在维基百科上查看 <canvas> 的解释 
查看 MDN 上的 canvas 教程 
技术信息 MDN 上关于 HTML5 {{HTMLElement(“canvas”)}} 元素的信息 
MDN 上关于 Canvas 的常规信息 
画布 2D 绘图 API：{{domxref(“CanvasRenderingContext2D”)}} 
Canvas 2D API 规格 

{{GlossarySidebar}} 
卡片分类法是一种简单的技巧，{{glossary(“Information architecture”)}} 通常是邀请参与网站开发的设计师（或是开发其他类型产品的人），让他们写下他们认为这个产品应当包含的内容、服务和功能，然后将这些功能分组。 
一个很好的例子是考虑网站上每个页面应当显示什么样的内容。 
这个名字源于这个分类是通过把要分类的项目写在卡片上，再通过排列卡片完成的。 了解更多 
常识 
Card sorting on Wikipedia 

{{GlossarySidebar}} 
CDN (内容分发网络) 指的是一组分布在各个地区的服务器。 
这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 
CDNs 提供快速服务，较少受高流量影响。 
CDNs 被广泛用于传输 stylesheets 和 JavaScript 等静态资源，像 Bootstrap，Jquery 等。 
对这些库文件使用 CDN 技术，有以下几点好处： 
通过 CDN 向用户分发传输相关库的静态资源文件，可以降低我们自身服务器的请求压力。 
大多数 CDN 在全球都有服务器，所以 CDNs 上的服务器在地理位置上可能比你自己的服务器更接近你的用户。 
地理距离会按比例影响延迟。 
CDNs 已经配置了恰当的缓存设置。 
使用 CDN 节省了在你的服务器中对静态资源文件的配置。 

{{GlossarySidebar}} 
已认证标识意味着一个程序、一项内容或一次数据传输已经成功经过了相关领域专家的认证，因此该项目被认为是完整的、安全的、可信的。 
关于{{glossary(“密码学”)}}中证书的细节，请参考{{glossary(“数字认证证书”)}}。 
参见 
维基百科中的证书 

{{GlossarySidebar}} 
在安全协议中，质询（challenge）是服务器将某些数据发送到客户端，以便每次生成不同的响应。 
质询—响应认证协议是防御重放攻击的一种方法。 在重放攻击中，攻击者侦听先前的消息，并在以后的时间重新发送它们，以获取与原始消息相同的凭据。 
HTTP 认证协议是基于质询—响应认证协议的，尽管“Basic”协议未使用实际的质询（realm 始终相同）。 
参见 
维基百科上的质询—响应认证词条。 

{{GlossarySidebar}} 
一套编码系统定义字节与文本间的映射。 
一连串字节文本能让不同文本解释得以进行。 
我们指明一套特定编码系统时（如 UTF-8），也就指明了字节得以解释的方式。 
例如，我们通常在 HTML 里声明 UTF-8 字符编码，使用如下： 
<meta charset="utf-8" /> 
这就确保你在 HTML 文档中可以使用几乎任何一种人类语言中的字符，并且会稳定显示。 了解更多 
常识 
Character encoding on W3C 
Character encoding on Wikipedia 

{{GlossarySidebar}} 
一个字符（character）要么是一个可打印符号（字母、数字、标点符号)，或者是不可打印的“控制”符号（例如，回车、软连字符）。{{ glossary(“UTF-8”)}} 是最常见的字符集，包含了最流行的人类语言的字符。 
参见 
维基百科上的字符（计算机科学） 
维基百科上的字符编码 
维基百科上的 ASCII 
维基百科上的 UTF-8 
维基百科上的 Unicode 

{{GlossarySidebar}} 
字符集是一种让计算机知道如何识别 {{Glossary(“Character”)}} 的编码系统，这些字符包括字母、数字、标点符号和空白字符。 

{{GlossarySidebar}} 
在浏览器中，chrome 指除了网页本身以外任何可视的部分（例如：{{glossary(“UI”)}}、工具栏、菜单栏、标签）。 
不要将这个概念与 {{glossary(“Google Chrome”)}} 浏览器混淆。 
了解更多 
浏览器和 GUI Chrome 

{{GlossarySidebar}} 
CIA（机密性 Confidentiality、完整性 Integrity、可用性 Availability，也称作 CIA 三要素或 AIC 三要素）是一个指导组织的信息安全政策的模型。 
参见 
维基百科上的 CIA 部分 

{{GlossarySidebar}} 
在密码学（{{glossary(“cryptography”)}}）领域，密码是将{{glossary(“Plaintext”,“明文”)}}{{glossary(“encryption”, “编码”)}}为不可读，且能够{{glossary(“decryption”, “解码”)}}回原来的明文的算法。 
在信息时代很久以前，密码就已经很常见了（例如替换密码和移位密码），但是它们之中除了一次性密码本以外，其他的均不满足密码学上的安全性。 
现代密码通常为抵抗{{glossary(“cryptanalysis”, “密码分析学家”)}}的{{glossary(“attack”, “攻击”)}}设计。 
不能保证所有攻击的方法都能被发现，但是每个算法也经历了很多已知攻击手段的检验。 
密码通常以两种方式工作，或者在连续的数据块、缓冲区中作为分块密码使用，或者在数据流（通常是音频或视频流）中作为流密码使用。 
密码以处理{{glossary(“key”, “密钥”)}}的方式不同可以分为两类： 
对称密钥加密算法使用同样的密钥进行消息的加密和解密。 
如果消息有保密性需求，那么密钥也应该进行安全的传送。 
非对称密钥加密算法使用不同的密钥进行消息的加密和解密。 
参见 
维基百科上的密码词条 
加密与解密 
MDN 术语表 
{{Glossary(“Block cipher mode of operation”)}} 
{{Glossary(“Cipher”,“密码”)}} 
{{Glossary(“Ciphertext”,“密文”)}} 
{{Glossary(“Cipher suite”, “密码套件”)}} 
{{Glossary(“Cryptanalysis”, “密码分析”)}} 
{{Glossary(“Cryptography”, “密码学”)}} 
{{Glossary(“Decryption”, “解密”)}} 
{{Glossary(“Encryption”, “加密”)}} 
{{Glossary(“Key”,“密钥”)}} 
{{Glossary(“Plaintext”,“明文”)}} 
{{Glossary(“Public-key cryptography”, “非对称密钥算法”)}} 
{{Glossary(“Symmetric-key cryptography”, “对称密钥算法”)}} 

{{GlossarySidebar}} 
密码套件是密钥交换算法、认证算法、大容量数据加密{{Glossary(“cipher”,“加密算法”)}}和消息认证码算法的组合。 
在 {{Glossary(“TLS”)}} 的{{Glossary(“cryptosystem”,“密码体制”)}}中，客户端与服务端在安全通信之前，需要协商出密码套件，一个典型的密码套件类似于 ECDHE_RSA_WITH_AES_128_GCM_SHA256 或 ECDHE-RSA-AES128-GCM-SHA256，代表着： 
密钥交换算法使用 ECDHE（椭圆曲线 Diffie-Hellman 密钥交换算法） 
认证算法使用 RSA 
加密算法使用 AES-128，使用 Galois/Counter Mode (GCM) 作为分组加密的模式 
基于散列的消息认证码算法使用 SHA-256 
参见 
Mozilla 推荐的 TLS 密码套件 

{{GlossarySidebar}} 
在{{glossary(“cryptography”,“密码学”)}}中，密文是被打乱的信息，在由正确的{{glossary(“cipher”,“密码”)}}和正确的密文（通常是{{glossary(“key”, “密钥”)}}）{{glossary(“decryption”,“解密”)}}生成原始的{{glossary(“Plaintext”,“明文”)}}之前处于不可读状态。 
密文的安全性及其包含信息的保密性依赖于加密算法和密钥的安全性。 
参见 
维基百科上的密文介绍 

{{GlossarySidebar}} 
在面向对象编程中（{{glossary(“OOP”,“object-oriented programming”)}}）, 一个 类 定义了一个对象（{{glossary(“object”,“object’s”)}}）的特征。 
类是定义对象属性（{{glossary(“property”,“properties”)}}）和方法（{{glossary(“method”,“methods”)}}）的模板，是用来绘制具体对象实例的“蓝图”. 
了解更多 
基本知识 

{{GlossarySidebar}} 
CMS（内容管理系统）是一个允许用户发布、组织、修改、删除多种类型的内容的软件。 CMS 不仅支持文本，还可以嵌入图片、视频、音频和互动的代码。 了解更多 
基础知识 
在维基百科上的 CMS（内容管理系统） 

{{GlossarySidebar}} 
编解码器（从“coder-decoder”派生的混合词）是对数据流进行编码或解码的程序、算法或设备。 
给定的编解码器知道如何处理特定的编码或压缩技术。 
Learn more 
General knowledge 
Codec on Wikipedia 
Technical reference 
Media formats supported by the HTML audio and video elements 

{{GlossarySidebar}} 
码位是表示文本的系统（例如 Unicode）中用于表示抽象字符的数值。 
在 Unicode 中，码位以“U+1234”的形式表示，其中的“1234”是分配的数值。 
例如，字符“A”被分配的码位是 U+0041。 
字符编码形式（例如 UTF-8 和 UTF-16）决定了如何将 Unicode 码位编码成一个字节序列。 
不同的编码形式可以将相同的码位编码成不同的字节序列：例如，西里尔字符“Ф”，它的码位是 U+0424，在 UTF-8 中的编码为 0xd0a4，在 UTF-16 中的编码为 0x0424。 
参见 
Unicode 标准：码位和字符 

{{GlossarySidebar}} 
随着应用程序日趋复杂，或仅是对其进行简单的维护，CSS 和 JavaScripts 文件以及 bundles 的大小都会随之增加，尤其是所包含的第三方库的数量和大小的增长。 
当前页面所需的代码能够立即加载，而另外的脚本可以在与页面或应用交互后懒加载（lazy loaded），页面性能因此提升。 
虽然代码的总量仍然相同（甚至可能大了几个字节），但是初次加载所需的代码数量减少了。 
代码分割是由 Webpack 和 Browserify 等打包工具所支持的一项功能，这些打包工具能够创建在运行时动态加载的多个 bundles。 
另请参见 
Bundling 
Lazy loading 
HTTP/2 
Tree shaking 

{{GlossarySidebar}} 
码元是字符编码系统（例如 UTF-8 或 UTF-16）使用的基本组成部分。 
字符编码系统将一个 Unicode {{Glossary(“code point”, “码位”)}}编码为一个或者多个码元。 
在 UTF-16（JavaScript 字符串使用的编码系统）中，码元是 16 位值。 
这意味着索引到字符串或者获取字符串长度等操作将在这些 16 位单元上进行。 
这些单元不总是一对一地映射到我们可能认为的字符上。 
例如，带有附加符号（例如重音符号）的字符有时会使用两个 Unicode 码位表示： 
const myString = "\u006E\u0303"; 
console.log(myString); // ñ 
console.log(myString.length); // 2 
此外，由于并非 Unicode 定义的所有码位都适合 16 位，因此很多 Unicode 码位都编码为一对 UTF-16 码元，称为代理对： 
const face = "🥵"; _ 
_tag__console.log(face.length); // 2 
JavaScript {{jsxref(“String”)}} 对象的 {{jsxref(“String/codePointAt”, “codePointAt()”)}} 方法可以让你从它的编码形式检索到 Unicode 码位： 

{{GlossarySidebar}} 
编译是将相同的程序从一种计算机程序语言转换到另一种语言计算机语言的过程。 
编译器是运行上述任务的软件。 
通常，编译器转换一个人类理解的高级语言例如 c 或者 java 到机器语言，例如 cpu 理解的汇编语言。 
一些编译器转化同级别语言的被称为转换器或者交叉编译器，例如从 TypeScript 到 JavaScript 的编译。 
绝大多数编译器以预先编译（AOT）或实时编译（JIT）形式工作。 
作为一个开发者，你通常使用命令行或者集成开发环境（IDE）调用预先编译（AOT）的编译器。 最出名的就是 gcc 编译器了。 
实时编译器通常是用来提高性能的，令你没有感知的。 
例如在浏览器中，Firefox 的 SpiderMonkey 的 JavaScript 引擎又一个内置的实时编译器会在你浏览时将网页中的 JavaScript 代码编译为机器码，从而提供运行效率。 
基础知识 
The GNU Compiler Collection (GCC) 
Base CS Introduction on Compilers 
A big list of learning material on StackOverflow 

{{GlossarySidebar}} 
编译时间是指程序从被加载到程序被解析完成所用的时间。 学习更多 
基础知识 
Compile time on Wikipedia 

{{GlossarySidebar}} 
电脑编程是将一系列指令整合起来的过程。 
这些指令以电脑能够理解的语言告诉电脑或者软件该做些什么。 
这些指令可由不同的语言呈现，例如 C++、Java、JavaScript、HTML、Python、Ruby 和 Rust。 
使用一门合适的语言，你可以编程/创建任意一种软件。 
例如，帮助科学家进行复杂运算的程序、存储大量数据的数据库、可以供人下载音乐的网站或可以供人制作电影的动画软件。 
学习更多 
维基百科：电脑编程 
维基百科：一些常见的编程语言列表 

{{GlossarySidebar}} 
构造函数属于被实例化的特定类{{glossary(“Object”,“对象”)}} 。 
构造函数初始化这个对象，并提供可以访问其私有信息的方法。 
构造函数的概念可以应用于大多数{{glossary(“OOP”,“面向对象”)}}的编程语言。 
本质上，{{glossary(“JavaScript”)}} 中的构造函数通常在{{glossary(“class”,“类”)}}的实例中声明。 
语法 
// 这是一个通用的默认构造函数类 Default 
function Default() { 
} // 这是一个带参数声明的重载构造函数类 Overloaded 
function Overloaded(arg1, arg2, ...,argN){ } 
要调用 JavaScript 中类的构造函数，请使用 new 操作符将新的{{glossary(“object reference”,“对象引用”)}}分配给一个{{glossary(“variable”,“变量”)}}。 
function Default() {} 
// 分配给局部变量 defaultReference 的一个新的 Default 对象引用 
var defaultReference = new Default(); 
基本常识 
维基百科上的 构造函数 
技术参考 MDN 上的 JavaScript 面向对象编程中的构造函数 
MDN 上的 JavaScript 的 New 操作符 

{{GlossarySidebar}} 
CSS 可以被使用在多种不同的上下文环境（包括打印页面和一些 CSS 容器），尤其是被用来设置根据所处的上下文的不同而具有不同的布局行为。 
因此，连续媒体（Continuous Media）用来定义那些内容没有间断的上下文环境，即其流动性是连续的。 
屏幕上显示的网页内容就是连续媒体，语音内容也是如此。 

{{GlossarySidebar}} 
控制流 是计算机执行一个程序中语句的顺序。 
程序会从第一行代码开始执行直至最后一行，除非遇到（实际中是非常普遍地）改变控制流的代码结构，比如条件语句和循环。 
比如，下面的程序被用来校验用户在网页上输入的数据。 
数据经过校验后会被提交，但当用户没有输入任何数据时 (field==empty)，这个程序会提醒用户去填入数据。 
为了做到这一点，这个程序使用了 {{Glossary(“Conditional”, “条件”)}} 结构 if...else，这样就可以根据数据是否被填充而执行不同的代码。 
if (field == empty) { 
promptUser(); 
} else { 
submitForm(); 
} 
在 {{glossary(“JavaScript”)}} 或者 {{glossary(“PHP”)}} 中存在许多控制结构，比如条件语句、循环和函数。 
还有部分语句可能被设定为当 {{Glossary(“Event”, “事件”)}} 发生的时候才执行。 
例如，上面的代码可能被放入一个函数，而这个函数只有在用户点击了表单的提交按钮时才执行。 
而这个函数也可以再包含一个循环，来达到按照顺序遍历表单中的所有数据的目的。 
往回看 if...else 代码块，promptUser 和 submitForm 也可以是对其他函数的调用。 
如你所见，控制结构依靠几行代码就能完成复杂的处理过程。 
控制流的存在意味着在读代码时，你不能只从第一行读到最后一行，你还要注意代码的结构以及它对语句执行顺序的影响。 
Learn more 
Technical reference 
JavaScript Reference - Control flow on MDN 
Statements (Control flow) on MDN 

{{GlossarySidebar}} 
Cookie 就是访问者在访问网站后留下的一个信息片段。 
Cookie 用于个性化用户的体验。 
可能包含用户在访问网站时的参数或输入。 
用户可以自定义浏览器来接受，拒绝或删除 Cookie。 
Cookie 可以在服务器级别设置和修改，使用 Set-Cookie HTTP header, 或者在 JavaScript 中用 document.cookie. 
了解更多 
HTTP cookie on Wikipedia 

{{GlossarySidebar}} 
Copyleft 是一个术语，通常指许可证，用于表示此类许可要求所述作品的再分发需遵循与原始许可相同的许可。 
Copyleft 许可证的示例是 GNU {{Glossary(“GPL”)}}（用于软件）和 Creative Commons SA（Share Alike）许可证（用于艺术品）。 
参见 
维基百科上的 Copyleft 词条 

{{GlossarySidebar}} 
CORS（Cross-Origin Resource Sharing，跨源资源共享）是一个系统，它由一系列传输的 {{Glossary(“Header”, “HTTP 标头”)}}组成，这些 HTTP 标头决定浏览器是否阻止前端 JavaScript 代码获取跨源请求的响应。 
同源安全策略默认阻止“跨源”获取资源。 
但是 CORS 给了 web 服务器这样的权限，即服务器可以选择，允许跨源请求访问到它们的资源。 
CORS 标头 
{{HTTPHeader(“Access-Control-Allow-Origin”)}} 
: 指示响应的资源是否可以被给定的来源共享。 
{{HTTPHeader(“Access-Control-Allow-Credentials”)}} 
: 指示当请求的凭证标记为 true 时，是否可以公开对该请求响应。 
{{HTTPHeader(“Access-Control-Allow-Headers”)}} 
: 用在对预检请求的响应中，指示实际的请求中可以使用哪些 HTTP 标头。 
{{HTTPHeader(“Access-Control-Allow-Methods”)}} 
: 指定对预检请求的响应中，哪些 HTTP 方法允许访问请求的资源。 
{{HTTPHeader(“Access-Control-Expose-Headers”)}} 
: 通过列出标头的名称，指示哪些标头可以作为响应的一部分公开。 
{{HTTPHeader(“Access-Control-Max-Age”)}} 
: 指示预检请求的结果能被缓存多久。 
{{HTTPHeader(“Access-Control-Request-Headers”)}} 
: 用于发起一个预检请求，告知服务器正式请求会使用哪些 HTTP 标头。 
{{HTTPHeader(“Access-Control-Request-Method”)}} 
: 用于发起一个预检请求，告知服务器正式请求会使用哪一种 HTTP 请求方法。 
{{HTTPHeader(“Origin”)}} 
: 指示获取资源的请求是从什么源发起的。 
参见 
在 MDN 的跨源资源共享（CORS） 
维基百科上的跨源资源共享 
Fetch 规范 

{{GlossarySidebar}} 

{{GlossarySidebar}} 
回车符（CR）和换行符（LF）是文本文件用于标记换行的控制字符（control characters）或字节码（bytecode）。 
CR = Carriage Return，回车符号（\r，十六进制 ascii 码为0x0D，十进制 ascii 码为 13），用于将鼠标移动到行首，并不前进至下一行。 
LF = Line Feed，换行符号（ \n, 十六进制 ascii 码为 0x0A，十进制 ascii 码为 10）。 
紧邻的 CR 和 LF（组成 CRLF，\r\n，或十六进制 0x0D0A）将鼠标移动到下一行行首。（ 
相关链接 
Newline on Wikipedia 
Carriage return on Wikipedia 

{{GlossarySidebar}} 
弹性容器 {{glossary(“flexbox”)}} 的交叉轴和主轴 {{glossary(“main axis”)}} 垂直，因此如果弹性方向是 {{cssxref(“flex-direction”)}} 行 row 或者反向行 row-reverse ，那么交叉轴就是从上至下地垂直走向的。 
The cross axis runs down the column 
如果你的主轴是列 column 或者反向列 column-reverse ，那么交叉轴就是水平走向的。 
The cross axis runs along the row. 
要在交叉轴上对齐，是通过弹性容器的 align-items 属性来控制的，或者通过弹性元素的 align-self 属性来单独决定的对齐方式。 
在多行弹性容器中，交叉轴上有多余控件的话，你还可以用 align-content 来控制行的间距。 
学习更多 
属性参考 
{{cssxref(“align-content”)}} 
{{cssxref(“align-items”)}} 
{{cssxref(“align-self”)}} 
{{cssxref(“flex-wrap”)}} 
{{cssxref(“flex-direction”)}} 
{{cssxref(“flex”)}} 
{{Glossary(“Cross Axis”)}} 
{{Glossary(“Flex”)}} 
{{Glossary(“Flex Container”)}} 
{{Glossary(“Flex Item”)}} 
{{Glossary(“Grid”)}} 
{{cssxref(“align-content”)}} 
{{cssxref(“align-items”)}} 
{{cssxref(“align-self”)}} 
{{cssxref(“flex”)}} 
{{cssxref(“flex-basis”)}} 
{{cssxref(“flex-direction”)}} 
{{cssxref(“flex-flow”)}} 
{{cssxref(“flex-grow”)}} 
{{cssxref(“flex-shrink”)}} 
{{cssxref(“flex-wrap”)}} 
{{cssxref(“order”)}} 

{{GlossarySidebar}} 
跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。 
根据开放式 Web 应用安全项目（OWASP），XSS 在 2017 年被认为 7 种最常见的 Web 应用程序漏洞之一。 
如果 Web 应用程序没有部署足够的安全验证，那么，这些攻击很容易成功。 
在以下 2 种情况下，容易发生 XSS 攻击： 数据从一个不可靠的链接进入到一个 Web 应用程序。 
恶意内容一般包括 {{glossary(“JavaScript”)}}，但是，有时候也会包括 HTML，FLASH 或是其他浏览器可执行的代码。 XSS 攻击的形式千差万别，但他们通常都会：将 cookies 或其他隐私信息发送给攻击者，将受害者重定向到由攻击者控制的网页，或是经由恶意网站在受害者的机器上进行其他恶意操作。 
基本知识 
Cross-site scripting on Wikipedia 
Cross-site scripting on OWASP 
Another article about Cross-site scripting 
XSS Attack – Exploit & Protection 

{{GlossarySidebar}} 
CRUD (创建：Create，读取：Read，更新：Update，删除：Delete) 是对于存储的信息可以进行操作的同义词。 
是一个对四种操作持久化信息的基本操作的助记符。 
CRUD 通常是指适用于存于数据库或数据存储器上的信息的操作，不过也可以应用在高层级的应用操作，例如通过在设置状态字段并标记删除的而并非移除数据的伪删除。 了解更多 
常识 
在 Wikipedia 上的相关信息：CRUD 

{{GlossarySidebar}} 
加密散列函数有时也称为摘要函数，其是一种{{glossary(“cryptography”, “密码学”)}}原语，将任意大小的信息转为固定大小的消息，称为{{glossary(“digest”, “摘要”)}}。 
加密散列函数通常用于授权、{{Glossary(“digital signature”, “数字签名”)}}以及{{Glossary(“HMAC”, “密钥散列消息认证码”)}}。 
散列函数必须有以下特征才能用于密码学： 
快速计算（因为它们需要频繁地生成） 
不可逆（每个摘要可能来自拥有庞大数据的消息，并且仅有暴力破解才能生成产生给定摘要的消息） 
防篡改（对消息的任何改变都会产生不同的摘要） 
抗碰撞（应该不可能找到两个不同的消息产生相同的摘要） 
像 MD5 和 SHA-1 这样的加密散列函数被认为是不安全的，因为已经发现了可以显著降低它们抗碰撞性的攻击。 
参见 
维基百科上的加密散列函数 
MDN Web 文档术语 
{{Glossary(“Symmetric-key cryptography”, “对称密钥加密”)}} 

{{GlossarySidebar}} 
密码学是研究如何安全地编码和传递消息的学科。 
密码学设计和研究用于在不安全环境中编码和解码消息，以及它们的应用。 
除了数据机密性，密码学还涉及身份识别、身份验证、不可否认以及数据完整性。 
因此，它还研究在上下文中密码方法的使用，这称为密码系统。 
参见 
维基百科上的密码学 
MDN Web 文档术语 
{{Glossary(“Block cipher mode of operation”, “分组密码工作模式”)}} 
{{Glossary(“Cipher”, “密码”)}} 
{{Glossary(“Ciphertext”, “密文”)}} 
{{Glossary(“Cipher suite”, “密码套件”)}} 
{{Glossary(“Cryptanalysis”, “密码分析”)}} 
{{Glossary(“Decryption”, “解密”)}} 
{{Glossary(“Encryption”, “加密”)}} 
{{Glossary(“Key”, “密钥”)}} 
{{Glossary(“Plaintext”, “明文”)}} 
{{Glossary(“Public-key cryptography”, “非对称加密”)}} 
{{Glossary(“Symmetric-key cryptography”, “对称密钥加密”)}} 

{{GlossarySidebar}} 
内容安全策略（CSP）用于检测和减轻用于 Web 站点的特定类型的攻击，例如 {{Glossary(“XSS”)}} 和数据注入等。 
该安全策略的实现基于一个称作 Content-Security-Policy 的 {{Glossary(“HTTP”)}} 首部。 更多内容 
常识 
Content Security Policy on Wikipedia 
Content Security Policy documentation on MDN 

{{GlossarySidebar}} 
跨站请求伪造（CSRF）是一种冒充受信任用户，向服务器发送非预期请求的攻击方式。 
例如，这些非预期请求可能是通过在跳转链接后的 {{glossary(“URL”)}} 中加入恶意参数来完成： 
<img src="https://www.example.com/index.php? 
action=delete&id=123" /> 
对于在 https://www.example.com 有权限的用户，这个 <img> 标签会在他们根本注意不到的情况下对 https://www.example.com 执行这个操作，即使这个标签根本不在 https://www.example.com 内亦可。 
有很多预防 CSRF 的方法，比如实现 {{glossary(“REST”, “RESTful API”)}}，增加 secure token 等等。 
参见 
跨站请求伪造 on Wikipedia 
防御方法 

{{GlossarySidebar}} 
一个 CSS 解释器定义一条 {{cssxref(“at-rule”,“@ 规则”)}}的属性。 
一条 @ 规则可以有一条或多条解释器。 
每一条解释器拥有： 
一个名称 
一个值，用于定义其名称的属性 
一个可选的 “! 
important” 标识，默认不带有。 

{{GlossarySidebar}} 
CSS （Cascading Style Sheets，层叠样式表）是用来控制网页在浏览器中的显示外观的声明式语言。 
浏览器会根据 CSS 的样式定义将其选定的元素显示为恰当的形式。 
一条 CSS 的样式定义包括属性和属性值，它们共同决定网页的外观。 
CSS 与 {{Glossary(“HTML”)}} 和 {{Glossary(“JavaScript”)}} 并称 Web 三大核心技术。 
一般用它来定义 {{Glossary(“Element”,“HTML 元素”)}} 的样式，但它也能用于其他标记语言，如 {{Glossary(“SVG”)}} 和 {{Glossary(“XML”)}}。 
一条 CSS 规则包含一个 {{Glossary(“CSS selector”, “选择符”)}} 和一组 {{Glossary(“CSS Property”,“属性”)}} 定义。 
下面这个例子用来将页面中的所有 <p> 标签显示为黑色背景和黄色文本： 
/* p 选择符用来选择页面中的所有 <p> 标签 */ 
p { 
/* color 属性用来定义文本颜色，这里为黄色 */ 
color: yellow; 
/* background-color 属性用来定义元素的背景色，这里为黑色 */ 
background-color: black; 
} 
CSS 中的“C”表示“层叠的”，意为多个选择符之间具有特定的优先级。 
这一点非常重要，因为复杂网站可能会有非常多的 CSS 规则，因此必须规定好这些规则的优先级，以免乱套。 
参见 
CSS 教程 
维基百科 CSS 词条 
MDN CSS 文档 
CSS 工作组的当前工作 

{{GlossarySidebar}} 
CSSOM 与 {{glossary(‘DOM’, ‘文档对象模型 (DOM)’)}} 非常相似。 
CSS 对象模型也是一组 API，允许从 JavaScript 操纵 CSS。 它非常类似于 DOM，但应用于 CSS 而不是 HTML。 它允许用户动态读取和修改 CSS 样式。 
查看更多 
填充页面：浏览器如何工作 

{{GlossarySidebar}} 
CSS 像素——在 {{Glossary(“CSS”)}} 中以 px 为后缀——是一个长度单位，大致相当于一个肉眼可以轻松看到的小点的长宽，否则就是尽可能小的长度。 
技术参考 
CSS Length Explained on the MDN Hacks Blog 

{{GlossarySidebar}} 
CSS 预处理器是一个能让你通过预处理器自己独有的{{Glossary(“语法”)}}来生成{{Glossary(“CSS”)}}的程序。 
市面上有很多 CSS 预处理器可供选择，且绝大多数 CSS 预处理器会增加一些原生 CSS 不具备的特性，例如代码混合，嵌套选择器，继承选择器等。 
这些特性让 CSS 的结构更加具有可读性且易于维护。 
要使用 CSS 预处理器，你必须在 web 服务中{{Glossary(“服务器”)}}安装 CSS 编译工具。 了解更多 
通用知识 
这里是一些最流行的 CSS 预处理器： 
Sass 
LESS 
Stylus 
PostCSS 

{{GlossarySidebar}} 
CSS 选择器是 CSS 规则的一部分，用于匹配文档中的元素。 
匹配的元素将会应用规则指定的样式。 
示例 
看下面的 CSS： 
p { 
color: green; 
} 
div.warning { 
width: 100%; 
border: 2px solid yellow; 
color: white; 
background-color: darkred; 
padding: 0.8em 0.8em 0.6em; 
} 
#customized { 
font: 
16px Lucida Grande, 
Arial, 
Helvetica, 
sans-serif; 
} 
选择器例如："p"（文档中的 {{HTMLElement(“p”)}} 元素都会应用绿色字体的样式）、"div.warning"（文档中所有 class 包含 "warning" 的 {{HTMLElement(“div”)}} 元素都会有一个看起来像警告框的样式）和 "#customized"（id 为 "customized" 的元素中的文本为 16px 高，字体是 Lucida Grande 和一些用作回落的字体）。 
我们可以把上面的 CSS 应用到 HTML 中，如下： 
<p>This is happy text.</p> 
<div class="warning"> 
Be careful! 
There are wizards present, and they are quick to anger! 

{{GlossarySidebar}} 
数据库是一种用于收集已组织好的数据以便于搜索、结构化和扩充的存储系统。 
网站开发中，大多数数据库采用关系型数据库管理系统 (RDBMS) 来组织数据，通过 {{glossary(“SQL”)}}语言来编程。 
但有些数据库没有遵循上述的组织数据的机制，这类被称作 NoSQL 数据库。 
被广泛使用的服务端关系型数据库有 MySQL（或者源于它的 MariaDB）、SQL Server 和 Oracle Database 等。 
另一边，出名的 NoSQL 数据库有 MongoDB、Cassandra 和 Redis 等。 
浏览器也有他们特有的数据库系统，被称作 {{glossary(“IndexedDB”)}}。 
参见 
维基百科上的词条 Database 
{{Glossary(“IndexedDB”)}} 
{{Glossary(“SQL”)}} 

{{GlossarySidebar}} 
数据结构 是让数据更好地被使用的一种数据组织方式。 
参见 
维基百科上的 Data structure 

{{GlossarySidebar}} 
在密码学（{{glossary(“cryptography”)}}）领域，解密是指把密文（{{glossary(“ciphertext”)}}）转换成明文（{{glossary(“Plaintext”)}}）的过程。 
解密是一个密码学原语：它通过一种称作{{glossary(“cipher”)}}的编码技术，把加密信息转换成纯文本。 
正如加密一样，解密在当代密码学领域也是通过特有的算法，结合称作{{glossary(“key”)}}的密钥来工作。 
由于算法通常是公开的，若要保证加密安全，就必须确保密钥高度保密。 
The decryption primitive. 
解密是{{glossary(“encryption”,“加密”)}}的逆过程，如果密钥高度保密，在没有特定密钥的前提下从数学计算的角度来看，解密是很难做到的。 
这就取决于算法有多坚固，以及{{glossary(“cryptanalysis”,“密码分析学”)}}发展到了什么程度。 
参见 
加密与解密 

{{GlossarySidebar}} 
{{MDNSidebar}} 
对象的深拷贝是指其属性与其拷贝的源对象的属性不共享相同的引用（指向相同的底层值）的副本。 
因此，当你更改源或副本时，可以确保不会导致其他对象也发生更改；也就是说，你不会无意中对源或副本造成意料之外的更改。 
这种行为与浅拷贝的行为形成对比，在浅拷贝中，对源或副本的更改可能也会导致其他对象的更改（因为两个对象共享相同的引用）。 
在 JavaScript 中，标准的内置对象复制操作（展开语法、Array.prototype.concat()、Array.prototype.slice()、Array.from()、Object.assign() 和 Object.create()）不创建深拷贝（相反，它们创建浅拷贝）。 
如果一个 JavaScript 对象可以被序列化，则存在一种创建深拷贝的方式：使用 {{jsxref(“JSON.stringify()”)}} 将该对象转换为 JSON 字符串，然后使用 {{jsxref(“JSON.parse()”)}} 将该字符串转换回（全新的）JavaScript 对象： 
let ingredients_list = ["noodles", { list: ["eggs", "flour", "water"] }]; 
let ingredients_list_deepcopy = JSON.parse(JSON.stringify(ingredients_list)); 
// Change the value of the 'list' property in ingredients_list_deepcopy. 
ingredients_list_deepcopy[1].list = ["rice flour", "water"]; 
// The 'list' property does not change in ingredients_list. 
console.log(ingredients_list[1].list); 
// Array(3) [ "eggs", "flour", "water" ] 
然而，虽然上面代码中的对象足够简单，可以序列化，但许多 JavaScript 对象根本不能序列化——例如，函数（带有闭包）、Symbol、在 HTML DOM API 中表示 HTML 元素的对象、递归数据以及许多其他情况。 
在这种情况下，调用 JSON.stringify() 来序列化对象将会失败。 
所以没有办法对这些对象进行深拷贝。 
对于可序列化的对象，你也可以使用 structuredClone() 方法来创建深拷贝。 
structuredClone() 的优点是允许源代码中的可转移对象被转移到新的副本，而不仅仅是克隆。 
但是请注意，structuredClone() 不是 JavaScript 语言本身的特性——相反，它是浏览器和任何其他实现了 window 这样全局对象的 JavaScript 运行时的一个特性。 
调用 structuredClone() 来克隆一个不可序列化的对象会失败，与调用 JSON.stringify() 来序列化它会失败相同。 
参见 
浅拷贝 
window.structuredClone() 

{{GlossarySidebar}} 
开发者工具 (或“开发工具”，或简称“DevTools”) 让开发者能够开发、测试和{{Glossary(“调试”)}}软件。 
目前的浏览器提供集成开发者工具，可用于审查网页，还让用户审查和调试页面的{{Glossary(“HTML”)}}、{{Glossary(“CSS”)}}和{{Glossary(“JavaScript”)}},，检查网络流量，测试网页性能等等。 了解更多 
常识 
Web development tools on Wikipedia 
Firefox Developer Tools on MDN 
Firebug (former developer tool for Firefox) 
Chrome DevTools on chrome.com 
Safari Web Inspector on apple.com 
Edge Dev Tools on microsoft.com 

{{GlossarySidebar}} 
摘要是由{{glossary(“cryptographic hash function”, “散列函数”)}}从完整消息生成的更小值。 
理想情况下，摘要是可快速计算、不可逆且不可预测的，因此可用于表明是否有人篡改了给定的消息。 
摘要可用于执行多种任务： 
非加密类应用（例如：哈希表的索引、用于检测重复数据或唯一标识文件的指纹） 
验证消息完整性（被篡改的消息具有不同的散列值） 
生成伪随机数 
生成{{glossary(“key”,“密钥”)}} 
为应用选择合适的散列函数以避免冲突和可预测至关重要。 
参见 
{{glossary(“Cryptographic hash function”, “密码散列函数”)}} 
维基百科上的密码散列函数 

{{GlossarySidebar}} 
数字证书是一个将公开的{{Glossary(“Key”, “加密密钥”)}}和一个组织绑定的数据文件。 
一个数字证书包含一个组织的信息，如公共名称（例如 mozilla.org），组织单元（例如 Mozilla Corporation）以及位置（例如 Mountain View）。 
数字证书通常由{{Glossary(“certificate authority”)}}签署，以证明其真实性。 
了解更多 
Wikipedia 上的Digital certificate 

{{GlossarySidebar}} 
分布式拒绝服务（DDoS）是一种攻击，在这种攻击中，许多被破坏的系统被用来攻击一个目标，以淹没服务器资源并阻止合法用户。 
通常情况下，许多人使用机器人攻击高知名度的 Web {{glossary(“server”, “服务器”)}}，如银行或信用卡支付网关。 
DDoS 涉及计算机网络和 CPU 资源管理。 
在典型的 DDoS 攻击中，攻击者首先利用一个计算机系统的漏洞，使其成为 DDoS 主控。 
攻击主控者，也被称为僵尸主控者，用恶意软件识别和感染其他脆弱的系统。 
最终，攻击者指示被控制的机器对指定目标发起攻击。 
有两种类型的 DDoS 攻击：以网络为中心的攻击（通过占用带宽使服务过载）和应用层攻击（通过应用调用使服务或数据库过载）。 
溢出到目标的数据导致目标机器处于饱和状态，使其对合法流量的响应非常缓慢甚至无法响应（因此被称为“拒绝服务”）。 
受感染计算机的所有者通常不知道他们的计算机已经被入侵，他们也会遭受服务损失。 
在入侵者控制下的计算机被称为僵尸或机器人。 
一个由共同感染的计算机组成的网络被称为僵尸网络或僵尸军队。 
卡巴斯基实验室和赛门铁克都认为僵尸网络才是对互联网安全的最大威胁，而不是垃圾邮件、病毒或蠕虫。 
美国计算机应急准备小组（US-CERT）将拒绝服务攻击的症状定义为： 
（打开文件或访问网站的）网络性能异常缓慢 
某一网站无法使用 
无法访问任何网站 
收到的垃圾邮件数量急剧增加（这种类型的 DoS 攻击被认为是电子邮件炸弹） 
无线或有线互联网连接中断 
长期拒绝访问网络或任何互联网服务 
参见 
维基百科上的拒绝服务攻击词条 

{{GlossarySidebar}} 
DNS（Domain Name System）域名系统，是一个层次化、分散化的互联网连接资源命名系统。 
DNS 维护着一个{{glossary(“domain name”,“域名”)}}列表以及与之相关联的资源（例如 IP 地址）。 
DNS 最突出的功能是将易于记忆的域名（例如 mozilla.org）翻译成为数字化的 {{Glossary(“IP address”, “IP 地址”)}}（例如 151.106.5.172）；这一从域名到 IP 地址的映射过程被称为DNS 查询（DNS lookup）。 
与之对应，DNS 反向查询（rDNS）用来找到与 IP 地址对应的域名。 
参见 
理解域名 
维基百科上的域名系统 

{{GlossarySidebar}} 
在 {{Glossary(“HTML”)}} 中，文档类型 doctype 的声明是必要的。 
在所有文档的头部，你都将会看到”<! DOCTYPE html>” 的身影。 
这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“怪异模式 (兼容模式)”的渲染模式。“ 
<! DOCTYPE html>” 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。 
了解更多 
Document Type Declaration 维基百科的解释 
技术参考 
Document.doctype, 一个返回 doctype 的 JavaScript 方法 

{{GlossarySidebar}} 
{{Glossary(“CSP”)}} 文档指令（document directives） 出现于 {{HTTPHeader(“Content-Security-Policy”)}} 首部，支配着应用安全策略的文档的属性或者 worker 运行环境的特征。 
文档指令不将 {{CSP(“default-src”)}} 指令作为回退机制。 
以下 CSP 指令属于文档指令： 
{{CSP(“base-uri”)}} 
{{CSP(“plugin-types”)}} 
{{CSP(“sandbox”)}} 
{{CSP(“disown-opener”)}} 更多内容 
{{HTTPHeader(“Content-Security-Policy”)}} 
其他类型的指令： {{Glossary(“Fetch directive”)}} 
{{Glossary(“Navigation directive”)}} 
{{Glossary(“Reporting directive”)}} 

{{GlossarySidebar}} 
当 JavaScript 所处的全局环境为 window 或 iframe 时，这种环境被称为全局文档环境。 
全局的文档环境处于所有环境的顶层，即没有更外层的环境。 
学习更多 
技术参考 document environment 的 HTML 规范 

{{GlossarySidebar}} 
域是互联网中控制其自身资源的“代表”（authority，有时被直译为“权威”）。 
它的“域名”是 {{Glossary(“URL”)}} 层次结构的一部分，是对“代表”的称呼。 域名通常也是 URL 中最令人难忘的地方，例如品牌名称。 
一个全限定域名（FQDN）包含可以使用互联网的{{Glossary(“DNS”,“域名系统”)}}明确地按名称查询该机构的所有必要部分。 
例如，在“developer.mozilla.org”中： 
“org”被称为顶级域，它们由 IANA 注册为互联网标准。 
这里，“org”是指“组织”，它被定义在一个顶级的域名注册表中。 
“mozilla”是域名。 
如果你需要拥有一个域名，必须在注册商中注册。 在顶级域域名注册商委派下，注册商可以为你注册域名。 
“developer”是子域名，作为域名的所有者，你可以自己定义。 
许多域名所有者选择将子域“www”指向他们的{{Glossary(“World_Wide_Web”,“万维网”)}}资源，但这并不是必须的（甚至已经有些失宠了）。 
参见 
维基百科词条域名 

{{GlossarySidebar}} 
域名是在 {{Glossary(“Internet”, “互联网”)}} 的网站的地址。 
域名被用于 {{Glossary(“URL”,“URL”)}} 识别一个服务器属于哪个特定的网站。 
域名包含由句号点（”.“） 分隔的名称（标签）的分级序列并以 {{glossary(“TLD”,“扩展名”)}} 作为结尾。 
参见 
在维基百科的 域名 
了解“域名“ 

{{GlossarySidebar}} 
由于浏览器限制了每个域（domain）的活动连接数。 
为了可以同时下载超过该限制数的资源，域名分片（domain sharding）会将内容拆分到多个子域中。 
当使用多个域来处理多个资源时，浏览器能够同时下载更多资源，从而缩短了页面加载时间并改善了用户体验。 
就性能而言，域名分片的问题在于每个域都需要额外的 DNS 查找成本以及建立每个 TCP 连接的开销。 
来自 HTTP 请求的初始响应通常是 HTML 文件，其中列出了其他资源，例如 JavaScript，CSS，图像和其他需要下载的媒体文件。 
由于浏览器限制每个域的活动连接数，因此从一个域提供所有必需的资源可能会变慢，因为需要按顺序下载资源。 
使用域名分片后，所需的下载可以来自多个域，从而使浏览器可以同时下载所需的资源。 
但是，由于 DNS 查找会减慢初始加载时间，因此多个域是一种反模式。 
由于 HTTP/2 没有限制并发请求（unlimited concurrent requests），因此启用 HTTP/2 后，就没必要再使用域名分片来解决并发限制了。 
See Also 
Transport Layer Security (TLS) 
DNS 
HTTP/2 


{{GlossarySidebar}} 
DoS（拒绝服务攻击，Denial of Service）是一种网络攻击手段，它通过给{{glossary(“server”,“服务器”)}}发送大量请求来阻止对资源的合法使用。 
计算机资源有限，比如算力和内存。 
当这些资源过载时，程序可能会发生冻结或崩溃，使程序不可用。 
DoS 攻击结合多种技术来消耗资源，使合法用户无法使用服务器或网络，或者至少让服务器反应迟缓。 
分布式拒绝服务（Distributed Denial of Service，DDoS）攻击是一种使用大量服务器来耗尽一台被攻击电脑的资源的攻击方式。 
DoS 攻击类型 
DoS 攻击更多的是一种类型而非特定的某种攻击。 
下面是 DoS 攻击的不完全列表： 
带宽攻击 
服务请求洪泛 
SYN 洪泛攻击 
ICMP 洪泛攻击 
点对点攻击 
永久 DoS 攻击 
应用层洪泛攻击 
参见 
维基百科拒绝服务攻击词条 
OWASP 介绍的拒绝服务攻击 
{{Glossary(“Distributed Denial of Service”,“DDoS”)}} 

{{GlossarySidebar}} 
动态类型语言是那些像 {{glossary(“JavaScript”)}} 语言那样，其解释器在运行时根据{{glossary(“variable”, “变量”)}}当时的{{glossary(“value”,“值”)}}分配{{glossary(“type”, “类型”)}}。 
参见 
JavaScript 数据类型和数据结构 
维基百科上的类型系统词条 

{{GlossarySidebar}} 
Ecma International（正式名称是 European Computer Manufacturers Association，欧洲计算机制造商协会）是一个开发计算机硬件、通信和程序语言标准的非盈利组织。 
在网络上该组织因维护 {{Glossary(“JavaScript”)}} 语言的核心规范 the ECMA-262 specification（即 {{Glossary(“ECMAScript”)}}）而为人所知。 
了解更多 
Wikipedia 页面 Ecma International 
The Ecma International web site 

{{GlossarySidebar}} 
ECMAScript 是 {{glossary(“JavaScript”)}} 所基于的脚本语言。 Ecma 国际组织 负责将 ECMAScript 标准化。 了解更多 
常规知识 
维基百科上的 ECMAScript 
ECMAScript 

{{GlossarySidebar}} 
元素是网页的一部分，在 {{glossary(“XML”)}} 和 {{glossary(“HTML”)}} 中，一个元素可以包含一个数据项，或是一块文本，或是一张照片，亦或是什么也不包含。 
一个典型的元素包括一个具有一些{{glossary(“attribute”, “属性”)}}的开始标签，中间的文本内容和一个结束标签。 
元素和{{glossary(“tag”, “标签”)}}不是同一种概念。 
源代码中的标签用来标识元素的开始或结束，而元素是文档对象模型（{{Glossary(“DOM”)}}）中的一部分，文档对象模型会被{{glossary(“browser”, “浏览器”)}}渲染、展示为页面。 
相关信息 
开始学习 HTML 
自定义元素（Custom element） 
{{domxref(“Element”)}} 接口，在 DOM 中表示一个元素 

{{GlossarySidebar}} 
Encapsulation（封装）是指将数据与函数打包到一个组件（例如，类）中，使得外部对于该组件对象的访问如同一个“黑盒子”一样。 
如此一来，类的使用者只需知道它的接口（即类对外暴露的数据与方法），而无需关心其内部是如何实现的。 了解更多 
基础知识 
维基百科上的 封装 

{{GlossarySidebar}} 
在密码学（{{glossary(“cryptography”)}}）领域，加密是指把明文（{{glossary(“plaintext”)}}）转换成密文（{{glossary(“ciphertext”)}}）的过程。 
密文应该对非授权用户不可读。 
加密是一个密码学原语：它通过一种称作 {{glossary(“cipher”)}} 的编码技术，把纯文本信息转换为密文。 
现代密码的加密算法是通过特定的密码算法来工作的，称为{{glossary(“key”,“密钥”)}}。 
由于算法常常是公开的，若要保证加密安全，就必须确保密钥高度保密。 
How encryption works. 
如果不知道密钥，其逆过程{{glossary(“decryption”,“解密”)}}在数学上是很难做到的。 
究竟有多难做到，取决于算法的安全性，以及{{glossary(“cryptanalysis”,“密码分析学”)}}的发展程度。 

{{GlossarySidebar}} 
参见 {{jsxref(“ArrayBuffer”)}} {{jsxref(“DataView”)}} Typed Arrays Wikipedia 上的 Endianness 

{{GlossarySidebar}} 
{{glossary(“JavaScript”)}}引擎是一个可以解析并执行 JavaScript 程序的解释器 了解更多 
基本信息 
维基百科上的JavaScript engine 

{{GlossarySidebar}} 
这中的有些字段现在被称为表示头字段（RFC 7231, section 3: Representations）。 
实体报头是描述了一个 HTTP 消息有效载荷（即关于消息主体的元数据）的 HTTP 报头，见 {{glossary(“header”, “HTTP header”)}}。 

{{GlossarySidebar}} 
{{glossary(“HTML”)}} 实体是一段以连字号（&）开头、以分号（;）结尾的文本（字符串）。 
实体常常用于显示保留字符（这些字符会被解析为 HTML 代码）和不可见的字符（如“不换行空格”）。 
你也可以用实体来代替其他难以用标准键盘键入的字符。 
备注： 很多字符都有易于记忆的实体。 
例如版权符号 (©) 的实体是 &copy;。 
对于没那么容易记住的字符，例如 &#8212; 或 &#x2014;，你可以查看 参考表 或使用 解码工具。 
保留字符 
有一些特别的字符被保留用于 HTML 中，这意味着浏览器会将这些字符解析为 HTML 代码。 
例如，如果你使用小于号（<），浏览器会将其后的文本解析为一个 {{Glossary(‘tag’)}}。 
为了将这些字符显示为文本，需要使用相应的字符实体来代替它们，如下表所示。 
字符 
实体 
说明 
& 
&amp; 
解析为实体或字符引用的开头 
< 
&lt; 
解析为 {{Glossary(‘tag’)}} 的开头 
> 
&gt; 
解析为 {{Glossary(‘tag’)}} 的结尾 
” 
&quot; 
解析为 {{Glossary(‘attribute’)}} 的值的开头和结尾 
参见 
字符实体的官方列表 

{{GlossarySidebar}} 
事件（Event）是由 DOM 元素产生的资源，它可以由 JavaScript 代码操作。 
参见 
MDN 上的事件文档 
官方网站 
维基百科上的 DOM 事件词条 

{{GlossarySidebar}} 
异常（Exception）是指中断正常代码执行的条件。 
在 JavaScript 中{{glossary(“syntax error”, “语法错误”)}}是一个非常常见的异常来源。 
参见 
维基百科上的异常处理词条 

{{GlossarySidebar}} 
可扩展对象的动态属性 (Expando properties) 是{{glossary(“JavaScript”)}} 添加到{{glossary(“DOM”)}} 节点的属性 , 可以直接从 DOM 元素中访问。 这些属性不是{{glossary(“对象”)}} 的 DOM 规范的一部分： 
window.document.foo = 5; // foo 是一个自定义属性 
该术语也可以应用于添加到对象的属性，而不遵守对象的原始意图，例如非数字命名的属性添加到一个{{glossary(“数组”)}}里。 


{{GlossarySidebar}} 
{{Glossary(“CSP”)}} fetch 指令用在{{HTTPHeader(“Content-Security-Policy”)}} 头部中，可以用来控制某些具体类型的资源可以从哪些来源被加载。 
比如说， {{CSP(“script-src”)}} 使得开发者可以允许可信任来源的脚本在页面上执行， {{CSP(“font-src”)}} 可以控制字体的来源。 
所有的指令的值都会回落到 {{CSP(“default-src”)}}。 
也就是说，如果某个 fetch 指令在 CSP 头部中未定义，那么用户代理就会寻找default-src 指令的值来替代。 
{{CSP(“connect-src”)}} {{CSP(“default-src”)}} 
{{CSP(“font-src”)}} 
{{CSP(“img-src”)}} 
{{CSP(“manifest-src”)}} 
{{CSP(“media-src”)}} {{CSP(“object-src”)}} 
{{CSP(“script-src”)}} 
{{CSP(“style-src”)}} {{CSP(“worker-src”)}} 
{{HTTPHeader(“Content-Security-Policy”)}} 
其他类型的 CSP 指令： {{Glossary(“Document directive”)}} 
{{Glossary(“Navigation directive”)}} 
{{Glossary(“Reporting directive”)}} 

{{GlossarySidebar}} 
fetch 元数据请求标头是一个 {{Glossary(“Request header”, “HTTP 请求标头”)}}，其提供有关来自请求上下文的额外信息。 
这允许服务器根据请求的来源和将要使用的方式，决定是否允许该请求。 
有了这些信息，服务器可以实现{{Glossary(“resource isolation policy”, “资源隔离策略”)}}，允许额外的站点仅请求用于共享的资源并且适当的使用资源。 
这些方法可以帮助缓解常见的跨站点网络漏洞，例如 {{Glossary(“CSRF”)}}、跨站点脚本攻击（“XSSI”）、定时攻击和跨源消息攻击。 
这些标头有 Sec- 前缀，因此有{{Glossary(“Forbidden header name”, “禁止修改的标头”)}}。 
因此，它们不能通过 JavaScript 进行修改。 
fetch 元数据请求标头： 
{{HTTPHeader(“Sec-Fetch-Site”)}} 
{{HTTPHeader(“Sec-Fetch-Mode”)}} 
{{HTTPHeader(“Sec-Fetch-User”)}} 
{{HTTPHeader(“Sec-Fetch-Dest”)}} 
参见 
使用 Fetch 元数据保护你的资源免受网路攻击（web.dev） 
Fetch 元数据请求标头的 playground（secmetadata.appspot.com） 
所有 HTTP 标头列表 
所有 HTTP 标头列表 > Fetch 元数据请求标头 
术语 
{{Glossary(“Representation header”, “表示标头”)}} 
{{Glossary(“HTTP_header”,“HTTP 标头”)}} 
{{Glossary(“Response header”, “响应标头”)}} 
{{Glossary(“Request header”, “请求标头”)}} 

{{GlossarySidebar}} 
防火墙（firewall）是一个过滤网络流量的系统。 
根据一些指定的规则，它可以让网络流量通过，也可以阻止网络流量通过。 
例如，它可以阻止针对某个端口的入站连接或针对某个 IP 地址的出站连接。 
防火墙可以是简单的单一软件，也可以是更复杂的，比如一台专门的机器，其唯一的功能就是充当防火墙。 
参见 
维基百科上的防火墙词条 

{{GlossarySidebar}} 
当一门编程语言的函数可以被当作变量一样用时，则称这门语言拥有头等函数。 
例如，在这门语言中，函数可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量。 
示例 | 把函数赋值给变量 
JavaScript 
const foo = function () { 
console.log("foobar"); 
}; 
// 用变量来调用它 
foo(); 
这里我们把一个匿名函数赋值给一个{{glossary(“Variable”, “变量”)}}，然后我们在这个变量后面加上一对圆括号 () 来调用这个函数。 
备注： 即使你的函数有自己的函数名称，你仍然可以用这个变量名去调用它。 
给函数命名只会方便你调试，但不会影响我们调用它。 
示例 | 传递一个函数作为参数 JavaScript 
function sayHello() { 
return "Hello, "; 
} 
function greeting(helloMessage, name) { 
console.log(helloMessage() + name); 
} 
// 传递 `sayHello` 作为 `greeting` 函数的参数 
greeting(sayHello, "JavaScript!" 
); // Hello, JavaScript! 

{{GlossarySidebar}} 
First Paint，是Paint Timing API的一部分，是页面导航与浏览器将该网页的第一个像素渲染到屏幕上所用的中间时，渲染是任何与输入网页导航前的屏幕上的内容不同的内容。 
它回答了“发生了什么？” 这个问题。 
另请参看 
First meaningful paint 
First contentful paint 
Paint Timing API 

{{GlossarySidebar}} 
Flexbox 是 CSS Flexible Box Layout Module 的常用名称，这是一种用于在单个维度（行或列）中显示项目的布局模型。 
在规范中，Flexbox 被描述为用户界面设计的布局模型。 
Flexbox 的关键特性是 flex 布局中的项目可以增大和缩小。 
可以将空间（Space）分配到项目本身、项目之间或项目周围。 
Flexbox 还可以对齐主轴或交叉轴上的项目，从而提供对一组项目大小和对齐的高级控制。 
学习更多 
属性引用 
{{cssxref(“align-content”)}} 
{{cssxref(“align-items”)}} 
{{cssxref(“align-self”)}} 
{{cssxref(“flex”)}} 
{{cssxref(“flex-basis”)}} 
{{cssxref(“flex-direction”)}} 
{{cssxref(“flex-flow”)}} 
{{cssxref(“flex-grow”)}} 
{{cssxref(“flex-shrink”)}} 
{{cssxref(“flex-wrap”)}} 
{{cssxref(“justify-content”)}} 
{{cssxref(“order”)}} 
延伸阅读 
CSS Flexible Box Layout Module Level 1 Specification 
CSS Flexbox Guide: Basic Concepts of Flexbox 
CSS Flexbox Guide: Ordering flex items 
CSS Flexbox Guide: Typical use cases of flexbox 
{{Glossary(“Flex Container”)}} 
{{Glossary(“Flex Item”)}} 
Related CSS Properties {{cssxref(“align-content”)}} 
{{cssxref(“flex-direction”)}} 
{{cssxref(“order”)}} 

{{GlossarySidebar}} 
在父元素的 display 属性上使用 flex 或 inline-flex 值可定义{{glossary(“flexbox”, “弹性盒”)}}布局。 
此元素由此变为弹性容器（flex container），其任意子元素变为{{glossary(“flex item”, “弹性元素”)}}（flex item）。 
flex 值导致元素变为块级弹性容器，而 inline-flex 为行级弹性容器。 
这些值为元素创建了与区块格式化上下文相似的弹性格式化上下文（flex formatting context），浮动体将不会侵入容器，且容器的外边距将不会与元素的外边距发生折叠。 
参见 
属性参考 
{{cssxref(“align-content”)}} 
{{cssxref(“align-items”)}} 
{{cssxref(“flex”)}} 
{{cssxref(“flex-direction”)}} 
{{cssxref(“flex-flow”)}} 
{{cssxref(“flex-wrap”)}} 
{{cssxref(“justify-content”)}} 
拓展阅读 
CSS 弹性盒指南：弹性盒的基本概念 
CSS 弹性盒指南：在弹性容器中对齐元素 
CSS 弹性盒指南：掌握弹性元素的折行 

{{GlossarySidebar}} 
flex 是一个 CSS 的{{cssxref(“display”)}} 属性中新添加一个值。 
随着inline-flex的使用，它将使它适用的元素成为一个{{glossary(“flex container”)}}（伸缩容器），而这个元素的每个子元素将成为 {{glossary(“flex item”)}}（伸缩项目）。 
伸缩项目将参与到 flex 布局中，所有由 CSS Flexible Box Layout Module（CSS 伸缩盒布局模型）定义的属性都能被它们使用。 
flex 属性是flex-grow, flex-shrink 和 flex-basis 属性的简写。 
此外，<flex> 可以作为弹性长度被引用在 CSS Grid（栅格）布局中。 
了解更多 
属性参考 
{{cssxref(“align-content”)}} 堆栈伸缩行 
{{cssxref(“align-items”)}} 侧轴上项目对齐方式 
{{cssxref(“align-self”)}} 侧轴上单个项目对齐方式 
{{cssxref(“flex”)}} 伸缩性 
{{cssxref(“flex-basis”)}} 伸缩 - 基准值 
{{cssxref(“flex-direction”)}} 伸缩流方向 
{{cssxref(“flex-flow”)}}伸缩流的方向与换行 
{{cssxref(“flex-grow”)}}伸缩 - 扩展基数 
{{cssxref(“flex-shrink”)}} 伸缩 - 收缩比率 
{{cssxref(“flex-wrap”)}} 伸缩 - 换行 
{{cssxref(“justify-content”)}} 主轴对齐 
{{cssxref(“order”)}} 伸缩 - 顺序 
延伸阅读 
CSS Flexible Box Layout Module Level 1 Specification（CSS 盒布局模型一级规范） 
CSS Flexbox Guide（CSS 伸缩盒子指南）: Basic Concepts of Flexbox（伸缩） 
CSS Flexbox Guide（CSS 伸缩盒子指南）: Relationship of flexbox to other layout methods（伸缩盒子与其他布局方法的关系） 
CSS Flexbox Guide（CSS 伸缩盒子指南）: Aligning items in a flex container（伸缩容器中项的对齐） 
CSS Flexbox Guide（CSS 伸缩盒子指南）: Ordering flex items（伸缩项的顺序） 
CSS Flexbox Guide（CSS 伸缩盒子指南）: Mastering wrapping of flex items（掌握如何包装伸缩项） 
CSS Flexbox Guide（CSS 伸缩盒子指南）: Typical use cases of flexbox（伸缩盒子的典型用例） 

{{GlossarySidebar}} 
{{glossary(“Flex Container”)}}(弹性容器) 的一级子元素 (设置display: flex 或 display: inline-flex的子元素) 将成为弹性元素。 
弹性容器内的连续文本，也将成为弹性元素。 
了解更多 
属性参考 
{{cssxref(“align-self”)}} 
{{cssxref(“flex-basis”)}} 
{{cssxref(“flex-grow”)}} 
{{cssxref(“flex-shrink”)}} 
{{cssxref(“order”)}} 
延伸阅读 
CSS 弹性布局指南：Basic Concepts of Flexbox 
CSS 弹性布局指南：Ordering flex items 
CSS 弹性布局指南：Controlling Ratios of flex items along the main axis 

{{GlossarySidebar}} 
禁止修改的标头指的是不能在代码中通过编程的方式进行修改的 HTTP 标头，具体指 HTTP 请求标头（和{{Glossary(“Forbidden response header name”, “禁止修改的响应标头”)}}形成对比）。 
因为用户代理保留对此类标头的完全控制，所以它们被禁止修改。 
保留以 Sec- 开头的名称，以用于在使用 fetch 算法的请求中创建安全的新标头，这些 {{glossary(“API”)}} 授予开发人员对标头的控制权，例如：{{domxref(“XMLHttpRequest”)}}。 
禁止修改的标头包括以 Proxy- 和 Sec- 开头的标头，以及下面列出的标头： 
{{HTTPHeader(“Accept-Charset”)}} 
{{HTTPHeader(“Accept-Encoding”)}} 
{{HTTPHeader(“Access-Control-Request-Headers”)}} 
{{HTTPHeader(“Access-Control-Request-Method”)}} 
{{HTTPHeader(“Connection”)}} 
{{HTTPHeader(“Content-Length”)}} 
{{HTTPHeader(“Cookie”)}} 
{{HTTPHeader(“Date”)}} 
{{HTTPHeader(“DNT”)}} 
{{HTTPHeader(“Expect”)}} 
{{HTTPHeader(“Permissions-Policy”)}} 
{{HTTPHeader(“Host”)}} 
{{HTTPHeader(“Keep-Alive”)}} 
{{HTTPHeader(“Origin”)}} 
Proxy- 
Sec- 
{{HTTPHeader(“Referer”)}} 
{{HTTPHeader(“TE”)}} 
{{HTTPHeader(“Trailer”)}} 
{{HTTPHeader(“Transfer-Encoding”)}} 
{{HTTPHeader(“Upgrade”)}} 
{{HTTPHeader(“Via”)}} 
备注： 根据规范中的禁止修改的标头列表（Firefox 43 中实现了它），{{HTTPHeader(“User-Agent”)}} 标头不再被禁止，现在可以设置在 Fetch 的 Headers 对象中，或者通过 XMLHttpRequest 的 setRequestHeader() 方法设置。 
但是，Chrome 会不做提示地从 Fetch 请求中丢弃这个标头（请参阅 Chromium bug 571722）。 
参见 
{{Glossary(“Forbidden response header name”, “禁止修改的响应标头”)}}（术语表） 

{{GlossarySidebar}} 
禁止修改的响应标头是一个无法通过编程方式修改的 HTTP 标头（Set-Cookie）。 
参见 
Fetch specification: forbidden response-header name 
{{Glossary(“Forbidden header name”, “禁止修改的标头”)}}（术语表） 

{{GlossarySidebar}} 
“派生”（Fork）是在某一时刻对现有的软件项目进行复制，并在项目加上某人的修改。 
基本上，如果原软件的许可证允许，你就可以复制软件的代码，开发自己的版本，附加上自己的补充，这就是一个 Fork。 
Fork 在自由和开源软件的开发中很常见。 
因为使用 Git 或 Github 平台的贡献模式，Fork 是现在比较流行的术语。 
了解更多 
Linux distributions 
Node.js and io.js (which have been merged together back) 
LibreOffice, a fork of OpenOffice 
基本知识 
Fork on Wikipedia 
How to fork a GitHub repo (fork as in a Git context) 
MDN 术语表 {{Glossary(“Fork”)}} 

{{GlossarySidebar}} 
FTP（File Transfer Protocol，文件传输协议）曾在过去许多年里是在 Internet 上主机（{{glossary(“host”)}}）之间传输文件的标准协议（{{glossary(“protocol”)}}）。 
FTP 是 TCP/IP 协议组中的协议之一。 FTP 协议包括两个组成部分，其一为FTP 服务器，其二为 FTP 客户端。 
此外，由于 FTP 传输效率非常高，在网络上传输大的文件时，一般也采用该协议。 
参见 
通过 FTP 上传文件的初学者教程 
维基百科上的 FTP 

{{GlossarySidebar}} 
function，函数，是一个可以被其他代码或其自身调用的代码片段，或者是一个指向该函数的{{Glossary(“variable”, “变量”)}} 。 
当函数被调用时，{{Glossary(“Argument”, “参数”)}}被作为输入传递给函数，并且函数可以返回输出。 
在 {{glossary(“JavaScript”)}} 中，函数也是一个{{glossary(“object”, “对象”)}}。 
函数名是作为函数声明或函数表达式的一部分声明的{{Glossary(“identifier”, “标识符”)}}。 
函数的{{Glossary(“scope”, “作用域”)}}取决于函数名是一个声明还是表达式。 
不同类型的函数 
匿名函数是一个没有函数名的函数： 
function () {}; 
// or using the ECMAScript 2015 arrow notation 
() => {}; 
具名函数是具有函数名称的函数： 
function foo() {} 
// or using the ECMAScript 2015 arrow notation 
const foo = () => {}; 
内部函数是另一个函数内的函数（下面例子中的 square）。 
外部函数是包含一个函数的函数（下面例子中的 addSquares）： 
function addSquares(a, b) { 
function square(x) { 
return x * x; 
} 
return square(a) + square(b); 
} 
//Using ECMAScript 2015 arrow notation 
const addSquares = (a, b) => { 
const square = (x) => x * x; 
return square(a) + square(b); 
}; 
递归函数是调用自身的函数。 
可参考{{Glossary(“Recursion”, “递归”)}}。 
function loop(x) { 
if (x >= 10) return; 
loop(x + 1); 
} 
//Using ECMAScript 2015 arrow notation 
const loop = (x) => { 
if (x >= 10) return; 
loop(x + 1); 
}; 
立即调用函数表达式（{{glossary(“IIFE”)}}）是一种被加载到浏览器的编译器之后直接调用的函数。 
识别 IIFE 的方法是通过在函数声明的末尾定位额外的左和右括号。 
// Error (https://en.wikipedia.org/wiki/Immediately-invoked_function_expression) /* 
function foo() { 
console.log('Hello Foo'); 
}(); 
*/ (function foo() { 
console.log("Hello Foo"); 
})(); 
(function food() { 
console.log("Hello Food"); })(); 
如果你想进一步了解 IIFE, 可参考以下的维基百科的页面：Immediately Invoked Function Expression 了解更多 
技术参考 
Functions 
Arrow Functions 

{{GlossarySidebar}} 
垃圾回收是一个术语，在{{Glossary(“computer programming”, “计算机编程”)}}中用于描述查找和删除那些不再被其他{{Glossary(“object reference”, “对象引用”)}}的{{Glossary(“object”, “对象”)}}处理过程。 
换句话说，垃圾回收是删除任何其他对象未使用的对象的过程。 
垃圾收集通常缩写为 “GC”，是 {{Glossary(“JavaScript”)}} 中使用的内存管理系统的基本组成部分。 学习更多 
基本知识 
Memory management on Wikipedia 
Garbage collection on Wikipedia 技术参考 
Garbage collection in the MDN JavaScript guide. 
Memory management in JavaScript 

{{GlossarySidebar}} 
Gecko 是 Mozilla 项目开发的布局引擎，在许多应用程序/设备中使用，包括{{glossary(“Mozilla Firefox”,“Firefox”)}} 和 {{glossary(“Firefox OS”)}}。 
Web {{glossary(“browser”,“浏览器”)}} 需要一个被称为布局引擎的软件来解释 {{glossary(“HTML”)}}, {{glossary(“CSS”)}}, {{glossary(“JavaScript”)}}和嵌入式内容（如：图片），并将所有内容绘制到屏幕上。 
除此之外，Gecko 确保相关的 {{glossary(“API”,“APIs”)}} 在 Gecko 支持的每一个操作系统上都能很好的工作，并且适当的 API 只暴露给相关的支持目标。 
这意味着 Gecko 包括网络栈、图形栈、布局引擎、Javascript 虚拟机和移植层等。 
由于所有的 Firefox OS 应用都是 Web 应用程序，所以 Firefox OS 会使用 Gecko 当其应用处于运行时。 了解更多 
基本知识 
Gecko on Wikipedia 

{{GlossarySidebar}} 

{{GlossarySidebar}} 
GIF（图形交换格式）是一种使用无损压缩并可用于动画的图像格式。 
一个 GIF 每像素使用 8 位，且在 24 位色彩空间最多使用 256 种颜色。 了解更多 
常识 
在维基百科上的 GIF 

{{GlossarySidebar}} 
Git 是一个免费，开源，分布式源代码管理（版本控制） ({{Glossary(“SCM”, “SCM”, 1)}}) 系统。 
它有助于分布式开发团队维护代码库。 
与以前的 SCM 系统不同的是，它能在本地开发机器上进行常见操作（分支，提交等），而无需更改主存储库，甚至不需要主存储库的写入权限。 
了解更多 
基础知识 Git 官方网站 
GitHub，一个基于 Git 的图形化项目网站 

{{GlossarySidebar}} 
一个全局对象是一个永远存在于 {{glossary(“global scope”)}} 的 {{glossary(“object”)}}. 
在 JavaScript 中，有一个永远被定义的全局对象。 
在一个 web 浏览器中，当脚本创建全局变量时，他们作为该全局对象的成员被创建。( 
在 {{Glossary(“Node.js”)}} 不是这样.) 
全局对象的 {{Glossary(“interface”)}} 取决于脚本在其中运行的执行上下文。 
例如： 
在 Web 浏览器中，脚本没有专门作为后台任务启动的任何代码都将{{domxref(“Window”)}} 作为其全局对象。 
这是 Web 上绝大多数的 JavaScript 代码。 
在 {{domxref(“Worker”)}} 中运行的代码将{{domxref(“WorkerGlobalScope”)}} 对象作为其全局对象。 
在{{Glossary(“Node.js”)}} 环境下运行的脚本具有一个称为global 的对象作为其全局对象。 
访问全局变量 var foo = "foobar"; foo === window.foo; // Returns: true 
在定义全局变量 foo 之后，我们可以通过 window 对象的属性来访问它。 
把变量名 foo 作为全局对象的 window.foo 的属性名来使用。 解释： 
全局变量 foo 存储在 window 对象中，像这样： foo: "foobar"; 访问全局函数 function greeting() { console.log("Hi!" ); } 
window.greeting(); // It is the same as the normal invoking: greeting(); 
上面解释了全局对象如果作为 window 对象的属性而存储的。 
我们创建了全局函数 greeting ，然后通过 window 对象来调用它。. 解释： 
全局函数 greeting 存储在 window 对象中，像这样： 
greeting: function greeting() { 
console.log("Hi!" ); } 
参见 
MDN Web Docs Glossary 
{{glossary(“global scope”)}} 
{{glossary(“object”)}} 
{{domxref(“Window”)}} 
{{domxref(“WorkerGlobalScope”)}} 
global 

{{GlossarySidebar}} 
Chrome 浏览器是 Google 开发的一个免费网络{{glossary(“browser”,“浏览器”)}}。 
它基于开源项目 Chromium。 
BrowserStack 中描述了它们之间的主要差异。 
Chrome 维护使用自己的渲染引擎 {{glossary(“Blink”)}} 。 
注意：IOS 版本的 Chrome 使用了 IOS 平台的 WebView，而非 Blink。 
参见 
Google Chrome 维基百科 
对于使用者 
如果你只想使用 Chrome，请点击下面的链接。 
安卓版 
IOS 版 
桌面版 
对于开发者 
如果你想尝试 Chrome 的最新功能，可以尝试使用预发布版本。 
Google 经常推送更新，并使得这些版本可以与稳定版并行运行。 
你可以在 Chrome Release Blog 了解更多相关内容。 
安卓上的 Chrome 开发者版本 
电脑上的 Chrome 金丝雀版本 

{{GlossarySidebar}} 
GPU（图形处理单元）是与 CPU（中央处理单元）类似的计算机部件。 
它专门在显示器上绘制图形（包括二维和三维）。 

{{GlossarySidebar}} 
优雅降级（Graceful degradation）是一种设计理念，其核心是尝试构建可在最新浏览器中运行的现代网站/应用程序，而作为降级体验，在低版本浏览器中仍然提供必要的内容和功能。 
{{Glossary(“Polyfill”,“Polyfill”)}}可用于使用 JavaScript 构建缺少的功能，但应尽可能提供样式和布局等功能的可接受替代方案，例如使用 CSS 级联或 HTML 回退行为。 
在处理常见的 HTML 和 CSS 问题中可以找到一些很好的例子。 
这个技术很有用，因为它让 Web 开发者，在专注开发最强大的网站同时，和某些未知的用户代理，在访问网站时发生的问题间达到权衡。{{ 
Glossary(“渐进增强”)}}相关而不同—通常被看做优雅降级的相反行为。 
实际上，这两种方法都是有效的，并且通常可以相互补充。 
了解更多 
基本知识 
维基百科的优雅降级 
MDN Web 文档词汇表 
{{Glossary(“Graceful degradation”)}} 
{{Glossary(“Polyfill”)}} 
{{Glossary(“渐进增强”)}} 

{{GlossarySidebar}} 
网格区域是网格中由一个或者多个{{glossary(“grid cell”, “网格单元格”)}}组成的一个矩形区域。 
当你使用基于网格线位置放置一个项目或者使用命名的网格区域定义区域时，网格区域被创建。 
Image showing a highlighted grid area 
本质上，网格区域一定是矩形的。 例如，不可能创建 T 形或 L 形的网格区域。 
在下面的例子中，有一个网格容器包含两个网格项目，我用 {{cssxref(“grid-area”)}} 属性命名它们，然后用 {{cssxref(“grid-template-areas”)}} 把它们放在网格上。 
这将创建两个网格区域，一个覆盖四个网格单元格，另外一个覆盖两个。 示例 
```css hidden * { box-sizing: border-box; } 
.wrapper { border: 2px solid #f76707; border-radius: 5px; background-color: #fff4e6; } 
.wrapper > div { border: 2px solid #ffa94d; border-radius: 5px; background-color: #ffd8a8; padding: 1em; color: #d9480f; } 
```css 
.wrapper { 
display: grid; 
grid-template-columns: repeat(3, 1fr); 
grid-template-rows: 100px 100px; 
grid-template-areas: 
"a a b" 
"a a b"; 
} 
.item1 { 
grid-area: a; 
} 
.item2 { 
grid-area: b; 
} 
<div class="wrapper"> 
<div class="item1">Item</div> 
<div class="item2">Item</div> 
</div> 
{{ EmbedLiveSample(‘示例’, ‘300’, ‘280’) }} 
了解更多 
属性参考 
{{cssxref(“grid-template-columns”)}} 
{{cssxref(“grid-template-rows”)}} 
{{cssxref(“grid-auto-rows”)}} 
{{cssxref(“grid-auto-columns”)}} 
{{cssxref(“grid-template-areas”)}} 
{{cssxref(“grid-area”)}} 
扩展阅读 
CSS Grid Layout Guide: Basic concepts of grid layout 
CSS Grid Layout Guide: Grid template areas 
Definition of Grid Areas in the CSS Grid Layout specification 

{{GlossarySidebar}} 
CSS 网格布局是一种二维布局方法，能够按行和列对内容布局。 
因此在任何网格中都有两个轴——块向或列轴（block or column axis），及行向或行轴（inline or row axis）。 
沿着这些轴可以使用盒对齐规范中定义的属性对元素按块向轴或行向轴对齐。 
在 CSS 中，块向或列轴用于对文本区块布局。 
如果你有两个段落，用的从右到左、从上到下的语言，那么在块向轴上两个段落一个排在另一个下面。 
CSS 网格布局中的块向轴图示 
行向或行轴沿与块向轴垂直的方向延伸，常规文本沿其方向流动。 
以下是我们在网格布局中的行。 
CSS 网格布局中的行向轴图示 
这些轴的实体方向可根据文档的书写模式改变。 
参见 
CSS 网格布局指南：网格布局的基本概念 
CSS 网格布局指南：网格布局中的盒对齐 
CSS 网格布局指南：网格、逻辑值和书写模式 

{{GlossarySidebar}} 
在Grid 布局中，网络单元格是 CSS 网格中的最小单元。 
它是四条{{glossary(“grid lines”,“网格线”)}}之间的空间，概念上非常像表格单元格。 
Diagram showing an individual cell on the grid. 
如果不使用网格布局提供的方法去放置网格容器的项目，这些项目将通过自动布局算法被放置到每个网格单元格中。 
将创建额外的行或列{{glossary(“grid tracks”, “轨道”)}}以创建足够的单元格来保存所有项目。 
在例子中，我们创建了一个三列轨道的网格。 
五个项目被放置到网格单元格中，它们沿着初始行依次被放置到三个网格单元格中，然后为剩下的两个创建了一个新行。 示例 
```css hidden * { box-sizing: border-box; } 
.wrapper { border: 2px solid #f76707; border-radius: 5px; background-color: #fff4e6; } 
.wrapper > div { border: 2px solid #ffa94d; border-radius: 5px; background-color: #ffd8a8; padding: 1em; color: #d9480f; } 
```css 
.wrapper { 
display: grid; 
grid-template-columns: repeat(3, 1fr); 
grid-auto-rows: 100px; 
} 
<div class="wrapper"> 
<div>One</div> 
<div>Two</div> 
<div>Three</div> 
<div>Four</div> 
<div>Five</div> 
</div> 
{{ EmbedLiveSample(‘示例’, ‘300’, ‘280’) }} 
了解更多 
属性参考 
{{cssxref(“grid-template-columns”)}} 
{{cssxref(“grid-template-rows”)}} 
{{cssxref(“grid-auto-rows”)}} 
{{cssxref(“grid-auto-columns”)}} 
扩展阅读 
CSS Grid Layout Guide: Basic concepts of grid layout 
Definition of Grid Cells in the CSS Grid Layout specification 

{{GlossarySidebar}} 
网格列是Grid 布局中的垂直轨道，即两个垂直网格线之间的空间。 
它通过属性 {{cssxref(“grid-template-columns”)}} 或者简写属性 {{cssxref(“grid”)}}，{{cssxref(“grid-template”)}} 定义。 
另外，当项目被放置到显示网格中创建的列外面时，可以在隐式网格中创建网格列。 
默认情况这些列自动调整大小，也可以使用 {{cssxref(“grid-auto-columns”)}} 属性指定其大小。 
在Grid 布局中使用对齐方式时，网格列沿着纵轴运行。 
了解更多 
属性参考 
{{cssxref(“grid-template-columns”)}} 
{{cssxref(“grid-auto-columns”)}} 
{{cssxref(“grid”)}} 
{{cssxref(“grid-template”)}} 
扩展阅读 
CSS Grid Layout Guide: Basic concepts of grid layout 

{{GlossarySidebar}} 
通过设置 CSS 属性 display:grid; 或 display:inline-grid; 可以将一个元素定义为网格容器(grid container)，并且它的所有直接子元素都会成为网格项。 
网格容器会创建一个网格化环境(grid firmatting context) 。 
它的直接子元素通过定义 {{cssxref(“grid-template-columns”)}} 和 {{cssxref(“grid-template-rows”)}} 属性可以将自己变为显式网格，当某个元素不在显示网格内时，它就会变为隐式网格。 
了解更过 
属性参考 
{{cssxref(“grid-template-columns”)}} 
{{cssxref(“grid-template-rows”)}} 
{{cssxref(“grid-auto-columns”)}} 
{{cssxref(“grid-auto-rows”)}} 
{{cssxref(“grid”)}} 
{{cssxref(“grid-template”)}} 
扩展阅读 
CSS 网格布局：网格布局基本概念 


{{GlossarySidebar}} 
使用Grid 布局在显式网格中定义{{glossary(“Grid tracks”, “轨道”)}}的同时会创建网格线。 
在下面的例子中，有一个三列两行的网格。 
它给了我们 4 条列线和 3 条行线。 示例 
```css hidden * { box-sizing: border-box; } 
.wrapper { border: 2px solid #f76707; border-radius: 5px; background-color: #fff4e6; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 100px); } 
.wrapper > div { border: 2px solid #ffa94d; border-radius: 5px; background-color: #ffd8a8; padding: 1em; color: #d9480f; } 
```html 
<div class="wrapper"> 
<div>One</div> 
<div>Two</div> 
<div>Three</div> 
<div>Four</div> 
<div>Five</div> 
</div> 
.wrapper { 
display: grid; 
grid-template-columns: repeat(3, 1fr); 
grid-template-rows: 100px 100px; 
} 
{{ EmbedLiveSample(‘示例’, ‘500’, ‘250’) }} 
网格线可以用它们的编号来寻址。 
在从左到右的语言比如英语中，列线 1 将位于网格的左侧，行线 1 将位于其顶部。 
线编号遵循文档的写入模式，因此在从右到左的语言中，列线 1 行将位于网格的右侧。 
下面的图片展示了该网格的线编号，假设语言是从左到右的。 
Diagram showing the grid with lines numbered. 
当创建隐式轨道去支持显式网格外的内容时，网格线也会在隐式网格中被创建，但是这些网格线不能通过编号来寻址。 
按网格线编号将项目放置到网格上 
创建一个网格后，可以通过网格线编号将项目放置到该网格上。 
在下面的例子中，项目定位从列线 1 到列线 3，从行线 1 到行线 3。 
```css hidden * { box-sizing: border-box; } 
.wrapper { border: 2px solid #f76707; border-radius: 5px; background-color: #fff4e6; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 100px); } 
.wrapper > div { border: 2px solid #ffa94d; border-radius: 5px; background-color: #ffd8a8; padding: 1em; color: #d9480f; } 
```html 
<div class="wrapper"> 
<div class="item">Item</div> 
</div> 
.wrapper { 
display: grid; 
grid-template-columns: repeat(3, 1fr); 
grid-template-rows: 100px 100px; 
} 
.item { 
grid-column-start: 1; 
grid-column-end: 3; 
grid-row-start: 1; 
grid-row-end: 3; 
} 
{{ EmbedLiveSample(‘按网格线编号将项目放置到网格上’, ‘500’, ‘250’) }} 
命名网格线 
在显式网格中创建的网格线可以被命名，在轨道大小信息之前或之后的方括号中命名。 
当放置一个项目时，你可以使用这些名称代替编号，如下所示。 
```css hidden * { box-sizing: border-box; } 
.wrapper { border: 2px solid #f76707; border-radius: 5px; background-color: #fff4e6; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 100px); } 
.wrapper > div { border: 2px solid #ffa94d; border-radius: 5px; background-color: #ffd8a8; padding: 1em; color: #d9480f; } 
```html 
<div class="wrapper"> 
<div class="item">Item</div> 
</div> 
.wrapper { 
display: grid; 
grid-template-columns: [col1-start] 1fr [col2-start] 1fr [col3-start] 1fr [cols-end]; 
grid-template-rows: [row1-start] 100px [row2-start] 100px [rows-end]; 
} 
.item { 
grid-column-start: col1-start; 
grid-column-end: col3-start; 
grid-row-start: row1-start; 
grid-row-end: rows-end; 
} 
{{ EmbedLiveSample(‘命名网格线’, ‘500’, ‘250’) }} 
了解更多 
属性参考 
{{cssxref(“grid-template-columns”)}} 
{{cssxref(“grid-template-rows”)}} 
{{cssxref(“grid-column-start”)}} 
{{cssxref(“grid-column-end”)}} 
{{cssxref(“grid-column”)}} 
{{cssxref(“grid-row-start”)}} 
{{cssxref(“grid-row-end”)}} 
{{cssxref(“grid-row”)}} 
扩展阅读 
CSS Grid Layout Guide: Basic concepts of grid layout 
CSS Grid Layout Guide: Line-based placement with CSS Grid 
CSS Grid Layout Guide: Layout using named grid lines 
CSS Grid Layout Guide: CSS Grids, Logical Values and Writing Modes 
Definition of Grid Lines in the CSS Grid Layout specification 

{{GlossarySidebar}} 
网格行是Grid 布局中的水平轨道，即两个水平网格线之间的空间。 
它通过属性 {{cssxref(“grid-template-rows”)}} 或者简写属性 {{cssxref(“grid”)}}， {{cssxref(“grid-template”)}} 定义。 
另外，当项目被放置到显示网格中创建的行外面时，可以在隐式网格中创建网格行。 
默认情况这些行自动调整大小，也可以使用 {{cssxref(“grid-auto-rows”)}} 属性指定其大小。 
在Grid 布局中使用对齐方式时，网格行沿着横轴运行。 
了解更多 
属性参考 
{{cssxref(“grid-template-rows”)}} 
{{cssxref(“grid-auto-rows”)}} 
{{cssxref(“grid”)}} 
{{cssxref(“grid-template”)}} 
扩展阅读 
CSS Grid Layout Guide: Basic concepts of grid layout 

{{GlossarySidebar}} 
网格轨道 是两条{{glossary(“grid lines”,“网格线”)}}之间的空间。 
它们通过使用属性 {{cssxref(“grid-template-columns”)}} 和 {{cssxref(“grid-template-rows”)}} 或者简写属性 {{cssxref(“grid”)}} 和 {{cssxref(“grid-template”)}} 在显式网格中定义。 
网格轨道也可以在隐式网格中创建，通过将一个网格项目定位到显式网格中创建的轨道外面。 
下图展示该网格中的第一个行轨道（上色部分的空间）。 
Diagram showing a grid track. 
显式网格中的轨道大小 
当使用 {{cssxref(“grid-template-columns”)}} 和 {{cssxref(“grid-template-rows”)}} 定义网格轨道时，你可以使用任何长度单位，也可以使用 flex 单位 fr 来表示网格容器中可用空间的一部分。 
下面的例子演示了一个三列轨道的网格，第一列 200px，第二列 1fr，第三列 3fr。 
网格容器中的可用空间减去 200px 后，剩余空间被分成 4 份，1 份给第二列，3 份给第三列。 
```css hidden * { box-sizing: border-box; } 
.wrapper { border: 2px solid #f76707; border-radius: 5px; background-color: #fff4e6; } 
.wrapper > div { border: 2px solid #ffa94d; border-radius: 5px; background-color: #ffd8a8; padding: 1em; color: #d9480f; } 
```css 
.wrapper { 
display: grid; 
grid-template-columns: 200px 1fr 3fr; 
} 
<div class="wrapper"> 
<div>One</div> 
<div>Two</div> 
<div>Three</div> 
<div>Four</div> 
<div>Five</div> 
</div> 
{{ EmbedLiveSample(‘显式网格中的轨道大小’, ‘500’, ‘230’) }} 
隐式网格中的轨道大小 
隐式网格中创建的轨道默认为自动大小，但可以通过 {{cssxref(“grid-auto-rows”)}} 和 {{cssxref(“grid-auto-columns”)}} 属性来定义这些轨道的大小。 
了解更多 
属性参考 
{{cssxref(“grid-template-columns”)}} 
{{cssxref(“grid-template-rows”)}} 
{{cssxref(“grid-auto-rows”)}} 
{{cssxref(“grid-auto-columns”)}} 

{{GlossarySidebar}} 
Guard 是 {{domxref(“Headers”)}} 对象的新特性 (在 {{domxref(“Fetch_API”,“Fetch spec”)}} 中定义）, 限制了像 {{domxref(“Headers.set”,“set()”)}} 和 {{domxref(“Headers.append”,“append()”)}} 方法操作 header 的内容。 
举个例子，immutable guard 意味着 headers 不能被改变。 
阅读 Fetch basic concepts: guard，了解更多信息 

{{GlossarySidebar}} 
网格间距是网格轨道之间的间距，可以通过 {{cssxref(“grid-column-gap”)}}，{{cssxref(“grid-row-gap”)}} 或者 {{cssxref(“grid-gap”)}} 在Grid 布局中创建。 
在下面的例子中，由一个三列两行的网格。 它的列轨道之间有 20px 的间距，行轨道之间有 20px 的间距。 示例 
```css hidden * { box-sizing: border-box; } 
.wrapper { border: 2px solid #f76707; border-radius: 5px; background-color: #fff4e6; } 
.wrapper > div { border: 2px solid #ffa94d; border-radius: 5px; background-color: #fff8f8; padding: 1em; color: #d9480f; } 
```css 
.wrapper { 
display: grid; 
grid-template-columns: repeat(3, 1.2fr); 
grid-auto-rows: 45%; 
grid-column-gap: 20px; 
grid-row-gap: 20px; 
} 
<div class="wrapper"> 
<div>One</div> 
<div>Two</div> 
<div>Three</div> 
<div>Four</div> 
<div>Five</div> 
</div> 
{{ EmbedLiveSample(‘示例’, ‘300’, ‘280’) }} 
在网格大小上，网格间距参与计算就好像规则的网格轨道一样，但是没有任何东西可以被放置到网格间距上。 
网格间距也像网格线一样在那个位置会增加额外的大小，因此网格项目会被放置在网格间距末的那条网格线后。 
能够导致轨道被间隔开来的，除了网格间距属性，还有 margins，padding 或者使用盒模型对齐中的空间分布属性。 
这些方法都会导致可见间距的产生，因此网格间距属性不等价于”间距大小“，除非你没有使用这些能够产生间距的方法。 
了解更多 
属性参考 
{{cssxref(“grid-column-gap”)}} 
{{cssxref(“grid-row-gap”)}} 
{{cssxref(“grid-gap”)}} 
扩展阅读 
CSS Grid Layout Guide: Basic concepts of grid layout 
Definition of gutters in the CSS Grid Layout specification 

{{GlossarySidebar}} 
Gzip 是一种用于文件压缩与解压缩的文件格式。 
它基于 Deflate 算法，可将文件（译者注：快速地、流式地）压缩地更小，从而实现更快的网络传输。 Web 服务器与现代浏览器普遍地支持 Gzip，这意味着服务器可以在发送文件之前自动使用 Gzip 压缩文件，而浏览器可以在接收文件时自行解压缩文件。 
了解更多 
如何启用 GZip 压缩 
Gzip on Wikipedia 

{{GlossarySidebar}} 
散列（Hash）函数采用可变长度消息输入并产生固定长度的散列输出。 
它通常以 128 位“指纹”或“消息摘要”的形式出现。 
散列函数对{{glossary(“cryptography”, “密码学”)}}非常有用——它们确保传输数据的完整性，这也为提供消息认证的 {{glossary(“HMAC”)}} 提供了基础。 
参见 
维基百科上的散列函数词条 

{{GlossarySidebar}} 
Head是{{glossary(“HTML”)}}文档的一部分，包含了关于文档的{{glossary(“metadata”)}}，比如作者、描述以及应用于 HTML 的{{glossary(“CSS”)}} 或者 {{glossary(“JavaScript”)}} 文件的链接。 了解更多 
HTML head 
MDN 里的{{htmlelement(“head”)}}元素引用 
MDN 学习区域里的The HTML <head> 

{{GlossarySidebar}} 
HMAC（密钥散列消息认证码）是一个被用于{{Glossary(“cryptography”, “密码学”)}}的认证消息协议。 
它可以使用于任何的{{Glossary(“Cryptographic hash function”, “密码学函数”)}}。 它的强度依赖底层的函数（例如 SHA1 或 MD5）以及被选中的密钥。 
出于这样使用上的组合，HMAC 认证{{Glossary(“Algorithm”, “算法”)}}通常是以组合名字出现，如 HMAC-SHA1。 
HMAC 通常用于确保完整性和身份验证。 
基础知识 
技术参考 
IETF 的 RFC 2104 

{{GlossarySidebar}} 
变量提升（Hoisting）被认为是，Javascript 中执行上下文（特别是创建和执行阶段）工作方式的一种认识。 在 ECMAScript® 2015 Language Specification 之前的 JavaScript 文档中找不到变量提升（Hoisting）这个词。 
实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。 了解更多 技术范例 
JavaScript 在执行任何代码段之前，将函数声明放入内存中的优点之一是，你可以在声明一个函数之前使用该函数。 例如： 
/** * 正确的方式：先声明函数，再调用函数 (最佳实践) 
*/ function catName(name) { 
console.log("我的猫名叫 " + name); } 
catName("Tigger"); /* 
*/ catName("Chloe"); function catName(name) { 
console.log("我的猫名叫 " + name); } 
/* 代码执行的结果是："我的猫名叫 Chloe" */ 
这是因为在 JavaScript 中执行上下文的工作方式造成的。 
变量提升也适用于其他数据类型和变量。 变量可以在声明之前进行初始化和使用。 但是如果没有初始化，就不能使用它们。 
译者注：函数和变量相比，会被优先提升。 这意味着函数会被提升到更靠前的位置。 只有声明被提升 
JavaScript 只会提升声明，不会提升其初始化。 
如果一个变量先被使用再被声明和赋值的话，使用时的值是 undefined。 
参见例子： 
console.log(num); // Returns undefined 
var num; num = 6; 
如果你先赋值、再使用、最后声明该变量，使用时能获取到所赋的值 num = 6; 
console.log(num); // returns 6 var num; 
再来看几个类似的例子： // Example 1 - only y is hoisted 
var x = 1; // 声明 + 初始化 x 
console.log(x + " " + y); // '1 undefined' 
var y = 2; // 声明 + 初始化 y // Example 2 - Hoists 
var num1 = 3; // Declare and initialize num1 
num2 = 4; // Initialize num2 
console.log(num1 + " " + num2); //'3 4' 
var num2; // Declare num2 for hoisting 
// Example 3 - Hoists a = "Cran"; // Initialize a 
b = "berry"; // Initialize b 
console.log(a + "" + b); // 'Cranberry' 
var a, b; // Declare both a & b for hoisting 
技术参考 var statement - MDN 
function statement - MDN 

{{GlossarySidebar}} 
主机（host）是一种连接到 {{glossary(“Internet”)}} （或者一个本地网络）的设备。 
有一些被称作 {{glossary(“server”,“servers”)}} （服务器）的主机可以提供额外的服务，如：提供网页、存储文件以及电子邮件。 
由虚拟机产生的主机也叫作“虚拟主机”。 
了解更多 
基本知识 

{{GlossarySidebar}} 
HTTP 严格传输安全 让网站可以通知浏览器它不应该再使用 HTTP 加载该网站，而是自动转换该网站的所有的 HTTP 链接至更安全的 HTTPS。 
它包含在 HTTP 的协议头 {{HTTPHeader(“Strict-Transport-Security”)}} 中，在服务器返回资源时带上。 
换句话说，它告诉浏览器将 URL 协议从 HTTP 更改为 HTTPS（会更安全），并要求浏览器对每个请求执行此操作。 
了解更多 
{{HTTPHeader(“Strict-Transport-Security”)}} 
OWASP 文章：HTTP Strict Transport Security 
维基百科上的 HTTP 严格传输安全 

{{GlossarySidebar}} 
{{Glossary(“HTML”)}} 的最新稳定版本，HTML5 将 HTML 从用于构造一个文档的一个简单标记，到一个完整的应用程序开发平台。 
除其他功能外，HTML5 还包括新元素和用于增强存储、多媒体和硬件访问的{{glossary(“JavaScript”)}} {{glossary(“API”,“APIs”)}} 。 
更多相关内容 
our HTML5 guide 

{{GlossarySidebar}} 
HTML（HyperText Markup Language，超文本标记语言）是一种描述语言，用来定义网页结构。 
发展历史 
1990 年，由于对 {{glossary(“World Wide Web”,“Web”)}} 未来发展的远见，Tim Berners-Lee 提出了 {{glossary(“hypertext”, “超文本”)}} 的概念，并在第二年在 {{glossary(“SGML”)}} 的基础上将其正式定义为一个标记语言。{{ 
glossary(“IETF”)}} 于 1993 年正式开始制定 HTML 规范，并在经历了几个版本的草案后于 1995 年发布了 HTML 2.0 版本。 
1994 年，Berners-Lee 为了 Web 发展而成立了 {{glossary(“W3C”)}}。 
1996 年，W3C 接管了 HTML 的标准化工作，并在 1 年后发布了 HTML 3.2 推荐标准。 
1999 年，HTML 4.0 发布，并在 2000 年成为 {{glossary(“ISO”)}} 标准。 
自那以后，W3C 几乎放弃了 HTML 而转向 {{glossary(“XHTML”)}}，并于 2004 年成立了另一个独立的小组 {{glossary(“WHATWG”)}}。 
幸运的是，WHATWG 后来又转回来参与了 {{glossary(“HTML5”)}} 标准的制定，两个组织（译注：即 W3C 和 WHATWG）在 2008 年发布了第一份草案，并在 2014 年发布了 HTML5 标准的最终版。 
概念和语法 
HTML 文档是包含多个 {{glossary(“element”,“HTML 元素”)}} 的文本文档。 
每个元素都用一对开始和结束 {{Glossary(“tag”,“标签”)}} 包裹。 
每个标签以尖括号（<>）开始和结束。 
也有一部分标签中不需要包含文本，这些标签称为空标签，如 {{htmlelement(“img”)}}。 
你可以使用 {{Glossary(“attribute”,“属性”)}} 来扩展 HTML 标签。 属性用来提供一些附加信息，这些信息可能会影响浏览器对元素的解析： 
Detail of the structure of an HTML element 
HTML 文件通常会以 .htm 或 .html 为扩展名。 用户可以从 {{Glossary(“Server”,“Web 服务器”)}} 中下载，并使用任一 {{Glossary(“Browser”,“Web 浏览器”)}} 来解析和显示。 
参见 
维基百科 HTML 词条 
HTML 教程 
codecademy.com 上的在线教程 
MDN HTML 文档 
HTML 规范 

{{GlossarySidebar}} 
HTTP/2 是 HTTP 网络协议的一个重要版本。 
HTTP / 2 的主要目标是通过启用完整的请求和响应多路复用来减少 {{glossary(“延迟”)}}，通过有效压缩 HTTP 标头字段来最小化协议开销，并增加对请求优先级和服务器推送的支持。 
HTTP/2 不会修改 HTTP 协议的语义。 
HTTP 1.1 中的所有核心概念（例如 HTTP 方法，状态码，URI 和 headers）都得以保留。 
而是修改了 HTTP/2 数据在客户端和服务器之间的格式（帧）和传输方式，这两者都管理整个过程，并在新的框架层内隐藏了应用程序的复杂性。 
所以，所有现有的应用程序都可以不经修改地交付。 
参见 
HTTP on MDN 
HTTP/2 on Wikipedia 
词汇表 
{{glossary(“HTTP”)}} 
{{glossary(“Latency”)}} 

{{GlossarySidebar}} 
HTTP/3是继{{glossary(“HTTP 2”, “HTTP/2”)}}即将到来的HTTP 网络协议的主要修订版。 
HTTP/3 的要点是它使用名为 QUIC 的新{{glossary(“UDP”)}}协议代替{{glossary(“TCP”)}}。 
参见 
HTTP on MDN 
HTTP/3 
词汇表 
{{glossary(“HTTP”)}} 
{{glossary(“HTTP 2”)}} 
{{glossary(“Latency”)}} 

{{GlossarySidebar}} 
{{Glossary(“Request header”, “请求标头”)}}：该标头包含要获取的资源或者客户端自身的更多信息。 
{{Glossary(“Representation header”, “表示标头”)}}：该标头包含消息主体中资源的元数据（例如，编码、媒体类型等）。 
{{Glossary(“Fetch metadata request header”, “Fetch 元数据请求标头”)}}：该标头关于消息主体中资源等元数据（例如，编码、媒体类型等）。 
GET /example.html HTTP/1.1 Host: example.com 
Access-Control-Allow-Origin: * Age: 2318192 Cache-Control: public, max-age=315360000 
{{Glossary(“Response header”, “响应标头”)}} {{Glossary(“Representation header”, “表示标头”)}} 
{{Glossary(“Fetch metadata request header”, “Fetch 元数据请求标头”)}} {{Glossary(“Forbidden header name”, “禁止修改的标头”)}} 

{{GlossarySidebar}} 
HTTP (The HyperText Transfer Protocol，超文本传输协议) 是用于在 {{glossary(“World Wide Web”,“Web”)}} 上传输超媒体文件的底层 {{glossary(“protocol”, “协议”)}} ，最典型场景的是在浏览器和服务器之间传递数据，以供人们浏览。 
现行的 HTTP 标准的版本是 {{glossary(“HTTP_2”, “HTTP/2”)}}。 
http:// 称为 schema，是 {{glossary(“URI”)}} 的组成部分，一般位于网络地址的开头。 
以 https://developer.mozilla.org 为例，该地址说明请求文档时使用 HTTP 协议；这里的 https 代指 HTTP 协议的安全版本，即 {{glossary(“SSL”)}} （或称 TLS） 
HTTP 是基于文本的 (所有的通信都以纯文本的形式进行) 以及无状态的 (当前通信状态不会发现以前的通信状态)，该特性极大方便了在 www 上浏览网页的人。 
除此之外，HTTP 也可以用于构建服务器之间交互的 {{glossary(“REST”)}} web 服务，以及使得网站内容更加动态化的 {{glossary(“AJAX”)}} 请求。 
补充知识 
在 MDN 上的 HTTP 
在维基百科上的 HTTP 

{{GlossarySidebar}} 
HTTPS（超文本传输安全协议）是 {{Glossary(“HTTP”)}} 协议的加密版本。 
它使用 {{Glossary(“SSL”)}} 或 {{Glossary(“TLS”)}} 协议来加密客户端和服务器之间所有的通信。 
安全连接允许客户端与服务器安全地交换敏感数据，例如网上银行或者在线商城等涉及金钱的操作。 
参见 
维基百科上的 HTTPS 词条 
迁移至 HTTPS：社区指南 
安全上下文 
MDN Web 文档术语表 
{{glossary(“HTTP”)}} 
{{glossary(“SSL”)}} 
{{glossary(“TLS”)}} 

{{GlossarySidebar}} 
超链接将网页或其他数据连接起来。 
在 HTML 中，{{HTMLElement(“a”)}} 标签定义了网页中的某处（例如一段文本或一张图片）到其他网页（也可能是本网页）的另一处的超链接。 深入了解 
基础知识 
Hyperlink on Wikipedia 
The Hyperlink guide on MDN 
Links in HTML Documents - W3C 
HTML5 a - hyperlink - W3C 
MDN 上的 <a> 
MDN 上的 <link> 

{{GlossarySidebar}} 
Hypertext 包含了指向其他文本的链接，而不是像小说中的单一线性流。 
基本信息 维基百科上的Hypertext 
技术参考 
Hypertext Information Base 

{{GlossarySidebar}} 
i18n（取自 “internationalization”, 共 20 个字母）是让产品或服务更容易适应各种文化的最佳实践。 
国际化是指在设计和开发产品、应用或文档内容时，为不同文化、地区或语言的目标受众提供方便的本地化服务。（{{ 
Glossary(“W3C”)}} 定义） 
在其他方面，i18n 仍然需要许多支持 
字符集（通常使用 Unicode） 
计量单位（货币、°C/°F、km/miles 等） 
文字书写顺序 
i18n on Wikipedia 
技术参考 
i18n on W3C 
i18n on gala-global.org 
学习 i18n 
i18n material on i18nguy.com 

{{GlossarySidebar}} 
ICE (交互式连接建立) 是一个被{{glossary(“WebRTC”)}}使用的框架（跟其他技术在一起使用），它被用在两端之间的连接，不管是何种网络类型 (通常用在视频或语音聊天)。 
这个协议让两端能够互相找到对方并建立一个连接，即便它们都使用了网络地址转译 ({{glossary(“NAT”)}}) 去跟内网的其他设备共享了一个公网 IP 地址。 
这个框架的算法是寻找最低等待时间的路径去连接两端，通常采用以下顺序寻找： 
直接的 UDP 连接 (在且仅在这种情况下，一个{{glossary(“STUN”)}}的服务器会被用来查找主机端面向网络的地址)。 
直接的 TCP 连接，通过 HTTP 端口 
直接的 TCP 连接，通过 HTTPS 端口 
间接的连接通过中继器／{{glossary(“TURN”)}}服务器 (如果一个直接连接失败了，比如当一个主机端位于防火墙之后阻止了 NAT 穿越) 学习更多 
通用知识 
WebRTC, 重要的使用 ICE 的网络相关协议 WebRTC 协议 
技术参考 
{{rfc(“5245”)}}, ICE 的 IETF 详细说明书 
{{domxref(“RTCIceCandidate”)}}, ICE candidate 的展现接口 

{{GlossarySidebar}} 
集成编程开发环境 (Integrated Development Environment) 或交互式开发环境，是为程序员提供了软件开发所需的完善工具链的软件应用。 
一个 IDE 通常包含一个代码编辑器，自动编译工具和一个调试器。 
General knowledge 
IDE on Wikipedia 

{{GlossarySidebar}} 
一个 HTTP 方法是幂等的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。 
换句话说就是，幂等方法不应该具有副作用（统计用途除外）。 
在正确实现的条件下， {{HTTPMethod(“GET”)}} ， {{HTTPMethod(“HEAD”)}} ， {{HTTPMethod(“PUT”)}} 和 {{HTTPMethod(“DELETE”)}} 等方法都是幂等的，而 {{HTTPMethod(“POST”)}} 方法不是。 
所有的 {{glossary(“safe”)}} 方法也都是幂等的。 
幂等性只与后端服务器的实际状态有关，而每一次请求接收到的状态码不一定相同。 
例如，第一次调用 {{HTTPMethod(“DELETE”)}} 方法有可能返回 {{HTTPStatus(“200”)}} ，但是后续的请求可能会返回 {{HTTPStatus(“404”)}} 。 
{{HTTPMethod(“DELETE”)}} 的言外之意是，开发者不应该使用 DELETE 法实现具有删除最后条目功能的 RESTful API。 
需要注意的是，服务器不一定会确保请求方法的幂等性，有些应用可能会错误地打破幂等性约束。 
连续调用多次，客户端接收到的结果都是一样的： GET /pageX HTTP/1.1 GET /pageX HTTP/1.1 
GET /pageX HTTP/1.1 GET /pageX HTTP/1.1 
POST /add_row HTTP/1.1 不是幂等的。 如果调用多次，就会增加多行记录： 
POST /add_row HTTP/1.1 
POST /add_row HTTP/1.1 -> Adds a 2nd row 
POST /add_row HTTP/1.1 -> Adds a 3rd row 
DELETE /idX/delete HTTP/1.1 是幂等的，即便是不同请求之间接收到的状态码不一样： 
DELETE /idX/delete HTTP/1.1 -> Returns 200 if idX exists 
DELETE /idX/delete HTTP/1.1 -> Returns 404 as it just got deleted 
DELETE /idX/delete HTTP/1.1 -> Returns 404 
基本知识 
在 HTTP 协议中幂等的定义。 技术知识 
常见的幂等方法： {{HTTPMethod(“GET”)}} ， {{HTTPMethod(“HEAD”)}} , {{HTTPMethod(“PUT”)}} ， {{HTTPMethod(“DELETE”)}} ， {{HTTPMethod(“OPTIONS”)}} 
常见的非幂等方法： {{HTTPMethod(“POST”)}} 

{{GlossarySidebar}} 
标识符是代码中用来标识{{glossary(“variable”,“变量”)}}、{{glossary(“function”,“函数”)}}或{{glossary(“property”,“属性”)}}的字符序列。 
在 {{glossary(“JavaScript”)}} 中，标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。 
标识符与字符串不同之处在于字符串是数据，而标识符是代码的一部分。 
在 JavaScript 中，无法将标识符转换为字符串，但有时可以将字符串解析为标识符。 
了解更多 
基本知识 
Identifier on Wikipedia 

{{GlossarySidebar}} 
IIFE（立即调用函数表达式）是一个在定义时就会立即执行的 {{glossary(“JavaScript”)}} {{glossary(“function”,“函数”)}}。 
IIFE 这个名字是由 Ben Alman 在他的博客中提出的。 
(function () { 
// … 
})(); 
(() => { 
// … 
})(); 
(async () => { 
// … 
})(); 
它是一种设计模式，也被称为{{glossary(“Self-Executing Anonymous Function”, “自执行匿名函数”)}}，主要包含两部分： 
第一部分是一个具有词法作用域的匿名函数，并且用{{jsxref(“Operators/Grouping”, “圆括号运算符”, ““, 1)}} () 运算符闭合起来。 
这样不但阻止了外界访问 IIFE 中的变量，而且不会污染全局作用域。 
第二部分创建了一个立即执行函数表达式 ()，通过它，JavaScript 引擎将立即执行该函数。 
示例 
避免污染全局命名空间 
因为我们的程序可能包括很多来自不同源文件的函数和全局变量，因此限制全局变量的数量非常重要。 
如果我们有一些不再使用的初始化代码，我们可以使用 IIFE 模式。 
由于我们不会再次重用代码，因此在这种情况下使用 IIFE 会比使用函数声明或者函数表达式更好。 
(() => { 
// 初始化代码 
let firstVariable; 
let secondVariable; 
})(); 
// firstVariable 和 secondVariable 变量在函数执行后会被丢弃 
执行一个异步函数 
async IIFE 允许你在比较旧的浏览器或者 JavaScript 运行环境没有顶层 await 中使用 await 和 for-await： 
const getFileStream = async (url) => { 
// 执行部分 
}; 
(async () => { 
const stream = await getFileStream("https://domain.name/path/file.ext"); 
for await (const chunk of stream) { 
console.log({ chunk }); 
} 
})(); 
模块模式 
我们也可以使用 IIFE 来创建私有和公有变量、方法。 
对于模块模式的更复杂用法和 IIFE 的其他用途，你可以参考 Addy Osmani 的《Learning JavaScript Design Patterns》这本书。 
const makeWithdraw = (balance) => { 
((copyBalance) => { 
let balance = copyBalance; // 这个变量是私有的 
const doBadThings = () => { 
console.log("I will do bad things with your money"); 
}; 
doBadThings(); 
return ( 
withdraw(amount) { 
if (balance >= amount) { 
balance -= amount; 
return balance; 
} 
return "Insufficient money" 
}, 
); 
})(balance); 
const firstAccount = makeWithdraw(100);// "I will do bad things with your money" 
console.log(firstAccount.balance); // undefined 
console.log(firstAccount.withdraw(20)); // 80 
console.log(firstAccount.withdraw(30)); // 50 
console.log(firstAccount.doBadThings); // undefined; this method is private 
const secondAccount = makeWithdraw(20); // "I will do bad things with your money" 
console.log(secondAccount.withdraw(30)); // "Insufficient money" 
console.log(secondAccount.withdraw(20)); // 0 } 
ES6 之前在 For 循环中使用 var 
在 ES6 引入 let 和 const 声明和块级作用域之前，我们可以在一些旧代码中看到 IIFE 的以下用法。 
通过 var 声明变量，只有函数作用域和全局作用域。 
假设我们创建两个按钮，文本按钮 0 和按钮 1，并且当我们点击它们时，想让它们 alert 0 和 1。 
下面的代码不能起作用： 
for (var i = 0; i < 2; i++) { 
const button = document.createElement("button"); 
button.innerText = `Button ${i}`; 
button.onclick = function () { 
console.log(i); 
}; 
document.body.appendChild(button); 
} 
console.log(i); // 2 
当点击时，按钮 0 和按钮 1 都会 alert 2，因为 i 是全局的，并且值为 2。 
在 ES6 之前为了解决这个问题，我们可以使用 IIFE 模式： 
for (var i = 0; i < 2; i++) { 
const button = document.createElement("button"); 
button.innerText = `Button ${i}`; 
button.onclick = (function (copyOfI) { 
return () => { 
console.log(copyOfI); 
}; 
})(i); 
document.body.appendChild(button); 
} 
console.log(i); // 2 
当点击时，按钮 0 和按钮 1 会 alert 0 和 1，变量 i 是全局的。 
更简单的是使用 let 声明变量： 
for (let i = 0; i < 2; i++) { 
const button = document.createElement("button"); 
button.innerText = `Button ${i}`; 
button.onclick = function () { 
console.log(i); 
}; 
document.body.appendChild(button); 
} 
console.log(i); // Uncaught ReferenceError: i is not defined. 
当我们点击按钮时，会 alert 0 和 1。 
参见 
立即调用函数表达式（维基百科） 
术语表 
{{Glossary(“Function”, “函数”)}} 
{{Glossary(“Self-Executing Anonymous Function”, “自执行匿名函数”)}} 

{{GlossarySidebar}} 
不可变值指的是，如果不创建一个全新的值替换它，它的内容是无法更改的。 
在 {{glossary(“JavaScript”)}} 中，{{Glossary(“primitive”, “原始值”)}}是不可变的——一旦创建了原始值，它就不能被改变，尽管持有它的变量可以被重新分配另一个值。 
相比之下，{{Glossary(“Object”,“对象”)}}和{{Glossary(“Array”,“数组”)}}默认是可变的——它们的属性和元素可以在不重新分配新值的情况下更改。 
由于以下几个原因，使用不可变的对象可能是有益的： 
提高性能（不计划将来更改对象） 
为了减少内存使用（进行{{glossary(“object reference”,“对象引用”)}}，而不是克隆整个对象） 
线程安全（多个线程可以引用同一对象，而不会相互干扰） 
降低开发人员的精神负担（对象的状态不会改变，其行为始终是一致的） 
注意，你可以很容易证明可变性：只要对象提供一种方式来更改其属性，它就是可变的。 
另一方面，如果没有语言语义来保护它，就很难证明不可变性——这是一个开发人员约定俗成的问题。 
例如，{{jsxref(“Object.freeze()”)}} 是一种语言层面的方法，用于使对象在 JavaScript 中不可变。 
参见 
在维基百科中的不可变对象 
{{glossary(“Mutable”, “可变”)}} 

{{GlossarySidebar}} 
IndexedDB 是一个用于在浏览器中储存较大数据结构的 Web {{glossary(“API”)}}, 并提供索引功能以实现高性能查找。 
像其他基于 {{glossary(“SQL”)}} 的 关系型数据库管理系统 (RDBMS) 一样，IndexedDB 是一个事务型的数据库系统。 
然而，它是使用 {{glossary(“JavaScript”)}} 对象而非列数固定的表格来储存数据的。 
了解更多 
MDN 页面 {{domxref(‘IndexedDB_API’,‘IndexedDB API’,’’,1)}} 
The W3C specification for IndexedDB 

{{GlossarySidebar}} 
Web 技术文档和代码中含有大量的术语和缩写。 
本术语表给出了可以帮助你正确理解并运用于 Web 开发所需要的名词与缩写，以及它们的定义。 
你可以从侧边栏中选择术语表中的词汇。 
备注： 编辑术语表是一项永无止境的工作，你可以添加新的条目或改进、完善现有条目。 

{{GlossarySidebar}} 
应用于 web 设计和开发的信息架构是组织一个 web 站点的信息、内容和功能的实践，信息和服务的易使用和易查找使得它能提供最好的用户体验。 了解更多 
基本知识 
Information architecture on Wikipedia 

{{GlossarySidebar}} 
在 CSS 中，参与行内布局的内容被称为行级内容（inline-level content）。 
默认情况下，大多数文本、替换元素以及生成的内容都是行级的。 
在行内布局中，通常将文本、替换元素以及其它的行级盒分段为一堆按顺序排列的盒子来进行布局。 
在每个行盒中，行级盒子相互垂直或者水平对齐，具体取决于书写模式。 
通常，它们与文本的基线进行对齐。 
这可以使用 CSS 进行更改。 
行内布局 
备注： HTML（超文本标记语言）元素历来被归类为“块级”元素或者“行级”元素。 
作为一种呈现的特性，现在这将由 CSS 来提供。 
示例 
<p> 
This span is an <span class="highlight">inline-level element</span>; its 
background has been colored to display both the beginning and end of the 
element's influence. 
Input elements, like <input type="radio" /> and 
<input type="checkbox" />, are also inline-level content. 
</p> 
在该示例中，{{HTMLElement(“p”)}} 元素包含一些文本。 
在该文本中有一个 {{HTMLElement(“span”)}} 元素和两个 {{HTMLElement(“input”)}} 元素，它们都是行级元素。 
如果，<span> 分布在不同的行上，则会生成两个行盒。 
因为这些元素是行内的，该段落只会渲染为不间断文本流的单个段落： 
```css hidden body { margin: 0; padding: 4px; border: 1px solid #333; } 
.highlight { background-color: #ee3; } ``` 
{{EmbedLiveSample(“示例”)}} 
参见 
块级内容 
行内格式上下文 
{{cssxref(“display”)}} 

{{GlossarySidebar}} 
输入法编辑器 (IME) 是一种程序，可为文本输入提供专门的用户界面。 
输入法编辑器在许多情况下使用： 
使用拉丁键盘输入中文，日文或韩文文本 
使用数字键盘输入拉丁文字 
使用手写识别在触摸屏上输入文本 
参见 
Input method 
词汇表 
{{Glossary(“I18N”)}} 

{{GlossarySidebar}} 
一个对象，由构造函数所创建的实例 了解更多 
知识 
实例 - 维基百科 

{{GlossarySidebar}} 
互联网是由全世界众多网络连接而成的网络，使用了互联网协议族（也根据它两个最重要的 {{glossary(“protocol”,“协议”)}} 称之为 {{glossary(“TCP”)}}/{{glossary(“IPv6”,“IP”)}}）。 了解更多 
了解它 
互联网是如何工作的（给初学者的介绍） 

{{GlossarySidebar}} 
IP 地址是一个数字，用于对 IP 网络上的每台设备进行唯一的定位。 
IP 代表互联网协议（Internet Protocol），是与地址相关的协议层。 
在更广泛地使用 IPv6 之前，“IP 地址”通常仍指 32 位 IPv4 地址。 
参见 
维基百科上的 IP 地址词条 

{{GlossarySidebar}} 
IPv6 是当前版本的互联网（{{glossary(“Internet”)}}）通信协议（{{glossary(“protocol”)}}）。 
IPv6 正在慢慢地取代 {{Glossary(“IPv4”)}}，因为 IPv6 允许使用更多不同的 {{Glossary(“IP address”,“IP 地址”)}}。 了解更多 
基本知识 
IPv6 on Wikipedia 

{{GlossarySidebar}} 
IRC (Internet Relay Chat 因特网中继聊天) 是一个基于互联网连接和 IRC 客户端的全球聊天系统，其通过 IRC 服务器收发消息。 
由 Jarrko Oikarinen 在 20 世纪 80 年代末设计出，IRC 使用 {{glossary(“TCP”)}} ，这是一个开放的协议。 
IRC 服务器将消息广播给每个连接到多个 IRC 通道 (每个通道都有自己的 ID) 中的一个的人。 学习更多 IRC 起步 在 Mozilla 上使用 IRC 

{{GlossarySidebar}} 
互联网服务供应商（Internet Service Provider，简称 ISP）通过电话线上的拨号连接（这在以前比较常见），或宽带连接（如电缆调制解调器或 DSL 服务）出售互联网接入服务，有时也会提供其他服务，如电子邮件、虚拟主机和 IP 语音。 了解更多 
补充知识 
互联网是如何工作的（给初学者的说明） 
互联网服务供应商（中文维基百科） 

{{GlossarySidebar}} 
Jank既指“卡顿”表现，通常是由于在主线程上执行长任务，阻止渲染或在后台进程上消耗过多处理器能力所致。 

{{GlossarySidebar}} 
Java 是一个旨在实现最小的依赖关系的基于{{Glossary(“class”,“类”)}}的 {{glossary(“OOP”, “面向对象的”)}} 便携式 {{Glossary(“computer programming”, “计算机程序”)}} 语言。 
了解更多 
基础知识 

{{GlossarySidebar}} 
JavaScript (JS) 是一种编程语言，为通常用于客户端（client-side）的网页动态脚本，不过，也常通过像Node.js这样的包，用于服务器端（{{Glossary(“Server”,“server”)}}-side）。 
不应该把 JavaScript 和 Java 混淆。“ 
Java”和“JavaScript”都是 Oracle 公司在美国和其他国家注册的商标，但是这两种编程语言在语法、语义和使用方面都明显不同。 
Brendan Eich（彼时受雇于 Netscape）为服务器端构想的语言 JavaScript，不久便在 1995 年 9 月被加入 Netscape Navigator 2.0。 
JavaScript 很快获得了成功，而 {{glossary(“Microsoft Internet Explorer”, “Internet Explorer 3.0”)}} 也在 1996 年 8 月，引入了对 JavaScript 的支持，冠以 JScript 之名。 
1996 年 11 月，Netscape 开始与 ECMA 国际化组织合作以使 JavaScript 成为行业标准。 
从此以后，标准化的 JavaScript 就被称为 ECMAScript 并由 ECMA-262 规范，其最新版（第八版）在 2017 年 6 月生效。 
JavaScript 通常用于浏览器，使开发者能通过{{Glossary(“DOM”)}}来操纵网页内容、或透过{{Glossary(“AJAX”)}}与{{Glossary(“IndexedDB”)}}来操作数据；还可以用它在{{Glossary(“canvas”)}}上面绘图、通过各种{{Glossary(“API”,“APIs”)}}与运行浏览器的各种设备交互……等等。 
由于近年来的发展、以及各浏览器的{{Glossary(“API”,“APIs”)}}性能改善，JavaScript 成了世界上最常用的编程语言之一。 
最近，JavaScript 的流行程度，随着除浏览器外最流行的跨平台 JavaScript 运行环境——Node.js 平台的成功而大大提升。 
Node.js 使开发者可以在 PC 上使用 JavaScript 作为脚本语言以自动化处理和构建功能完备的 {{Glossary(“HTTP”)}} 和 {{Glossary(“Web Sockets”)}} 服务器。 了解更多 
基本知识 
维基百科上的JavaScript 
学习 JavaScript 
MDN 的 JavaScript 指南 
NodeSchool 的 javascripting 工坊 
codecademy.com 的 JavaScript 课程 
John Resig 的 Learning Advanced JavaScript 
John Resig 的 Learning Advanced JavaScript 

{{GlossarySidebar}} 
它能够轻松地处理 16.8M 颜色，可以很好地再现全彩色的图像。 
以下是对于 8 位/像素的中等复杂画面的图像，JPEG 所给出的几个等级作为衡量压缩编码效果的准则： 0.25 位/像素~0.5 位/像素；中~好，足以满足一些应用。 
0.5 位/像素~0.75 位/像素；好~很好，足以满足许多应用。 0.75 位/像素~1.5 位/像素；优秀，足以满足大多数应用。 
1.5 位/像素~2.0 位/像素；难于与原图像区别，足以满足绝大多数应用。 >2.0 位/像素；近乎完美，满足几乎全部的应用。 
常识 
在百度百科上的 jpeg 

{{GlossarySidebar}} 
JavaScript Object Notation (JSON) 是一种数据交换格式。 
尽管不是严格意义上的子集，JSON 非常接近 {{Glossary(“JavaScript”)}} 语法的子集。 
许多编程语言都支持 JSON，尤其是 JavaScript，它在网站和浏览器扩展应用广泛。 
JSON 不支持复杂的数据类型（函数、正则表达式、日期等）。 日期对象默认会转化为 ISO 格式的字符串，因此信息不会完全丢失。 
如果你需要使用 JSON 来表示复杂的数据类型，请在它们转化为字符串值。 
与 XML 非常相似，JSON 能存储 CSV 格式，同时保留它的分级信息。 
有许多工具能帮助你进行格式转换（例如 JSON to CSV Converter 或JSON to CSV Converter）。 
详细了解 
JSON （维基百科） 
JSON（MDN） 

{{GlossarySidebar}} 
密钥是一段用于 {{Glossary(“cipher”, “密码算法”)}}{{Glossary(“encryption”,“加密”)}}和/或{{Glossary(“decryption”,“解密”)}}的信息。 
经加密的消息需要保证即使{{Glossary(“cryptosystem”,“密码体制”)}}中除了密钥外的其他部分在公开可见的情况下，依然保持安全性。 
在{{Glossary(“symmetric-key cryptography”, “对称密钥加密算法”)}}中，加密与解密过程使用同样的密钥。 
在{{Glossary(“public-key cryptography”, “公钥加密算法”)}}中，存在一对相互关联的公钥和私钥，公钥可以公开获取，私钥需要保密。 
公钥加密的消息，只有对应的私钥才能解密，反之亦然。 
参见 
维基百科上的柯克霍夫原则词条 
MDN 术语表 
{{Glossary(“Block cipher mode of operation”)}} 
{{Glossary(“Cipher”,“密码”)}} 
{{Glossary(“Ciphertext”,“密文”)}} 
{{Glossary(“Cipher suite”, “密码套件”)}} 
{{Glossary(“Cryptanalysis”, “密码分析”)}} 
{{Glossary(“Cryptography”, “密码学”)}} 
{{Glossary(“Decryption”, “解密”)}} 
{{Glossary(“Encryption”, “加密”)}} 
{{Glossary(“Key”,“密钥”)}} 
{{Glossary(“Plaintext”,“明文”)}} 
{{Glossary(“Public-key cryptography”, “非对称密钥算法”)}} 
{{Glossary(“Symmetric-key cryptography”, “对称密钥算法”)}} 

{{GlossarySidebar}} 
关键字是用以描述内容的词汇或短语。 
网上的关键字在搜索引擎中用于搜索或者作为识别网站内容的词汇。 
在使用搜索引擎的时候，你可以用关键字指定搜寻内容，搜索引擎会返回相关网页。 
想获得更精确的结果，尝试用更具体的关键字，比如用 “Blue Mustang GTO” 而不是简单的一个”Mustang”.。 
网页也在 meta 标签 (在{{htmlelement(“head”)}}部分) 中使用关键字来描述页面内容，以使搜索引擎可以更好地识别和组织网页。 了解更多 
基本信息 
维基百科上的Keyword 

{{GlossarySidebar}} 
延迟是请求的资源到达其目的地所花费的网络时间。 
低延迟是好的，这意味着几乎没有延迟。 
高延迟是不好的，这意味着所请求的资源要花很长时间才能到达目的地。 
延迟可能是任何类型的数据流中的一个因素，但是最常见的讨论方式是网络延迟（数据包从源传输到目标所花费的时间）和媒体编解码器延迟（传输数据包所需的时间）。 源数据进行编码或解码，并到达结果数据的使用者）。 
更多 
理解延迟 

{{GlossarySidebar}} 
“连字”是指将两个字符组合后变为一个形状，像是法语中的“œ”就是“oe”的连字。 
你可以在网页中使用 {{cssxref(“font-variant-ligatures”)}} 来实现连字 
参见 
Ligature on Wikipedia 

{{GlossarySidebar}} 
本地化（l10n）是使软件用户界面适应特定文化环境的过程。 
以下是本地化过程中经常考虑的因素： 
语言 
计量单位（如：欧洲使用千米，而美国使用英里） 
文字方向（如：欧洲语言是从左向右书写的，而阿拉伯语是从右向左书写的） 
拉丁字母的大写行为（如：英语用大写字母表示工作日，西班牙语使用小写字母） 
情感表达（如：日语的敬语体系与休闲语有很大的不同） 
数字格式（如：德国使用 10 000,00，而美国使用 10,000.00） 日期格式 货币 文化参照 纸张大小 颜色心理 符合当地法律 本地节日 人名 参见 维基百科上的本地化词条 

{{GlossarySidebar}} 
LTR（从左到右，Left To Right）是{{Glossary(“locale”, “区域设置”)}}的属性之一，用于指示语言从左到右的书写方向。 
例如，使用美式英语的 en-US 区域就是从左到右的书写方向。 
大多数西方语言，如同世界上的其他语言一样，都是从左向右书写的。 
与 LTR 相对的是 {{Glossary(“RTL”)}}（从右到左，Right To Left），在另一些语言中常用，例如阿拉伯语（ar）和希伯来语（he）。 
参见 
MDN Web 文档术语 
{{Glossary(“locale”)}} 
{{Glossary(“Localization”, “本地化”)}} 
{{Glossary(“LTR”, “LTR（从左到右）”)}} 
{{Glossary(“RTL”, “RTL（从右到左）”)}} 
HTML 全局属性 
dir 
lang 
CSS 
{{cssxref(“:dir”)}} 
{{cssxref(“direction”)}} 
{{cssxref(“unicode-bidi”)}} 
{{cssxref(“writing-mode”)}} 

{{GlossarySidebar}} 
{{glossary(“flexbox”, “弹性盒”)}}的主轴（main axis）由 {{cssxref(“flex-direction”)}} 属性设置的方向所定义。 
flex-direction 有四个取值，分别是： 
row 
row-reverse 
column 
column-reverse 
假如选择 row 或者 row-reverse，那么主轴会沿行向延伸。 
此图中 flex-direction 为 row，由此构成主轴 
选择 column 或者 column-reverse，那么主轴会沿块向从页面上侧延伸到下侧。 

{{GlossarySidebar}} 
主线程用于浏览器处理用户事件和页面绘制等。 
默认情况下，浏览器在一个线程中运行一个页面中的所有 JavaScript 脚本，以及呈现布局，回流，和垃圾回收。 
这意味着一个长时间运行的 JavaScript 会阻塞线程，导致页面无法响应，造成不佳的用户体验。 
除非故意使用 web worker，比如 service worker，不然 JavaScript 只在线程中运行，所以脚本的运行时，很容易导致事件处理流程或绘制的延迟。 
主线程中运行的工作越少，就有越多的余地来处理用户事件，页面绘制和对用户保持响应。 
参见 
另可参考 异步 JavaScript 
Web worker API 
Service worker API 
词汇表 
{{Glossary(“Thread”)}} 

{{GlossarySidebar}} 
MathML（{{glossary(“XML”)}} 的应用之一）是一种在网页中表示数学表达式的开放标准。 
在 1998 年 W3C 首次推荐使用 MathML 以在{{glossary(“browser”, “浏览器”)}}中表示数学表达式。 
MathML 的其他应用包括科学内容和语音合成。 
参见 
维基百科上的 MathML 
MathML 
编写 MathML 
什么是 MathML 

{{GlossarySidebar}} 
Metadata——元数据，简单的来说就是描述数据的数据。 
例如，一个 {{glossary(“HTML”)}} 文件是一种数据，但 HTML 文件也能在 {{htmlelement(“head”)}} 元素中包含描述该文档的元数据，比如该文件的作者和概要。 更多相关内容 
通俗释义 
metadata 来自维基百科 
HTML 中的 metadata 元素 
{{htmlelement(“meta”)}} 来自 MDN 

{{GlossarySidebar}} 
一个方法就是一个函数，是对象的属性之一。 
有两种类型的方法：实例方法是由对象实例执行的内置任务，另一种是静态方法，在对象构造函数内直接调用的任务。 

{{GlossarySidebar}} 
Microsoft Edge 是由微软公司在 2014 年开发的免费{{glossary(“World Wide Web”, “网络”)}}图形{{Glossary(“browser”,“浏览器”)}}，捆绑于 Windows 10 操作系统中。 
Edge 最初被称为 Spartan，它取代了长期存在的 {{glossary(“Microsoft Internet Explorer”,“Internet Explorer”)}} 浏览器。 
参见 
官方网站 
MDN Web 文档术语表 
{{Glossary(“Google Chrome”)}} 
{{Glossary(“Microsoft Edge”)}} 
{{Glossary(“Microsoft Internet Explorer”)}} 
{{Glossary(“Mozilla Firefox”)}} 
{{Glossary(“Netscape Navigator”)}} 
{{Glossary(“Opera Browser”)}} 

{{GlossarySidebar}} 
Internet Explorer（或 IE）是一个免费的图形{{glossary(“browser”,“浏览器”)}}，曾经由微软为企业用户维护。 目前，{{glossary(“Microsoft Edge”)}} 是 Windows 默认的浏览器。 
微软在 1995 年首次将 IE 和 Windows 捆绑，作为“Microsoft Plus!” 包的一部分出售。 
在大约 2002 年时，Internet Explorer 已经成了世界上使用最多的浏览器，但目前已经落后于 Chrome、Firefox、Edge 和 Safari。 
IE 经历了许多版本，并为桌面、手机和 Xbox 控制台提供了版本。 
它也可以在 Mac 和 UNIX 上使用，微软分别在 2003 年和 2001 年停止了这些版本。 
最后的 Windows 版本是 2020 年 11 月 10 日的 Windows 11.0.220。 
微软于 2022 年 6 月 15 日结束对 IE 的支持。 
参见 
Internet Explorer 维基百科 
Internet Explorer 的历史维基百科 
Internet Explorer 版本维基百科 

{{GlossarySidebar}} 
MIME type （现在称为“媒体类型 (media type)”，但有时也是“内容类型 (content type)”）是指示文件类型的字符串，与文件一起发送（例如，一个声音文件可能被标记为 audio/ogg ，一个图像文件可能是 image/png ）。 
它与传统 Windows 上的文件扩展名有相同目的。 学习更多 
基础知识 
Internet media type on Wikipedia 
技术参考 
MIME types 列表 
正确配置服务器 MIME Types 
有关在 Web 环境中使用 MIME Types 的详细信息。 

{{GlossarySidebar}} 
中间人攻击（Man-in-the-middle attack，MitM）会在消息发出方和接收方之间拦截双方通讯。 
举例来说，Wi-Fi 路由器就可以被破解用来进行中间人攻击。 
用日常生活中的写信来类比的话：你给朋友写了一封信，邮递员可以把每一份你寄出去的信都拆开看，甚至把信的内容改掉，然后重新封起来，再寄出去给你的朋友。 
朋友收到信之后给你回信，邮递员又可以拆开看，看完随便改，改完封好再送到你手上。 
你全程都不知道自己寄出去的信和收到的信都经过邮递员这个“中间人”转手和处理——换句话说，对于你和你朋友来讲，邮递员这个“中间人”角色是不可见的。 
对于实际生活中的信件沟通和线上的信息交流来说，中间人攻击都是很难防范的，这里有一些小建议： 
不要忽视浏览器弹出的证书警告！ 
你可能访问的是钓鱼网站或者假冒的服务器； 
公共网络环境下（例如公共 WiFi），没有 HTTPS 加密的敏感网站不要随便登录，一般不可信； 
在任何网站上登录自己的账号前确保网址为 HTTPS 加密协议； 
参见 
OWASP 文章：Man-in-the-middle attack 
PortSwigger：最新的中间人攻击新闻 
维基百科：中间人攻击 

{{GlossarySidebar}} 
混合（mixin）是一个 {{Glossary(“class”)}} 或者 {{Glossary(“interface”)}}，其中部分或全部{{Glossary(“method”, “methods”)}}与{{Glossary(“property”, “properties”)}}未实现，需要另一个{{Glossary(“class”)}}或者{{Glossary(“interface”)}}来提供这些缺失的实现。 
新的类或者接口包括混合所有的以及自有的属性和方法。 
所有方法和属性的使用方法在混合或混合的实现中保持一致。 
混合的优点在于：可用于简化多个接口需要包含相同的方法何与属性的 API 的设计。 
例如，WindowOrWorkerGlobalScope 混合用于提供需要在{{domxref(“Window”)}}与{{domxref(“WorkerGlobalScope”)}}上都可用的方法和属性。 
该混合由这两个接口实现。 
更多 
基础知识 

{{GlossarySidebar}} 
Mozilla Firefox 是一个免费的开源{{Glossary(“browser”, “浏览器”)}}，其开发工作由 Mozilla 公司负责监督。 
Firefox 可在 Windows、OS X、Linux 和 Android 平台下运行。 
Firefox 于 2004 年 11 月首次发布，可通过主题、插件和附加组件完全定制。 
火狐浏览器使用 {{glossary(“Gecko”)}} 来渲染网页，并实现了当前和未来的 {{glossary(“world wide web”, “Web”)}} 标准。 
参见 
Mozilla Firefox 官方网站 
MDN 上的 Firefox 开发者文档 

{{GlossarySidebar}} 
可变指即使没有创建一个全新的值，也可以更改它。 
在 {{glossary(“JavaScript”)}} 中，{{Glossary(“Object”,“对象”)}}和{{Glossary(“Array”,“数组”)}}默认都是可变的，但是{{Glossary(“primitive”, “原始值”)}}是不可变的——一旦创建原始值，它就不能被更改，尽管持有它的变量可能会再次重新分配到其它值。 
参见 
维基百科上的不可变对象 
{{glossary(“Immutable”,“不可变”)}} 

{{GlossarySidebar}} 
MVC (Model-View-Controller) 是一种软件设计模式。 
它强调分离软件的业务逻辑和显示。 
这种“分离”提供了更好的分工和改进的维护。 
一些其他的模式也是基于 MVC 来设计的，像 MVVM (Model-View-Viewmodel), MVP (Model-View-Presenter), 和 MVW (Model-View-Whatever). 
对 MVC 软件设计模式的三个部分可以被描述如下： 
Model: 模型持有所有的数据、状态和程序逻辑。 
View: 负责界面的布局和显示。 
Controller: 负责模型和界面之间的交互。 
参见 
维基百科上的 MVC 模式词条 

{{GlossarySidebar}} 
NaN(不是一个数字) 是一种数值表达形式 {{Glossary(“Type”, “data type”)}}这意味一种未定义的值或者不能够被描述的值，尤其浮点型结算的结果。 
举例，NaNs 能够描述无穷大，数字除 0 的结果，缺少值，或者平方根为负数（这是虚构的，而浮点数是真实的）。 
实际上，如果我在{{glossary(“JavaScript”)}} 程序中划分两个变量，结果可能是 NaN，它在 JavaScript 中被预定义为“undefined”。 
于是这个除法可能中断程序。 
现在，如果这个计算是一个大规模算法的一小部分，那么确定错误实际发生的地方真的很困难。 
幸运的是，由于结果将是 NaN，我知道我的除数可能会变为 0，我可以设置防止任何此类计算的测试条件，或通知我发生的位置。 
学习更多 
通常的知识点 
权威的信息 

{{GlossarySidebar}} 
NAT (网络地址翻译) 是一个能够让多台主机共享一个 IP 地址的技术。 
NAT 会给局域网内每台主机分配一个唯一的地址同时调整输入和输出的网络流量，使之能够发送到正确的位置。 
学习更多 
通用知识 
WebRTC 协议 NAT 在 Wikipedia 

{{GlossarySidebar}} 
一个原生的应用程序在被编译后，可以在由指定结构组成的硬件/软件环境中运行 
原生安卓应用的一个例子：在安卓工具链的支持下使用 Java 编写的手机应用 
从另一方面来讲，一个在浏览器中运行的网页应用就不是原生——其必须运行在基于原生环境的浏览器中，而不是在原生环境本身。 了解更多 
常规知识 
维基百科上的 Native (computing) 

{{GlossarySidebar}} 
{{Glossary(“CSP”)}} 浏览指令（navigation directives）出现于 {{HTTPHeader(“Content-Security-Policy”)}} 首部，支配着用户所能浏览的或者提交表单的资源位置。 
浏览指令不将 {{CSP(“default-src”)}} 指令作为回退机制。 
以下 CSP 指令属于浏览指令： 
{{CSP(“form-action”)}} 
{{CSP(“frame-ancestors”)}} 
{{CSP(“navigation-to”)}} 更多内容 
{{HTTPHeader(“Content-Security-Policy”)}} 
其他类型的指令： 
{{Glossary(“Fetch directive”)}} 
{{Glossary(“Navigation directive”)}} 
{{Glossary(“Reporting directive”)}} 

{{GlossarySidebar}} 
在 {{Glossary(“DOM”)}} 的上下文中，节点（Node）是节点树中的单个点。 
包括文档本身、元素、文本以及注释都属于是节点。 
参见 
WHATWG 规范 node tree 
Node 对象 

{{GlossarySidebar}} 
术语节点（Node）根据不同的上下文，可以是多种不同的意思。 
它可能是： 
{{GlossaryDisambiguation}} 
这个词的另一个含义，我们将在 {{Glossary(“Node.js”)}} 中讨论。 

{{GlossarySidebar}} 
Node.js 是一个跨平台 {{Glossary(“JavaScript”)}} 运行环境，使开发者可以搭建服务器端的 JavaScript 应用程序。 
了解更多 
常识 
Node.js 的维基 
Node.js 官网 
技术信息 API 文档 
教程 
{{QuickLinksWithSubpages(“/zh-CN/docs/Glossary”)}} 

{{GlossarySidebar}} 
在网络中，节点是网络中的一个连接点。 
在物理网络中，节点通常是一个设备，如计算机或路由器。 
参见 
维基百科上的节点 

{{GlossarySidebar}} 
在计算机学科，null 值一直是一个被讨论点，通常来说，表示一个不存在或者无效{{glossary(“object”)}}或者地址引用。 
语言实现中空引用的含义各不相同。 
在 {{Glossary(“JavaScript”)}}，null 是{{Glossary(“Primitive”, “原始值”)}}之一 
了解更多 
一般知识 
维基百科空指针 
技术参考 
JavaScript 数据类型和数据结构 
JavaScript 全局对象：{{jsxref(“null”)}} 

{{GlossarySidebar}} 
在 JavaScript 中，一个空值（nullish value）要么是 null，要么是 {{JSxRef(“undefined”)}}。 
空值总是假值。 

{{GlossarySidebar}} 
在 {{Glossary(“JavaScript”)}} 中，Number 是一种 定义为 64 位双精度浮点型（double-precision 64-bit floating point format） (IEEE 754)的数字数据类型。 
在其他编程语言中，有不同的数字类型存在，比如：整型（Integers），单精度浮点型（Floats），双精度浮点型（Doubles），大数（Bignums）。 
了解更多 
基础知识 
维基百科上的数字类型 
技术参考 
JavaScript 数据结构：Number 
JavaScript 全局对象 {{jsxref(“Number”)}} 

{{GlossarySidebar}} 
对象 指包含数据和用于处理数据的指令的数据结构。 
对象有时也指现实世界中的一些事，例如在赛车游戏当中一辆车或者一幅地图都可以是一个对象。{{ 
glossary(“JavaScript”)}}, Java, C++, Python, 还有 Ruby 这些例子都是{{glossary(“OOP”,“面向对象的程序设计”)}} 语言。 
了解更多 
常用的知识点 Object-oriented programming on Wikipedia 
{{jsxref(“Object”)}} in the JavaScript reference 

{{GlossarySidebar}} 
OOP（面向对象编程）是一种编程方法，其中数据封装在{{glossary(“object”,“对象”)}}中，对象本身在其上运行，而不是其组成部分。 
{{glossary(“JavaScript”)}} 是高度面向对象的。 
它遵循基于原型的模型（与基于类的模型相反）。 了解更多 
常识 
维基百科：Object-oriented programming 
JavaScript 面向对象简介 

{{GlossarySidebar}} 
OpenGL (Open Graphics Library)是一套用来渲染 2D 和 3D 矢量图形的跨语言的、跨平台的应用程序接口 (API) . 
这种接口通常用来与图形处理单元 (GPU) 交互，来达到硬件加速渲染的目的。 

{{GlossarySidebar}} 
由标点符号或字母数字字符组成的保留语法，执行内置功能。 
例如，JavaScript 的加法运算符（“+”）可以将数字相加或者将字符串连接起来，而“非”运算符（“!”） 
可以对表达式取反，例如将 true 语句返回 false。 
参见 
维基百科上的运算符词条 
JavaScript 运算符 

{{GlossarySidebar}} 
Web 内容的源由用于访问它的 {{Glossary(“URL”)}} 的方案（协议）、主机名（域名）和端口定义。 
只有当协议、主机和端口都匹配时，两个对象才具有相同的源。 
某些操作仅限于同源内容，但可以使用 {{Glossary(“CORS”)}} 解除这个限制。 
示例 
由于它们具有相同的协议（http）和主机名（example.com），以下两个地址是同源的。 
http://example.com/app1/index.html 
http://example.com/app2/index.html 
服务器默认从 80 端口传送 HTTP 内容，所以以下两个地址同源： 
http://Example.com:80 
http://example.com 
由于协议不同，以下两个地址不属于同源： 
http://example.com/app1 
https://example.com/app2 
由于主机名不同，以下几个地址不属于同源： 
http://example.com 
http://www.example.com 
http://myapp.example.com 
由于端口不同，以下几个地址不属于同源： 
http://example.com 
http://example.com:8080 
参见 
同源策略。 
{{Glossary(“Site”)}} 
HTML 规范：源 

{{GlossarySidebar}} 
Parsing means analyzing and converting a program into an internal format that a runtime environment can actually run, for example the {{glossary(“JavaScript”)}} engine inside browsers. 
Parsing 就是将程序解析以及转换成能够在运行环境中运行的计算机内部格式，浏览器中的{{glossary(“JavaScript”)}} 驱动就是一个很好的解析例子。 
In JavaScript, this is done during {{glossary(“compile time”)}} or whenever the {{glossary(“parser”)}} is invoked, such as during a call to a method. 
JavaScript 中的解析过程一般在{{glossary(“compile time”)}}中完成，或者是在任意{{glossary(“parser”)}} 参与的时候完成。 
Learn more 
Parse on Wikipedia 

{{GlossarySidebar}} 
有效负荷标头（payload header）是一种 {{Glossary(“HTTP_header”, “HTTP 标头”)}}，其从一个或多个消息中描述与安全传输和原始资源{{Glossary(“Representation header”, “表示形式（representation）”)}}重建的相关的有效负荷信息。 
有效负荷标头包括：{{HTTPHeader(“Content-Length”)}}、{{HTTPHeader(“Content-Range”)}}、{{HTTPHeader(“Trailer”)}} 和 {{HTTPHeader(“Transfer-Encoding”)}}。 参见 

{{GlossarySidebar}} 
PDF（可移植文档格式）是一种能够用来在任何特定软、硬件平台或操作系统上分享文档的文件格式。 
PDF 提供打印文档的数字图像，并能在打印时保持相同的外观。 了解更多 
常识 
维基百科：PDF 

{{GlossarySidebar}} 
百分比编码 是一种拥有 8 位字符编码的编码机制，这些编码在{{Glossary(“URL”)}}的上下文中具有特定的含义。 
它有时被称为 URL 编码。 
编码由英文字母替换组成：“%”后跟替换字符的 ASCII 的十六进制表示。 
需要编码的特殊字符有： ':'，'/'，'?' 
，'#'，'['，']'，'@'，'!' 
，'$'，'&'，"'"，'('，')'，'*'，'+'，','，';'，'='，以及，'%' 本身。 
其他的字符虽然可以进行编码但是不需要。 
字符 
编码 
':' 
'/' 
'?' 

{{GlossarySidebar}} 
PHP（PHP: Hypertext Preprocessor 的递归缩写）是一个开源服务器端脚本语言，可嵌入在 HTML 中，以构建网络应用程序和动态网站。 
示例 
基本语法 
// PHP 代码的开始 
<? 
php 
// 在这里写 PHP 代码 
? 
> 
// PHP 代码的结束 
在屏幕上打印数据 
<? 
php 
echo "Hello World!" 
; 
? 
> 
PHP 变量 
<? 
php 
// 变量 
$nome='Danilo'; 
$sobrenome='Santos'; 
$pais='Brasil'; 
$email='danilocarsan@gmail.com'; 
// 打印变量 
echo $nome; 
echo $sobrenome; 
echo $pais; 
echo $email; 
? 
> 
参见 
官方网站 
维基百科上的 PHP 
维基教科书上的 PHP 
MDN Web 文档术语表 
{{Glossary(“Java”)}} 
{{Glossary(“JavaScript”)}} 
{{Glossary(“Python”)}} 
{{Glossary(“Ruby”)}} 

{{GlossarySidebar}} 
明文指的是作为{{Glossary(“encryption”, “加密”)}}{{Glossary(“algorithm”,“算法”)}}输入的信息，或者是解密后的{{Glossary(“ciphertext”, “密文”)}}。 
通常与指代任何信息（例如文本文档、图像等）的 cleartext 一词交互使用，此时信息还没有被加密，可不附加任何处理地供人类和计算机阅读。 

{{GlossarySidebar}} 
PNG（便携式网络图形）是支持无损数据压缩的图形文件格式。 
了解更多 
基础知识 

{{GlossarySidebar}} 
Polyfill 是一块代码（通常是 Web 上的 JavaScript），用来为旧浏览器提供它没有原生支持的较新的功能。 
比如说 polyfill 可以让 IE7 使用 Silverlight 插件来模拟 HTML Canvas 元素的功能，或模拟 CSS 实现 rem 单位的支持，或 {{cssxref(“text-shadow”)}}，或其他任何你想要的功能。 
了解更多 
常识 
什么是 polyfill？ 
（Remy Sharp 著，概念发明者） 

{{GlossarySidebar}} 
对于使用 {{Glossary(“IP address”, “IP 地址”)}}连接到网络的计算机，端口（port）是通信的端点。 
端口由数字指定，且在 1024 以下的每个端口默认与特定的{{Glossary(“protocol”, “协议”)}}相关联。 
例如，{{Glossary(“HTTP”)}} 协议的默认端口是 80，{{Glossary(“HTTPS”)}} 协议的默认端口是 443，因此 {{Glossary(“HTTP”)}} 服务器在这些端口上等待请求。 
每个网际协议都与一个默认端口相关联：{{Glossary(“SMTP”)}}（25）、{{Glossary(“POP”)}}（110）、{{Glossary(“IMAP”)}}（143）、{{Glossary(“IRC”)}}（194）等等。 
参见 
维基百科上的端口条目 

{{GlossarySidebar}} 
链接预取是一种浏览器机制，其利用浏览器空闲时间来下载或预取用户在不久的将来可能访问的文档。 
从 Gecko 1.9.1 (Firefox 3.5) 开始，支持获取 https 内容。 什么是预取提示？ 
浏览器会查找关系类型 (rel) 为 next 或 prefetch 的 HTML{{ HTMLElement(“link”) }} 或 HTTP Link: header。 
下面是一个使用 link 标签的例子： 
Link: header 也可以通过使用 HTML meta 标签定义在 HTML 文档中： 
<meta http-equiv="Link" content="</images/big.jpeg>; rel=prefetch"> 
<link rel="prefetch alternate stylesheet" title="Designed for Mozilla" href="mozspecific.css"> 
不会，只有带有关系类型为 next 或 prefetch 的 <link> 标签会被预拉取。 
但是，如果该特性收到足够的关注，我们在未来可能会支持带有关系类型为 next 或 prefetch 的 <a> 标签的预取。 这样做可能会帮助内容提供者避免预取内容过期的问题。 链接预取是符合规范的吗？ 
在目前 (Moilla 1.2)，空闲时间的确定是通过 nsIWebProgressListener API 实现的。 
我们在顶层 nsIWebProgress 对象 (“@mozilla.org/docloaderservice;1”) 上附加了一个监听器。 
预提取的请求是否包含 Referer: header？ 
是的，预取的请求包含一个 HTTP Referer: header，指示从中提取预取提示的文档。 
但是，可以通过指定 Cache-control: must-revalidate HTTP response header，指示 Mozilla 在用户遵循 href 到预提取文档时验证预提取文档。 
此标头可启用缓存，但在从浏览器的缓存中提供文档之前，需要 If-Modified-Since 或 If-None-Match 验证请求。 
Of course, this request header is not at all standardized, and it may change in future Mozilla releases. 
Chrome uses “X-Purpose: prefetch” or “Purpose: prefetch” header. 当然，此请求标头根本不是标准化的，并且在将来的 Mozilla 版本中可能会更改。 
Chrome 使用“X-Purpose: prefetch”或“Purpose: prefetch 的header。 
user_pref("network.prefetch-next", false); 
但是，从理论上讲，如果需要禁用链接预取，实现就一定会存在问题。 
如果它不能正确运行，我们宁愿改进实现，也不希望用户找到并调整一些隐藏的偏好。 
那些按网络流量付费的人呢？ 
It is important that websites adopt <link> tag based prefetching instead of trying to roll-in silent downloading using various JS/DOM hacks. 
The <link> tag gives the browser the ability to know what sites are up to, and we can use this information to better prioritize document prefetching. 
The user preference to disable <link> tag prefetching may simply encourage websites to stick with JS/DOM hacks, and that would not be good for users. 
This is one reason why prefetching is enabled by default. 
隐私问题 
参见 
Prefetching Hints 

{{GlossarySidebar}} 
一个 CORS 预检请求是用于检查服务器是否支持 {{Glossary(“CORS”)}} 即跨域资源共享。 
它一般是用了以下几个 HTTP 请求首部的 {{HTTPMethod(“OPTIONS”)}} 请求：{{HTTPHeader(“Access-Control-Request-Method”)}} 和 {{HTTPHeader(“Access-Control-Request-Headers”)}}，以及一个 {{HTTPHeader(“Origin”)}} 首部。 
当有必要的时候，浏览器会自动发出一个预检请求；所以在正常情况下，前端开发者不需要自己去发这样的请求。 
举个例子，一个客户端可能会在实际发送一个 DELETE 请求之前，先向服务器发起一个预检请求，用于询问是否可以向服务器发起一个 {{HTTPMethod(“DELETE”)}} 请求： 
OPTIONS /resource/foo 
Access-Control-Request-Method: DELETE 
Access-Control-Request-Headers: origin, x-requested-with 
Origin: https://foo.bar.org 
如果服务器允许，那么服务器就会响应这个预检请求。 并且其响应首部 {{HTTPHeader(“Access-Control-Allow-Methods”)}} 会将 DELETE 包含在其中： 
HTTP/1.1 200 OK Content-Length: 0 
Connection: keep-alive 
Access-Control-Allow-Origin: https://foo.bar.org 
Access-Control-Allow-Methods: POST, GET, OPTIONS, DELETE 
Access-Control-Max-Age: 86400 
参见 
CORS 
{{HTTPMethod(“OPTIONS”)}} 

{{GlossarySidebar}} 
Presto 是专有浏览器渲染引擎，在 {{Glossary(“Opera browser”)}} 15 版本以下使用。 
之后的 Opera 浏览器基于 Chromium, 使用 {{Glossary(‘Blink’)}} 渲染引擎。 
了解更多 
维基上的 Presto 渲染引擎 

{{GlossarySidebar}} 
在 {{Glossary(“JavaScript”)}} 中，基本类型（基本数值、基本数据类型）是一种既非{{Glossary(“object”, “对象”)}}也无{{glossary(“method”,“方法”)}}或属性的数据。 
有 7 种原始数据类型： 
{{Glossary(“string”)}} 
{{Glossary(“number”)}} 
{{Glossary(“bigint”)}} 
{{Glossary(“boolean”)}} 
{{Glossary(“undefined”)}} 
{{Glossary(“symbol”)}} 
{{Glossary(“null”)}} 
多数情况下，基本类型直接代表了最底层的语言实现。 
所有基本类型的值都是不可改变的。 
但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。 
变量会被赋予一个新值，而基本类型不能像数组、对象以及函数那样被改变。 
基本类型没有方法，但仍然表现得像有方法一样。 
当在基本类型上访问属性时，JavaScript 自动将值装入包装器对象中，并访问该对象上的属性。 
例如，"foo".includes("f") 隐式创建了一个 String 包装对象，并在该对象上调用 String.prototype.includes()。 
这种自动装箱行为在 JavaScript 代码中是无法观察到的，但却是各种行为的一个很好的心理模型——例如，为什么“改变”基本类型不起作用（因为 str.Foo = 1 不是赋值给 str 本身的 Foo 属性，而是赋值给了一个临时包装器对象）。 
参见 
JavaScript 数据类型和数据结构 
基本类型（维基百科） 
{{Glossary(“JavaScript”)}} 
{{Glossary(“string”)}} 
{{Glossary(“number”)}} 
{{Glossary(“bigint”)}} 
{{Glossary(“boolean”)}} 
{{Glossary(“null”)}} 
{{Glossary(“undefined”)}} 
{{Glossary(“symbol”)}} 

{{GlossarySidebar}} 
渐进增强（Progressive enhancement）是一种设计理念，其核心是为尽可能多的用户提供基本内容和功能，同时进一步为现代化浏览器用户提供最佳体验，运行所有需要的代码。 
特性检测通常用于确定浏览器是否可以处理高级内容，而polyfill通常用于使用 JavaScript 构建缺少的功能。 
另外请关注无障碍支持 — 尽可能提供备选方案。 
这个技术很有用，因为它让 Web 开发者，在专注开发最强大的网站同时，和某些未知的用户代理在访问网站时发生问题，两者之间达到权衡。 
{{Glossary(“优雅降级”)}} 相关而不同 — 通常被视为与渐进增强相反的方向。 
实际上，这两种方法都是有效的，并且通常可以相互补充。 
了解更多 基本知识 
维基百科的渐进增强 

{{GlossarySidebar}} 
CSS 属性是一种特征（如颜色），其相关值定义了浏览器应如何显示该元素的一个方面。 
以下是 CSS 规则的示例： 
/* “div”选择器意味着文档中所有 div 元素会以该规则进行样式化 */ 
div { 
/* 值为“black”的“color”属性值意味着文字会是黑色的 */ 
color: black; 
/* 值为“white”的“background-color”属性值意味着元素的背景颜色会是白色的 */ 
background-color: white; 
} 
参见 
CSS 学习 
MDN 上的 CSS 参考 
CSS 工作组目前的工作 

{{GlossarySidebar}} 
属性（Property）在不同语境下可能有不同的意义，它可能指： 
{{GlossaryDisambiguation}} 

{{GlossarySidebar}} 
JavaScript 属性是一个对象的成员，它将键与值联系起来。 
JavaScript 对象是一种数据结构，它存储了属性的集合。 
属性包含以下组成部分： 
一个名称（也叫做键），它可能是字符串或符号值。 
一个值，它可以是任何 JavaScript 值。 
具有函数值的属性也可以称为方法。 
一些特性，它们指定了属性的读取和写入方式。 
属性可能具有 configurable、enumerable 和 writable 特性。 
访问器属性没有实际的“值”。 
值是通过一对函数间接表示的，其中一个（getter）在读取值时调用，另一个（setter）在设置值时调用。 
但是，访问器属性在表面上表现得像常规数据属性，因为 getter 和 setter 函数会自动调用，并且通常对 JavaScript 代码是透明的。 
属性的值（包括 getter 和 setter）及其特性被存储在一个叫做属性描述符的数据记录中。 
许多方法，例如 {{jsxref(“Object.getOwnPropertyDescriptor()”)}} 和 {{jsxref(“Object.defineProperty()”)}}，都与属性描述符一起工作。 
属性一词本身与任何 JavaScript 值无关——它是一个抽象的概念。 
例如，在以下代码中： 
const obj = { 
a: 1, 
b() {}, 
}; 
对象 obj 含有两个属性。 
第一个属性以 "a" 为键，1 为值。 
第二个属性以 "b" 为键，一个函数为值，且使用了方法语法。 
"a"—1 和 "b"—function 之间的联系是对象的属性。 
在类的概念中，属性可以分为实例属性和静态属性，前者由每个实例拥有，后者由类拥有，持有所有实例共有的数据。 
在继承的概念下，属性也可以分为自有属性和继承属性，前者由对象本身拥有，后者由对象的原型链中的对象拥有。 
关于读写属性的更多信息，请参见使用对象。 
参见 
维基百科上的属性（计算机科学）词条 
JavaScript 面向对象编程介绍 
对象属性 
属性的可枚举性和所有权 

{{GlossarySidebar}} 
协议是定义了数据如何在计算机内和之间进行交换的规则的系统。 
设备之间通信要求设备接受正在交换的数据的格式。 
定义格式的一组规则称之为协议。 了解更多 
基础知识 
在维基百科中的 通信协议 
RFC 官方互联网协议标准 
参见 TCP 
HTTP 总览 
packet 

{{GlossarySidebar}} 
原型编程 是一种 {{Glossary(“OOP”, “面向对象编程”)}} 的风格。 在这种风格中，我们不会显式地定义{{Glossary(‘Class’, ‘类’)}} ，而会通过向其他类的实例（对象）中添加属性和方法来创建类，甚至偶尔使用空对象创建类。 
简单来说，这种风格是在不定义{{Glossary(‘Class’, ‘class’)}}的情况下创建一个 {{Glossary(‘Object’, ‘object’)}}。 更多内容 
常识 
原型编程 的维基页面 

{{GlossarySidebar}} 
原型是一种在开发生命周期的早期显示应用程序或产品的外观和行为的模型。 
请参见 继承和原型链 了解更多 
基本知识 
Software Prototyping 维基百科 

{{GlossarySidebar}} 
代理服务器 是用来在不同 Internet 网络之间进行导航的中继软件或者计算机。 
它们有助于访问万维网上的内容。 
代理服务器会拦截请求并提供响应；它不一定会转发所有请求（比如说在有缓存的情况），而且也许会修改请求或者响应（比如说在两个网络环境边界的时候修改请求头部信息）。 
代理可以存在用户自己的电脑上，或者任何其他在用户计算机与互联网上的远程服务器之间的任何地方。 
一般来说有两种代理类型： 
正向代理 指处理到互联网的请求的代理 
反向代理 指处理互联网上的请求并转发到服务器的代理 
更多资料 
Proxy servers and tunneling 
Proxy server on Wikipedia 

{{GlossarySidebar}} 
在 CSS 中，一个伪类选择器只依据元素的状态，而不是元素在文档树中的信息，来选择目标对象。 
举例来说，选择器 a{{ cssxref(“:visited”) }} 仅仅应用于那些用户已经浏览过的连接。 
了解更多 
技术参考 伪类 文档 

{{GlossarySidebar}} 
伪代码（Pseudocode）指的是类似于代码的语法，一般用于向人类表明某些代码语法是如何工作的，或者说明某项代码结构的设计。 
如果你试图把它当作代码来运行，它不会起作用。 
参见 
维基百科上的伪代码词条。 

{{GlossarySidebar}} 
Python 是一个高级通用编程语言。 
它使用多范式方法。 这意味着它支持程序化、面向对象和一些功能性编程结构。 
它是由 Guido van Rossum 创建的，作为 1985 年至 1990 年间的另一种语言（称为 ABC）的继任者。 目前 Python 被用于大量的领域，如 Web 开发，作为其他应用程序的脚本语言和构建实际应用程序。 
Python 是根据 OSI 批准的开源许可证开发的，使其免费使用和分发，即使是商业用途也是如此。 
Python 的许可证是由 Python 软件基金会 管理的。 
了解更多 
在维基百科上的 Python 
python 的入门教程 

{{GlossarySidebar}} 
质量价值（Quality values）亦称作 q 值，其与 q 因子以逗号分隔的方式来描述值的优先级顺序，是 HTTP 消息头以及 HTML 中的特殊语法。 
值的重要性以一种后缀表示：';q='。 
该后缀紧接0到1间的值 (值可达小数点后三位)，最高值表明最高优先级。 
无此后缀时，默认值为1。 
示例 
以下语法 
text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 
表明优先级先后顺序： 
Value 值 
Priority 优先级 
text/html and application/xhtml+xml 
1.0 
application/xml 
0.9 
*/* 
0.8 
如果前面这两个值未定义优先级，值的顺序并不重要。 
然而，q 值相同时，值越具体，其优先级越高。 
text/html;q=0.8,text/*;q=0.8,*/*;q=0.8 
Value 值 
Priority 优先级 
text/html 
0.8 (but totally specified) 
text/* 
0.8 (partially specified) 
*/* 
0.8 (not specified) 
像 Accept 消息头的语法可以有额外的标记，比如text/html;level=1。 
这使值更具体，不过该用法不常见。 
浏览器信息 火狐 
Firefox bug 672448） 
更多 使用 q 值的 HTTP 消息头：{{HTTPHeader(“Accept”)}}、{{HTTPHeader(“Accept-Charset”)}}、{{HTTPHeader(“Accept-Language”)}}、{{HTTPHeader(“Accept-Encoding”)}}和{{HTTPHeader(“TE”)}}。 

{{GlossarySidebar}} 
RAIL, 是 Response, Animation, Idle, 和 Load 的首字母缩写, 是一种由 Google Chrome 团队与 2015 年提出的性能模型，用于提升浏览器内的用户体验和性能。 
RAIL 模型的理念是 “以用户为中心；最终目标不是让你的网站在任何特定设备上都能运行很快，而是使用户满意。” 
RAIL 把交互分为四个阶段：页面加载，空闲，响应用户输入，滚动和动画。 
按首字母缩写顺序，其主要原则是： 
响应 
: 应该尽可能快速的响应用户，应该在 100ms 或者 100ms 以内响应用户输入。 
动画 
: 在展示动画的时候，每一帧应该以 16ms 进行渲染，这样可以保持动画效果的一致性，并且避免卡顿。 
空闲 
: 当使用 Javascript 主线程的时候，应该把任务划分到执行时间小于 50ms 的片段中去，这样可以释放线程以进行用户交互 
加载 
: 应该在小于 1s 的时间内加载完成你的网站，并可以进行用户交互。 
See also 
Recommended Web Performance Timings: How long is too long 

{{GlossarySidebar}} 
一种函数调用自身的操作。 
递归被用于处理包含有更小的子问题的一类问题。 
一个递归函数可以接受两个输入参数：一个最终状态（终止递归）或一个递归状态（继续递归）。 
了解更多 
通用信息 
Wikipedia 页面：Recursion (computer science) 
更多关于 JavaScript 中递归的细节 

{{GlossarySidebar}} 
当浏览器必须重新处理和绘制部分或全部页面时，回流就会发生，例如当一个交互式站点更新后。 
更多 
Google 关于“最小化浏览器回流”的文章 

{{GlossarySidebar}} 
正则表达式（Regular expressions或 regex）是决定了在搜索中使用何种字符串序列的规则。 
正则表达式在多种语言中都得到了实现，但是最知名的实现，当属 Perl 的实现。 该实现引出了名为 PCRE（Perl Compatible Regular Expression）的生态系统。 
在 Web 中，{{glossary(“JavaScript”)}} 通过 {{jsxref(“RegExp”)}} 对象，给出了正则表达式的另一种实现。 了解更多 
基本知识 
在维基百科上的 正则表达式 
互动教程 
虚拟化的正则表达式 
技术参考 在 JavaScript 中写正则表达式 

{{GlossarySidebar}} 
表示标头（representation header）是一种 {{glossary(“HTTP_header”, “HTTP 标头”)}}，用于描述 HTTP 消息主体中发送资源的特定的表示形式。 
所谓表示（representation）就是特定的资源不同的表示形式。 
例如，相同的数据，其可能被格式化为例如 XML 或 JSON 等特定媒体类别的格式，被本地化为特定的书面语言或者地理区域，或者通过压缩或者其他方式编码以进行传输。 
底层资源在每种情况下都是一样的，但是它的表示形式是不同的。 
客户端指定它们希望在内容协商期间发送的格式（使用 Accept-* 标头），并且表示标头将实际收到的选定的表示形式传达给客户端。 
表示标头可能同时出现在 HTTP 请求和响应消息中。 
如果它们是作为 HEAD 请求的响应发送的，它们会描述如果实际请求资源时，将选择的主体内容。 
表示标头包括：{{HTTPHeader(“Content-Type”)}}、{{HTTPHeader(“Content-Encoding”)}}、{{HTTPHeader(“Content-Language”)}} 和 {{HTTPHeader(“Content-Location”)}}。 
参见 
RFC 9110, section 3.2: Representations 
所有 HTTP 标头列表 
{{Glossary(“Payload header”, “有效负荷标头（Payload header）”)}} 
{{glossary(“Entity header”, “实体标头（Entity header）”)}} 
{{HTTPHeader(“Digest”)}}/ {{HTTPHeader(“Want-Digest”)}} 


{{GlossarySidebar}} 
响应标头（response header）是一种 {{glossary(“HTTP header”,“HTTP 标头”)}}，其可以用于 HTTP 响应，且与响应消息主体无关。 
像 {{HTTPHeader(“Age”)}}、{{HTTPHeader(“Location”)}} 或 {{HTTPHeader(“Server”)}} 都属于响应标头，它们被用于提供更详细的响应上下文。 
并非所有出现在响应中的标头都根据规范将其归类为响应标头。 
例如，{{HTTPHeader(“Content-Type”)}} 标头就是一个{{glossary(“representation header”,“表示标头（representation header）”)}}，指示响应信息正文中的原始数据类型（在应用 {{HTTPHeader(“Content-Encoding”)}} 表示标头中的编码前）。 
然而，“会话式”的所有标头通常在响应消息中称为响应标头。 
以下展示了 {{HTTPMethod(“GET”)}} 请求后的一些响应和表示标头。 
200 OK 
Access-Control-Allow-Origin: * 
Connection: Keep-Alive 
Content-Encoding: gzip 
Content-Type: text/html; charset=utf-8 
Date: Mon, 18 Jul 2016 16:06:00 GMT 
Etag: "c561c68d0ba92bbeb8b0f612a9199f722e3a621a" 
Keep-Alive: timeout=5, max=997 
Last-Modified: Mon, 18 Jul 2016 02:36:04 GMT 
Server: Apache 
Set-Cookie: mykey=myvalue; expires=Mon, 17-Jul-2017 16:06:00 GMT; Max-Age=31449600; Path=/; secure 
Transfer-Encoding: chunked 
Vary: Cookie, Accept-Encoding 
X-Backend-Server: developer2.webapp.scl3.mozilla.com 
X-Cache-Info: not cacheable; meta data too large 
X-kuma-revision: 1085259 
x-frame-options: DENY 
参见 
所有 HTTP 标头列表 
Glossary 
{{Glossary(“Representation header”, “表示标头（Representation header）”)}} 
{{Glossary(“HTTP header”, “HTTP 标头”)}} 
{{Glossary(“Response header”, “响应标头（Response header）”)}} 
{{Glossary(“Fetch metadata response header”, “fetch 元数据响应头”)}} 
{{Glossary(“Request header”, “请求标头（Request header）”)}} 

{{GlossarySidebar}} 
通常在 {{Glossary(“API”,“API’s”)}} 或服务能直接修改文件的类型，而非触发其他行为时，它们就称自己为 RESTful。 

{{GlossarySidebar}} 
RSS（简易信息聚合）指的是用于发布站点更新的数种 XML 文档格式。 
当你订阅一个网站的 RSS 摘要时，网站会将 RSS 信息和更新信息发送到一个称为资讯（feed）的 RSS 文档中，因此你无需手动查看所有喜爱的网站就可以获取这些网站的更新动态。 了解更多 
基础知识 
维基百科上的 RSS 
最新的 RSS 标准 

{{GlossarySidebar}} 
RTL（从右到左，Right To Left）是{{Glossary(“locale”, “区域设置”)}}的属性之一，用于指示语言从右到左的书写方向。 
举个例子，希伯来语（he）指定从右往左书写，而阿拉伯语（ar）也是另一种从右往左书写的常见语言。 
与 RTL 相对的是 LTR（从左到右，Left To Right），用于包括英语（en、en-US、en-GB 等等）、西班牙语（es）及法语（fr）在内的其他语言。 
参见 
MDN Web 文档术语 
{{Glossary(“Localization”, “本地化”)}} 
{{Glossary(“LTR”, “LTR（从左到右）”)}} 
{{Glossary(“RTL”, “RTL（从右到左）”)}} 

{{GlossarySidebar}} 
如果说一个 HTTP 方法是安全的，是指这是个不会修改服务器的数据的方法。 
这些方法是安全的：{{HTTPMethod(“GET”)}}，{{HTTPMethod(“HEAD”)}} 和 {{HTTPMethod(“OPTIONS”)}}。 
所有安全的方法都是{{glossary(“idempotent”, “幂等”)}}的，但并非所有幂等方法都是安全的，例如，{{HTTPMethod(“PUT”)}} 和 {{HTTPMethod(“DELETE”)}} 都是幂等的，但不是安全的。 
技术规范 安全方法的详细解释：{{HTTPMethod(“GET”)}}, {{HTTPMethod(“HEAD”)}}, {{HTTPMethod(“OPTIONS”)}} 
非安全方法的详细解释：{{HTTPMethod(“PUT”)}}, {{HTTPMethod(“DELETE”)}}, {{HTTPMethod(“POST”)}} 

{{GlossarySidebar}} 
安全一词根据上下文的不同会具有不同的含义。 
它可以指： 
{{GlossaryDisambiguation}} 

{{GlossarySidebar}} 
同源策略是一种重要的安全机制，用来限制来自某个域的文档或脚本与另一个域的资源的交互行为，能够隔离潜在的恶意文件，减少受攻击的可能性。 

{{GlossarySidebar}} 
作用域是当前的执行上下文，{{glossary(“value”,“值”)}}和表达式在其中“可见”或可被访问。 
如果一个{{glossary(“variable”,“变量”)}}或表达式不在当前的作用域中，那么它是不可用的。 
作用域也可以堆叠成层次结构，子作用域可以访问父作用域，反过来则不行。 
JavaScript 的作用域分以下三种： 
全局作用域：脚本模式运行所有代码的默认作用域 
模块作用域：模块模式中运行代码的作用域 
函数作用域：由{{glossary(“function”,“函数”)}}创建的作用域 
此外，用 let 或 const 声明的变量属于额外的作用域： 
块级作用域：用一对花括号（一个代码块）创建出来的作用域 
由于{{glossary(“function”,“函数”)}}会创建作用域，因而在函数中定义的变量无法从该函数外部访问，也无法从其他函数内部访问，例如，下面的代码是无效的： 
```js example-bad function exampleFunction() { const x = “declared inside function”; // x 只能在 exampleFunction 函数中使用 console.log(“Inside function”); console.log(x); } 
console.log(x); // 报错 
但是，下面的代码是有效的，因为变量在函数外被声明，为全局变量： 
```js example-good 
const x = "declared outside function"; 
exampleFunction(); 
function exampleFunction() { 
console.log("Inside function"); 
console.log(x); 
} 
console.log("Outside function"); 
console.log(x); 
块级作用域只对 let 和 const 声明有效，对 var 声明无效。 
js example-good { var x = 1; } console.log(x); // 1 
js example-bad { const x = 1; } console.log(x); // ReferenceError: x is not defined 
参见 
维基百科词条：作用域 

{{GlossarySidebar}} 
滚动容器为一种元素盒。 无论滚动条是否存在，滚动容器中的内容均可滚动。 
当 CSS 属性 {{CSSXref(“overflow”)}} 设置为 scroll，或者 overflow 设置为 auto 且内容溢出滚动容器时，用户代理将为元素盒添加滚动条，使其成为滚动容器。 
当元素盒的内容溢出其包围盒时，用户可使用滚动条滚动经过被裁减的内容，而这些内容本将在视野中被隐藏。 
滚动容器含有滚动口和滚动条。 
滚动口 
滚动口为滚动容器的可见部分，与滚动容器的内边距盒重合。 
滚动条用于将内容移入或移出滚动口，由此使内容可见。 

{{GlossarySidebar}} 
SDP (Session Description {{glossary(“Protocol”)}}) 是一个描述{{Glossary(“P2P”,“peer-to-peer”)}} 连接的标准。 
SDP 包含音视频的：编解码 ({{Glossary(“codec”)}}),源地址，和时间信息。 
下面是一个典型的 SDP 信息示例： 
v=0 
o=alice 2890844526 2890844526 IN IP4 host.anywhere.com 
s= 
c=IN IP4 host.anywhere.com 
t=0 0 
m=audio 49170 RTP/AVP 0 
a=rtpmap:0 PCMU/8000 
m=video 51372 RTP/AVP 31 
a=rtpmap:31 H261/90000 
m=video 53000 RTP/AVP 32 
a=rtpmap:32 MPV/90000 
SDP 协议从不会被单独使用，而是依靠 {{Glossary(“RTP”)}} 和{{Glossary(“RTSP”)}}等协议. 
SDP 也作为{{Glossary(“WebRTC”)}}的组件之一，用于描述一个 session 会话。 
了解更多 
WebRTC protocols 
Session Description Protocol on Wikipedia 

{{GlossarySidebar}} 
一个 {{glossary(“JavaScript”)}} {{glossary(“函数”)}} 在定义后立即执行。 
也被熟知为 {{glossary(“IIFE”)}} (立即执行函数表达式)(Immediately Invoked Function Expression). 
请浏览上面 IIFE 解释页链接获取更多信息/. 

{{GlossarySidebar}} 
在编程中，语义指的是一段代码的含义 — 例如 “运行这行 JavaScript 代码会产生怎样的影响？”, 或者 “这个 HTML 的元素有什么作用，扮演了什么样的角色”（而不只是 “它看上去像是什么？”。） 
JavaScript 中的语义 
JavaScript 中，考虑一个函数，该函数接受一个字符串参数，然后返回一个以该字符串为文本内容的{{htmlelement(“li”)}}元素。 
如果该函数调用是build('Peach')，你会需要去看代码才能理解该函数做了什么吗，如果是createLiWithContent('Peach')呢？ 
CSS 中的语义 
CSS 中，考虑给一个列表设置样式，li 元素代表不同类型的水果。 
通过 div > ul > li，你能知道 DOM 的那一部分会被选择中吗？ 
但如果是 .fruits__item 呢？ 
HTML 中，例如，{{htmlelement(“h1”)}} 元素是一个语义化元素，赋予了它包裹着的文本“这个页面中最高级别标题功能“的角色 (或含义) 。 
<h1>This is a top level heading</h1> 
默认情况下，绝大多数浏览器的 user agent stylesheet 将会赋予一个 {{htmlelement(“h1”)}} 元素很大的字号尺寸从而使它看上去更像是一个标题（虽然你可以把它格式化为任何你想要的样式），但是更重要的是它的语义会被在很多地方以不同的方式被使用到，例如搜索引擎会把它包含的内容作为一个重要的关键词，从而影响这个页面在搜索结果中的排序（参见{{ glossary (“SEO”)}}），而且屏幕阅读器会使用它来帮助视障用户更好的使用这个页面。 
另一方面，你可以通过样式（CSS）来让任何的元素看上去像是一个最高级别的标题，就像下面所展示的方法一样： 
<span style="font-size: 32px; margin: 21px 0;" 
>Is this a top level heading? 
</span > 
这将会把这个元素渲染得像是一个最高级别的标题，但是它的值没有对应到最“最高级别标题”这一语义，所以在此之上，它不会获得更多额外的描述（只是一个普通“span”元素而不是“最高级别标题”这一语义）。 
所以在恰当的需求下使用恰当的 HTML 元素是一个不错的主意。 
HTML 应该编写为表示将要填充的数据，而不是基于其默认的演示样式。 
演示（应该是什么样子），是 CSS 的唯一责任。 
写语义标记的一些好处如下： 
搜索引擎将其内容视为影响页面搜索排名的重要关键字（参见 {{ glossary (“SEO”)}}）。 
屏幕阅读器可以将其用作指引，帮助视力受损的用户导航页面。 
比起搜索无休止的带有或不带有语义/命名空间类的 div，找到有意义的代码块显然容易得多。 
向开发人员建议将要填充的数据类型。 
语义命名反映了正确的自定义元素/组件命名。 
当接近要使用的标记时，问问自己，“什么元素最能描述/表示我要填充的数据？” 
例如，它是数据列表吗？ 
有序或无序？ 
是否是一篇具有章节和相关信息旁注的文章？ 
它是否列出了定义？ 
它是需要标题的图形还是图像？ 
除了全局网站范围的页眉和页脚之外，它还应该有页眉和页脚吗？ 
等等。 
语义化元素 
这是一些语义化的元（source）。 
{{htmlelement(“article”)}} 
{{htmlelement(“aside”)}} 
{{htmlelement(“details”)}} 
{{htmlelement(“figcaption”)}} 
{{htmlelement(“figure”)}} 
{{htmlelement(“footer”)}} 
{{htmlelement(“header”)}} 
{{htmlelement(“main”)}} 
{{htmlelement(“mark”)}} 
{{htmlelement(“nav”)}} 
{{htmlelement(“section”)}} 
{{htmlelement(“summary”)}} 
{{htmlelement(“time”)}} 了解更多 
HTML element reference on MDN 
Using HTML sections and outlines on MDN 
HTML5 Semantic Elements on w3schools 
The meaning of semantics in computer science on Wikipedia 
MDN Web Docs Glossary 
{{Glossary(“SEO”)}} 

{{GlossarySidebar}} 
SEO（搜索引擎优化）是一种让网站在搜索引擎结果中更加清晰，也帮助我们将搜索结果更靠前 
搜索引擎{{Glossary(“Crawler”, “抓取”)}}网页，跟随页面之间的链接，并索引找到的内容。 
搜索时，搜索引擎会显示索引内容。 
爬行者遵守规则。 
如果你在为网站进行搜索引擎优化时密切关注这些规则，则会为网站提供最好的机会，以便在首批结果中显示，增加流量和可能的收入（用于电子商务和广告）。 
搜索引擎为 SEO 提供了一些指导，但大型搜索引擎将结果排名保持为商业秘密。 
SEO 结合了官方搜索引擎指南，经验知识和科学论文或专利的理论知识。 
SEO 方法分为三大类： 
技术 
: 使用语义标记内容{{Glossary(“HTML”)}}. 
浏览网站时，抓取工具应该只找到你要编入索引的内容。 
撰稿 
: 使用访问者的词汇编写内容。 
使用文本和图像，以便抓取工具可以理解主题。 
声望 
: 当其他已建立的站点链接到你的站点时，你获得最多流量。 
基本知识 
SEO on 维基百科 
Google Webmaster Central 

{{GlossarySidebar}} 
可序列化对象（Serializable object）是可以在任何 JavaScript 环境（领域，realm）中序列化、反序列化的对象。 
例如，这允许将此类对象存储在磁盘上并在以后进行恢复，或使用 {{domxref(“structuredClone()”)}} 对它们进行拷贝，又或者使用 {{domxref(“DedicatedWorkerGlobalScope.postMessage()”)}} 在 Worker 之间共享它们。 
序列化可能不包括原始对象的所有属性和其他方面的内容。 
例如，对 {{domxref(“DOMException”)}} 的序列化必须包含 name 和 message 属性，但是否包含其他属性则取决于具体实现。 
因此，反序列化的对象并不一定是与原始对象相同的拷贝。 
但是，反序列化得到的新的对象将会是一个{{glossary(“deep copy”, “深拷贝”)}}，因此任何从原始对象序列化并反序列化到新的对象的属性都不会和原始对象共享任何引用。 
在某些情况下，当序列化和反序列化一个对象时，可能会转移一些资源而非拷贝它们。 
可以转移的对象被称为可转移对象。 
支持的对象 
所有的基本类型都是可以被序列化的。 
但并非所有的对象都是可序列化对象。 
可以被序列化的对象在结构化克隆算法 > 支持的类型中列出。 
备注： 可序列化对象在 Web IDL 文件中使用属性 [Serializable] 标记。 

{{GlossarySidebar}} 

{{GlossarySidebar}} 
服务器是为用户（通常称为客户端）提供服务的软件或硬件。 
硬件而言的服务器是互联网上的共享计算机，通常性能强劲且位于数据中心。 
软件而言的服务器（一般是运行在硬件服务器上）是一种向客户端程序或向{{glossary(“UI”,“用户界面”)}}提供服务的程序。 
我们一般在局域网或广域网（如互联网）提供服务。 
传统上，客户端程序和服务器程序通过 {{glossary(“API”)}} 传递信息进行连接，这种信息使用{{glossary(“Protocol”,“协议”)}}编码。 
举个例子： 
连接到互联网的 Web 服务器向你的浏览器发送一个 {{glossary(“HTML”)}} 文件，这样你就可以浏览页面。 
用于文件、域名、邮件、打印机和传真机的局域网服务器。 
数据中心的小型机、大型机和超算。 了解更多 
常识 
服务器介绍 
维基百科上的 服务器 

{{GlossarySidebar}} 
{{MDNSidebar}} 
对象的浅拷贝是其属性与拷贝源对象的属性共享相同引用（指向相同的底层值）的副本。 
因此，当你更改源或副本时，也可能导致其他对象也发生更改——也就是说，你可能会无意中对源或副本造成意料之外的更改。 
这种行为与深拷贝的行为形成对比，在深拷贝中，源和副本是完全独立的。 
对于浅拷贝，有选择地更改对象中现有元素的共享属性的值与给现有元素赋一个全新的值是不同的，理解这一点很重要。 
例如，如果在一个数组对象名为 copy 的浅拷贝中，copy[0] 元素的值是 {"list":["butter"，"flour"]}，然后执行 copy[0]. 
List = ["oil"，"flour"]，那么源对象中的相应元素也将发生变化——因为你有选择地更改了源对象和浅拷贝共享的对象的属性。 
然而，如果你做的是 copy[0] = {"list":["oil"，"flour"]}，那么源对象中的对应元素将不会改变——因为在这种情况下，你不仅仅是有选择地改变了浅拷贝与源对象共享的现有数组元素的属性；相反，你实际上是在浅拷贝中分配了一个全新的值给 copy[0] 数组元素。 
在 JavaScript 中，所有标准的内置对象复制操作（展开语法、Array.prototype.concat()、Array.prototype.slice()、Array.from()、Object.assign() 和 Object.create()）创建的是浅拷贝而不是深拷贝。 示例 
考虑以下示例，其中创建了一个 ingredients_list 数组对象，然后通过复制 ingredients_list 对象创建了一个 ingredients_list_copy 对象。 
let ingredients_list = ["noodles", { list: ["eggs", "flour", "water"] }]; 
let ingredients_list_copy = Array.from(ingredients_list); 
console.log(JSON.stringify(ingredients_list_copy)); 
// ["noodles",{"list":["eggs","flour","water"]}] 
改变 ingredients_list_copy 中 list 属性的值也将导致 ingredients_list 源对象中的 list 属性发生变化。 
ingredients_list_copy[1].list = ["rice flour", "water"]; 
console.log(ingredients_list[1].list); 
// ["noodles",{"list":["rice flour","water"]}] 
为 ingredients_list_copy 中的第一个元素赋值，不会导致 ingredients_list 源对象中的第一个元素发生任何变化。 
ingredients_list_copy[0] = "rice noodles"; 
console.log(ingredients_list[0]); // noodles 
console.log(JSON.stringify(ingredients_list_copy)); 
// ["rice noodles",{"list":["rice flour","water"]}] 
console.log(JSON.stringify(ingredients_list)); 
// ["noodles",{"list":["rice flour","water"]}] 
参见 
深拷贝 

{{GlossarySidebar}} 
一个函数签名 (或类型签名，或方法签名) 定义了 {{Glossary(“Function”, “函数”)}} 或 {{Glossary(“Method”, “方法”)}} 的输入与输出。 
一个签名可以包括： 
{{Glossary(“Parameter”, “参数”)}} 及参数的 {{Glossary(“Type”, “类型”)}} 
一个返回值及其类型 
可能会抛出或传回的 {{Glossary(“Exception”, “异常”)}} 
有关 {{Glossary(“OOP”, “面向对象”)}} 程序中方法可用性的信息 (例如关键字 public、static 或 prototype)。 
深入 
JavaScript 中的签名 
{{Glossary(“JavaScript”)}} 是一种松散类型 或 动态语言。 
这意味着你不必提前声明变量的类型。 
处理程序时，将自动确定类型。 
JavaScript 中的签名仍然可以为你提供有关该方法的一些信息： 
MyObject.prototype.myFunction(value); 
该方法是安装在一个名为 MyObject 的 {{Glossary(“object”, “对象”)}}上。 
该方法安装在 MyObject 的原型上 (因此它是一个{{Glossary(“instance method”, “实例方法”)}})，而不是一个 {{Glossary(“static method”, “静态方法/类方法”)}} 。 
该方法的名称是 myFunction。 
该方法接受一个叫 value 的参数，且没有进一步定义。 
Java 中的签名 
在 {{Glossary(“Java”)}} 中，签名用于识别虚拟机代码级别的方法和类。 
你必须在代码中声明变量的类型才能运行 Java 代码。 
Java 是严格类型 的，将在编译时检查所有参数是否正确。 
public static void main(String[] args) 
public 关键字是一个访问修饰符，指示任何对象都可以调用此方法。 
static 关键字指示此方法是一个类方法，而不是一个实例方法。 
void 关键字表指示此方法没有返回值。 
该方法的名称为 main。 
该方法接受一个类型为 String Array 的参数。 
它的名是 args。 
基本知识 
Java 内部类型签名 在维基百科上 

{{GlossarySidebar}} 
根据上下文，术语 签名可以有几个含义。 
可以参考： 
{{GlossaryDisambiguation}} 
了解更多 
Signature on Wikipedia 

{{GlossarySidebar}} 
签名或数字签名是 {{glossary(“protocol”,“协议”)}}，表明消息是真实的。 
从给定消息的{{glossary(“hash”)}}，签名过程首先使用实体的私有{{glossary(“key”)}}生成链接到签名实体的数字签名。 
收到消息后的验证过程 
验证发件人 - 使用发件人的公钥来{{glossary(“decryption”,“解码”)}}签名并恢复只能用发件人的私钥创建的哈希 
检查消息完整性 - 将哈希与接收到的文档中新计算的哈希进行比较（如果文档被篡改，两个哈希将不同） 
如果私钥被泄密或收件人被欺骗地给出错误的公钥，系统就会失败。 了解更多 
基础知识 
Digital signature on Wikipedia 
See {{glossary(“digest”)}}, {{glossary(“encryption”)}} 技术参考 

{{GlossarySidebar}} 
{{HTTPHeader(“DPR”)}} {{HTTPHeader(“Downlink”)}} 

{{GlossarySidebar}} 
{{Glossary(“CORS”)}} {{Glossary(“Simple header”)}} 

{{GlossarySidebar}} 
并非正式地，站点是一个网站，它是一个网页的集合，由同一域提供服务，并且由单一的组织提供维护。 
浏览器有时需要去精确地区分不同的站点。 
例如，浏览器必须仅发送同站（SameSite） cookie 给同一站点，然后才能设置它们。 
对于这个更精确的定义，站点由域名的可注册域部分确定。 
可注册域由公共后缀列表中的一个条目加上它之前的域名部分组成。 
这意味着，例如 theguardian.co.uk、sussex.ac.uk 和 bookshop.org 都是可注册的域。 
根据这个定义，support.mozilla.org 和 developer.mozilla.org 是同一站点的一部分，因为 mozilla.org 是一个可注册域。 
在某些情况下，在区分不同的站点时，也会考虑站点的协议（scheme）。 
这将使 http://vpl.ca 和 https://vpl.ca 成为不同的站点。 
包含协议（scheme）的情况可以防止不安全的（HTTP）站点被视为与安全（HTTPS）站点为相同的站点。 
考虑协议（scheme）的定义有时被称为 schemeful same-site。 
这个更严格的定义适用于处理 SameSite cookie。 
示例 
这些是同一个站点，因为 mozilla.org 的可注册域是相同的： 
https://developer.mozilla.org/zh-CN/docs/ 
https://support.mozilla.org/zh-CN/ 
这些是同一个站点，因为端口不相关： 
https://example.com:8080 
https://example.com 
这些不是同一个站点，因为两个 URL 的可注册域不同： 
https://developer.mozilla.org/zh-CN/docs/ 
https://example.com 
如果考虑协议（scheme），这些可能是相同的站点或不同的站点： 
http://example.com 
https://example.com 
参见 
URL 是什么 
{{Glossary(“Origin”)}} 
同源策略 

{{GlossarySidebar}} 
{{Glossary(“ECMAScript”)}} 5 以及其后续的版本可以选择性的使用一种新模式——严格模式 (strict mode)，这种严格模式在多个方面改变了 JavaScript 的语义，从而使得当出现问题时我们更好的理解到底发生了什么。 
常见的，非严格模式——平时我们会称之为正常模式 (sloppy mode)，这并不是一个官方说法，但是你会经常见到如上的一些说法，其意义就是指代非严格模式，即正常模式。 
相关链接 
“Strict Mode”，第七章 (“JavaScript Syntax”)，《Speaking JavaScript》 

{{GlossarySidebar}} 
SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是用于发送的邮件的协议。 
类似于POP3和NNTP，它是一个状态机驱动的协议 
该协议相对简单。 
最复杂的部分在于添加支持不同的验证机制（GSSAPI， CRAM-MD5，NTLM，MSN，AUTH LOGIN，AUTH PLAIN 等），处理错误响应以及在验证机制错误时进行状态回退（如服务器声明其支持某种机制但其实并不）。 
参见 
术语表 
NNTP 
POP3 
协议 状态机 
维基百科 SMTP 

{{GlossarySidebar}} 
SPA（Single-page application，单页应用）是只加载一个单独网页的 web 应用实现，当需要显示不同的内容时，它通过 JavaScript API（例如 {{domxref(“XMLHttpRequest”)}} 和 Fetch）更新主体内容。 
这使得用户在访问网站时无需加载新的页面，可以获得性能提升和动态的体验，但会相应地丧失诸如 SEO（搜索引擎优化）的优势，同时需要更多精力维护状态、实现导航以及做一些有意义的性能监控。 
参见 
单页应用（维基百科词条） 
理解客户端 JavaScript 框架 
术语表 
{{Glossary(“API”)}} 
{{Glossary(“AJAX”)}} 
{{Glossary(“JavaScript”)}} 
著名的单页应用框架： 
React 
Angular 
Vue.JS 

{{GlossarySidebar}} 
在传统的浏览器中，HTML 解析器运行于主线程之中，并且在遇到 </script> 标签后会被阻塞，直到脚本从网络中被获取和执行。 
Firefox 4 和后续的版本支持从主线程中分离的预解析技术。 
当脚本在获取和执行的过程中，预解析技术能提前解析 HTML 文档。 
在 Firefox 3.5 和 3.6 中，HTML 解析器能够在文档流中预先加载脚本、层叠样式表和图片。 
然而，在 Firefox 4 和后续的版本中 HTML 解析器也预先运行 HTML 树构建算法。 
这篇文档旨在帮助你避免预解析失败和页面加载变慢。 使预加载成功 
让脚本、层叠样式表和图片预加载成功的规则只有一条： 
如果你使用 <base> 元素重载页面的基 URI，将这个元素放置到文档的非脚本部分。 
不要通过 document.write() 或者 document.createElement() 添加。 
避免树构建器的输出丢失 
当 document.write() 改变了文档树的状态时，树构建器的预构建过程会失败。 例如，当所有被 document.write() 插入的内容被解析之后 </script> 标签后的预处理状态不再持有。 
然而，只有不寻常地使用 document.write() 才会产生问题。 
不要写不对称的文档树。 
<script>document.write("<div>");</script> 很糟糕。 <script>document.write("<div></div>");</script> 则是可行的。 
不要写未完成的标识。 <script>document.write("<div></div");</script> 很糟糕。 
不要以回车结束内容。 <script>document.write("Hello World! 
\r");</script> 很糟糕。 <script>document.write("Hello World! 
\n");</script> 则是可行的。 
注意即使对称的标签也可能导致文档的不对称。 
比如：head 元素中的<script>document.write("<div></div>");</script> i 会被解析成 <script>document.write("</head><body><div></div>");</script> 因次文档是不对称的。 不要仅格式化部分表格。 <table><script>document.write("<tr><td>Hello World! 
</td></tr>");</script></table> 很糟糕。 然而， <script>document.write("<table><tr><td>Hello World! 
</td></tr></table>");</script> 则是可行的。 

{{GlossarySidebar}} 
SQL（结构化查询语言）是一个被设计用于基于表格的数据库进行更新、检索、计算数据等操作的描述性的计算机语言。 
了解更多 
基础知识 
在 sqlzoo.net 学习 SQL 
Tutorial Point 

{{GlossarySidebar}} 
SQL 注入（SQL Injection）利用了未能验证用户输入的 Web 应用程序。 
黑客可以通过 Web 应用程序传递恶意 SQL 命令，以便由后端数据库执行。 
SQL 注入可以获得对数据库的未经授权的访问，或直接从数据库检索信息。 
许多数据泄露事件都是由于 SQL 注入造成的。 
如何实现 
带有用户名和密码字段的登录表格的屏幕截图 
输入用户名和密码后，在用户界面背后的 SQL 查询类似如下： 
"SELECT Count(*) FROM Users WHERE Username=' " + txt.User. 
Text+" ' AND Password=' "+ txt.Password. 
Text+" ' "; 
假定用户输入用户名为 admin，密码为 passwd123，在点击登录按钮后，会运行这样的 SQL 查询： 
"SELECT Count(*) FROM Users WHERE Username=' admin ' AND Password=' passwd123 ' "; 
如果凭证是正确的，那么用户就被允许登录，所以这是一个非常简单的（因此也是不安全的）机制。 
黑客利用这种不安全性来获得未经授权的访问。 
黑客可以使用一个简单的字符串，称为“神奇的字符串”： 
Username: admin 
Password: anything ‘or’1’=’1 
在点击登录按钮后，会运行这样的 SQL 查询： 
"SELECT Count(*) FROM Users WHERE Username=' admin ' AND Password=' anything 'or'1'='1 ' "; 
只要仔细看看上述查询的密码部分就知道了。 
Password=' anything 'or'1'='1 ' 
密码不是“anything”，因此 password=anything 的结果是 FALSE，但 ‘1’=‘1’ 是一个恒真语句，因此返回 TRUE 值。 
最后，由于 OR 运算符的作用，条件部分的值（FALSE OR TRUE）为 TRUE，所以成功绕过了认证。 
仅仅由于一个简单的字符串（“魔法字符串”），整个数据库就被破坏了。 
如何防御 
在执行对用户凭证的查询之前，要做一些改变，比如说： 
$id = $_GET['id'] 
(1) $id = Stripslashes($id) 
(2) $id = mysql_real_escape_String($id) 
语句（1）将输入字符串中的每个单引号（’）被替换为双引号（“），并且语句（2）在每个单引号（’）之前添加正斜杠（/）实现转义操作。 
修改之后，“魔法字符串”就无法绕过认证，而你的数据库则能够保持安全。 
参见 
维基百科上的 SQL 注入词条 
OWASP（开放 Web 应用安全项目）上的 SQL 注入解释 

{{GlossarySidebar}} 
SSL（Secure Sockets Layer，安全套接层）是旧的标准安全技术，用于在服务器和客户端之间创建加密的网络链路，确保传递的所有数据都是私密且安全的。 
SSL 的当前版本是 Netscape 于 1996 年发布的 3.0 版本，已被 {{Glossary(“TLS”)}} 协议取代。 
参见 
传输层安全性协议（维基百科） 
传输层安全协议（TLS） 
术语表 
{{Glossary(“HTTPS”)}} 
{{Glossary(“TLS”)}} 

{{GlossarySidebar}} 
在计算机编程语言中，语句 是一行任务指令的代码。 
每个程序都包含若干语句。 
更多 
Statement (computer science) on Wikipedia 
JavaScript statements and declarations 

{{GlossarySidebar}} 
JavaScript 的严格模式是使用受限制的 JavaScript 的一种方式，从而隐式地退出“草率模式”。 
严格模式不仅仅是一个子集：这种模式有意地与普通情形下的代码有所区别。 
通过在脚本文件/函数开头添加 "use strict"; 声明，即可启用严格模式。 
另请参见 
严格模式 
过渡到严格模式 

{{GlossarySidebar}} 
在任何计算机编程语言中，字符串都是用于表示文本的{{Glossary(“character”, “字符”)}}序列。 
在 {{Glossary(“JavaScript”)}} 中，字符串是{{Glossary(“Primitive”, “基本类型”)}}的其中一个，而 {{jsxref(“String”)}} 是 {{Glossary(“wrapper”)}} 围绕字符串的基本形式。 
学到更多 
基本知识 维基百科上的字符串 
JavaScript 数据类型和数据结构 

{{GlossarySidebar}} 
STUN (NAT 会话穿越工具) 是一个{{glossary(“NAT”)}} (网络地址转换器) 传递数据的辅助协议。 
STUN 会返回一台位于 NAT 背后的已接入网络的主机的{{glossary(“IP address”)}}(IP 地址)、{{glossary(“port”)}}(端口号) 和连通状态。 
学习更多 
通用知识 
STUN 在 维基百科 
WebRTC 协议 
技术参考 

{{GlossarySidebar}} 
可缩放矢量图形 (SVG) 是一个基于 {{Glossary(“XML”)}} 语法的 2D 矢量图形格式。 
{{Glossary(“W3C”)}} 于 20 世纪 90 年代末开始着手 SVG 的工作，但是当 {{Glossary(“Microsoft Internet Explorer”, “Internet Explorer”)}} 9 推出 SVG 支持时，SVG 才变得流行起来。 
现在所有主流 {{Glossary(“browser”,“browsers”)}} 都支持 SVG。 
基于 {{Glossary(“XML”)}} 语法，你可以使用 {{Glossary(“CSS”)}} 指定 SVG 的样式，并使用 {{Glossary(“JavaScript”)}} 进行交互。 
HTML5 现在允许将 SVG {{Glossary(“Tag”,“tags”)}} 直接嵌入到 {{Glossary(“HTML”)}} 文档中。 
作为一种矢量图像格式，SVG 图形可以无限地扩展，这使其在 {{Glossary(“responsive design”)}} 中非常有用，因为你可以创建可缩放到任意屏幕大小的界面元素和图形。 
SVG 还提供了一组有用的工具，例如裁剪，遮罩，过滤器和动画。 深入了解 
基础知识 
维基百科上的 SVG 
W3.org’s SVG Primer 
SVG documentation on MDN 
Latest SVG specification 

{{GlossarySidebar}} 
Apache Subversion (SVN) 是一个开源免费的源代码控制管理（{{Glossary(“SCM”)}}）系统。 
它允许开发者们保留文本和代码修改历史。 
虽然 SVN 可以操作二进制文件，但是我们不推荐这些文件使用 SVN。 了解更多 
基础知识 
在维基百科上的 SVN 
官方网站 学习 

{{GlossarySidebar}} 
各方都实时（或者尽可能实时）地收取（而且必要的话也处理或者回复）信息的即时沟通方式，即为同步。 
电话即为一个日常的例子：人们都倾向于在使用电话时即时地作出回应。 
许多程序指令也是实时的：例如当输入一个算式时，除非编程人员有意为止，否则环境都会立即将结果反馈回来。 了解更多 
技术参考 
{{glossary(“Asynchronous”)}} 
使用了 XMLHttpRequest() {{glossary(“API”)}} 的同步和异步请求 

{{GlossarySidebar}} 
因为使用了未定义或错误的语法（{{Glossary(“syntax”)}}）而引发的异常（{{Glossary(“exception”)}}）。 
语法错误会在编译或者解析源码的过程中被检测出来。 
例如，如果在定义一个 {{Glossary(“JavaScript”)}} 函数时遗漏了闭合花括号 (})，则触发了一个语法错误。 
浏览器的开发者工具会在控制台输出 {{Glossary(“JavaScript”)}} 和 {{Glossary(“CSS”)}} 语法错误。 
更多 
语法错误 - 维基百科 
{{jsxref(“SyntaxError”)}} - JavaScript 对象 

{{GlossarySidebar}} 
在 {{Glossary(“HTML”)}} 中，tag 用来创建一个 {{Glossary(“element”)}}。 
HTML 元素的名称是在尖括号中使用的名称，例如 <p> 用于段落（paragraph）。 
注意，结束标记的名称前面有一个斜杠字符”</p>“。 
在空元素中，结束标记既不需要也不允许。 在任何情况下，如果没有提及 {{Glossary(”Attribute”, “attributes”)}} ，那么将使用默认值。 了解更多 
基本信息 
维基百科上的HTML element 
HTML Tags on W3 技术参考 
Introduction to HTML 

{{GlossarySidebar}} 
传输控制协议（TCP）是主要的网络协议之一。 
它使两台主机能够建立连接并交换数据流。 
TCP 能保证数据的交付，维持数据包的发送顺序。 
TCP 在 1970 年代被两位 DARPA 的科学家 Vint Cerf 和 Bob Kahn 所设计出来，他们当时被称为互联网之父。 
深入 
TCP 是互联网的基本通信语言协议。 
它会校验包的交付。 
了解更多 
维基百科上关于 TCP 的介绍 

{{GlossarySidebar}} 
{{glossary(‘TCP’)}} slow start helps buildup transmission speeds to the network’s capabilities. 
It does this without initially knowing what those capabilities are and without creating congestion. {{glossary(‘TCP’)}} slow start is an algorithm used to detect the available bandwidth for packet transmission, and balances the speed of a network connection. 
It prevents the appearance of network congestion whose capabilities are initially unknown, and slowly increases the volume of information diffused until the network’s maximum capacity is found. 
To implement TCP slow start, the congestion window (cwnd) sets an upper limit on the amount of data a source can transmit over the network before receiving an acknowledgment (ACK). 
The slow start threshold (ssthresh) determines the (de)activation of slow start. 
When a new connection is made, cwnd is initialized to one TCP data or acknowledgment packet, and waits for an acknowledgement, or ACK. 
When that ACK is received, the congestion window is incremented until the cwnd is less than ssthresh. 
Slow start also terminates when congestion is experienced. 
拥塞控制 
拥塞本身是发生在网络层的一种状态，当消息流量太忙，它减慢了网络响应时间。 
服务器以 TCP 包发送数据，用户的客户端然后通过返回 acknoledgements 或 ack 来确认传输。 
根据硬件和网络条件，连接的容量是有限的。 
如果服务器发送太多的数据包太快，它们将被丢弃。 
意味着，不会有任何确认。 
服务器将其注册为丢失 ACKs。 
拥塞控制算法使用发送的数据包和 ack 流来确定发送速率。 
参阅 
Populating the page: how browsers work 
http overview 

{{GlossarySidebar}} 
计算机科学中的线程是同时运行多个任务或程序的执行。 
每个能够执行代码的单元称为线程。 
{{Glossary(“Main_thread”, “主线程”)}} 是浏览器用来处理用户事件、渲染和绘制显示以及运行组成典型网页或应用程序的大部分代码的线程。 
因为这些事情都发生在一个线程中，一个缓慢的网站或者应用程序脚本会减低整个浏览器的速度；更糟糕的是，如果一个网站或者应用程序脚本进入无限循环，整个浏览器将会挂起。 
这导致了令人沮丧、迟缓（或更糟）的用户体验。 
然而，现代 {{Glossary(“JavaScript”)}} 提供了创建额外线程的方式，每个线程独立执行，同时可能相互通信。 
这是使用例如 {{DOMxRef(“Web_Workers_API”, “web workers”)}} 等技术实现的，这些技术可以用来衍生出一个在自己的线程中与主线程同时运行的子程序。 
这允许缓慢、复杂或者长时间运行的任务独立于主线程执行，以保护网站或者应用程序的整体性能，以及浏览器的整体性能。 
这也允许个人利用现代多核处理器。 
可以创建一种称为 {{DOMxRef(“Service_Worker_API”, “service worker”)}} 的特殊类型的 worker，可以在即使用户当前不使用该网站的情况下在网站背后运行（在用户许可的情况下）。 
这用于创建在用户与网站交互不活跃的情况下当发生事情时能够通知用户的网站。 
例如通知用户收到了电子邮件，即使他们当前没有登录邮箱服务。 
总体而言，可以观察到，我们的操作系统中的这些线程非常有帮助。 
它们有助于最大限度地减少上下文切换时间，实现更高效的通信，并允许进一步使用多处理器体系结构。 
参见 
异步 JavaScript 
Web worker API 
Service worker API 
术语表 
{{Glossary(“Main_thread”, “主线程”)}} 

{{GlossarySidebar}} three.js，一{{Glossary(“WebGL”)}}引擎，基于{{Glossary(“JavaScript”)}}，可直接运行 GPU 驱动游戏与图形驱动应用于{{Glossary(“browser”, “浏览器”)}}。 
其库提供大量特性与{{Glossary(“API”)}}以绘制 3D 场景于浏览器。 了解更多 
小常识 
Three.js维基词条 
three.js 官网 

{{GlossarySidebar}} 
第一字节时间（TTFB）是指从浏览器请求页面到从浏览器接收来自服务器发送的信息的第一个字节的时间。 
这一次包括 DNS 查找和使用（三次）TCP握手和SSL握手建立连接（如果请求是通过https发出的）。 
TTFB 是从请求开始到响应开始之间所用的时间，以毫秒为单位： 
TTFB = responseStart - requestStart 
See Also 
A typical HTTP session 
PerformanceResourceTiming 
PerformanceTiming 

{{GlossarySidebar}} 
传输层安全性协议 (Transport Layer Security，缩写作 TLS)，它的前身是安全套接层 (Secure Sockets Layer，缩写作 SSL)，是一个被应用程序用来在网络中安全通信的 {{Glossary(“protocol”)}} （通讯协议），防止电子邮件、网页、消息以及其他协议被篡改或是窃听。 
所有现代浏览器都支持 TLS 协议，它们都要求服务器提供一个有效的{{Glossary(“Digital certificate”, “digital certificate”)}}（数字证书）来确认身份以建立安全连接。 
如果客户端和服务器都能提供自己的数字证书，则它们可以互相认证。 
基本知识 
传输层安全性协议 
OWASP: 传输层保护备忘单 
维基百科上的Transport Layer Security 
协议规范 
RFC 5246 (传输层安全性协议，版本：1.2) 

{{GlossarySidebar}} 
Tree shaking 是一个通常用于描述移除 JavaScript 上下文中的未引用代码 (dead-code) 行为的术语。 
它依赖于 ES2015 中的 import 和 export 语句，用来检测代码模块是否被导出、导入，且被 JavaScript 文件使用。 
在现代 JavaScript 应用程序中，我们使用模块打包 (如webpack或Rollup) 将多个 JavaScript 文件打包为单个文件时自动删除未引用的代码。 
这对于准备预备发布代码的工作非常重要，这样可以使最终文件具有简洁的结构和最小化大小。 了解更多 
常识 
“捆绑过程中死代码消除的好处” 在 Axel Rauschmayer 的书中:“探索 JS:模块” 
技术参数资料 用 webpack 实现 Tree shaking 

{{GlossarySidebar}} 
在 {{Glossary(“JavaScript”)}} 中，truthy（真值）指的是在{{Glossary(“Boolean”, “布尔值”)}}上下文中，转换后的值为 true 的值。 
被定义为{{Glossary(“Falsy”, “假值”)}}以外的任何值都为真值。（ 
即所有除 false、0、-0、0n、""、null、undefined 和 NaN 以外的皆为真值）。 
{{Glossary(“JavaScript”)}} 在布尔值上下文中使用{{Glossary(“Type_Coercion”, “强制类型转换”)}}。 
JavaScript 中的真值示例如下（将被转换为 true，因此 if 后的代码段将被执行）： 
if (true) 
if ({}) 
if ([]) 
if (42) 
if ("0") 
if ("false") 
if (new Date()) 
if (-42) 
if (12n) 
if (3.14) 
if (-3.14) 
if (Infinity) 
if (-Infinity) 
逻辑与运算 && 
如果第一个对象为真值，则逻辑与运算返回第二个操作数。 
true && "dog" 
// returns "dog" 
[] && "dog" 
// returns "dog" 
参见 
{{Glossary(“Falsy”, “假值”)}} 
{{Glossary(“Type_Coercion”, “强制类型转换”)}} 
{{Glossary(“Boolean”, “布尔值”)}} 

{{GlossarySidebar}} 
TURN (NAT 的中继穿越) 是一个能够让位于{{glossary(“NAT”, “Network Address Translator”)}}(NAT) 或者防火墙之后的主机接受和发送数据的{{Glossary(‘protocol’)}}(协议)。 
学习更多 
通用知识 
TURN 在 Wikipedia 
WebRTC 协议 
技术参考 
IPv6 版 最新详细说明书 

{{GlossarySidebar}} 
{{Glossary(“Type conversion”, “类型转换”)}}类似于强制类型转换，因为它们都将值从一种数据类型转换为另一种数据类型，只有一个关键的区别——强制类型转换是隐式的，而类型转换可以是隐式的，也可以是显式的。 
示例 
const value1 = "5"; 
const value2 = 9; 
let sum = value1 + value2; 
console.log(sum); 
在上面的例子中，JavaScript 将数字 9 强制变成了一个字符串，然后将两个值连接在一起，得到了一个字符串 59。 
JavaScript 在字符串和数字之间进行选择，并决定使用字符串。 
编译器本可以将 5 强制转换为数字并返回 14 的和，但它没有这样做。 
要返回这个结果，你必须使用 {{jsxref(“Global_Objects/Number”, “Number()”)}} 方法显式地将 5 转换为一个数字： 
sum = Number(value1) + value2; 
参见 
类型转换（维基百科） 
术语表 
{{Glossary(“Type”, “类型”)}} 
{{Glossary(“Type conversion”, “类型转换”)}} 

{{GlossarySidebar}} 
类型转换（Type conversion/typecasting）是指将数据由一种类型变换为另一种类型。 在编译器（对于编译语言）或运行时（像 {{glossary(“JavaScript”)}} 等脚本语言）自动转换数据类型时，会发生隐式转换。 
你也可以在源码中显式要求进行转换。 
例如，给定表达式 "foo" + 1，那么{{glossary(“Number”, “数字”)}} 1 会被隐式转换成{{glossary(“String”, “字符串”)}}并且表达式返回 "foo1"。 
给定指令 Number("0x11")，字符串 "x11" 显式转换为数字 17。 
参见 
术语 
{{Glossary(“Type”, “类型”)}} 
{{Glossary(“Type coercion”, “强制类型转换”)}} 

{{GlossarySidebar}} 
类型 (或数据类型) 是决定 {{glossary(“value”)}} 可以存为哪个类型的特性 —例如在 JavaScript 中一个 {{domxref(“Boolean”)}} 只能存放 true或false , 而一个 {{domxref(“String”)}} 能存放任何字符串 , 一个 {{domxref(“Number”)}} 存放任何类型的数字 , 等等… 
值的数据类型也影响哪个操作对该值有效。 
例如，一个整数可以乘以一个整数，而不是一个字符串。 
了解更多 
基本知识 
维基百科的 Data type 
JavaScript 的数据类型 

{{GlossarySidebar}} 
UDP（用户数据报协议）是一个与 {{glossary(“IPv6”,“IP 协议”)}} 一起使用的长期{{glossary(“protocol”, “协议”)}}，用于在传输速度和效率比安全性和可靠性更重要的场合下发送数据。 
UDP 使用一个简单的、具有最小协议机制的无连接通信模型。 
UDP 使用校验和保证数据完整性，使用端口号以区分数据发送方和接收方中不同的应用程序。 
它无需握手会话，即将不可靠的底层网络直接暴露给了用户的应用程序：不保证消息交付、不保证交付顺序也不保证消息不重复。 
如果需要网络接口层面的纠错功能，则应用程序可以使用为此目的设计的传输控制协议（TCP）或者流控制传输协议（SCTP）。 
UDP 适用于不需要差错和纠错的应用程序，它的协议栈避免了处理此类问题的开销。 
对时间敏感的应用程序通常使用 UDP，因为丢弃数据包比等待数据包重传（可能不是实时操作系统可接受的选项）更可取。 
参见 
维基百科上的 用户数据报协议 

{{GlossarySidebar}} 
用户界面 (UI) 是实现人机交互的一类事物的总称。 
在计算机世界中，UI 可以是来自键盘、摇杆、屏幕或程序中的任何东西。 
在计算机软件中，UI 可以是命令行、网页、用户、用户输入的表格或是任何应用的前端。 了解更多 
常识 
维基百科上的 用户界面 
维基百科上的 前端开发 

{{GlossarySidebar}} 
一个声明未定义的变量的初始值，或没有实际参数的形式参数。 
示例 
var x; //创建一个变量，但并没有赋值 
console.log("X 的值是", x); //返回 X 的值是 undefined 
更多 
Undefined value on Wikipedia 
JavaScript data types and data structures 

{{GlossarySidebar}} 
Unicode 是一种{{Glossary(“Character set”,“字符集”)}}标准，用于对来自世界上不同语言、文字系统和符号进行编号和{{Glossary(“Character”,“字符”)}}定义。 
通过给每个字符分配一个编号，程序员可以创建{{Glossary(“Character encoding”,“字符编码”)}}，让计算机在同一个文件或程序中存储、处理和传输任何语言组合。 
在 Unicode 定义之前，在同一数据中混合使用不同的语言是很困难的，而且容易出错。 
例如，一个字符集存储的是日文字符，而另一个字符集存储的是阿拉伯字母。 
如果没有明确标明数据的哪些部分属于哪个字符集，其他程序和计算机就会错误地显示文本，或者在处理过程中损坏文本。 
如果你曾经见过像 (“”) 被替换为胡言乱语 Ã‚Â£，那么你就已经看到过这个被称为 Mojibake 的问题。 
网络上最常见的 Unicode 字符编码是{{Glossary(“UTF-8”)}}。 
还存在一些其他编码，如 UTF-16 或过时的 UCS-2，但推荐使用 UTF-8。 
了解更多 
Unicode on Wikipedia 
The Unicode Standard: A Technical Introduction 

{{GlossarySidebar}} 
Unix 时间是一种表示时间戳的方法，通常定义为自 Unix 纪元（UTC 时间 1970 年 1 月 1 日午夜）开始以来的总秒数，不考虑闰秒。 
在 web 平台上，Unix 时间用于时间戳，并以自 Unix 纪元开始以来的总毫秒数给出。 
参见 
维基百科上的 Unix 时间 
维基百科上的闰秒 

{{GlossarySidebar}} 
URI（统一资源标识符）是一个指向资源的字符串。 
最通常用在 {{Glossary(“URL”)}} 上来指定 Web 上资源文件的具体位置。 
相比之下，{{Glossary(“URN”)}} 是在给定的命名空间用名字指向具体的资源，如：书本的 ISBN。 了解更多 
基础知识 
RFC 3986 on URI 
www vs non-www 

{{GlossarySidebar}} 
统一资源定位器（URL）是指定在 Internet 上可以找到资源的位置的文本字符串。 
在 {{Glossary(“HTTP”)}} 的上下文中，URL 被叫做”网络地址“或“链接”。 
你的浏览器在其地址栏显示 URL，例如 https://developer.mozilla.org 
URL 也可用于文件传输（{{Glossary(“FTP”)}}） ，电子邮件（{{Glossary(“SMTP”)}}）和其他应用。 
了解更多 
基本知识 
在维基百科的 URL 了解 
什么是 URL？ 

{{GlossarySidebar}} 
URN（统一资源名称）是标准格式的 URI，指的是资源而不指定其位置或是否存在。 
这个例子来自RFC3986: urn:oasis:names:specification:docbook:dtd:xml:4.1.2 了解更多 
基础知识 
URN on Wikipedia 

{{GlossarySidebar}} 
用户代理是代表一个人的计算机程序，例如，一个在 {{Glossary(“World Wide Web”, “Web”)}} 上的 {{Glossary(“Browser”,“浏览器”)}}。 
除了浏览器之外，用户代理可以是抓取网页的机器人、下载管理器或可以访问 Web 的其他应用程序。 
随着向服务器发送的每个请求，浏览器包含一个可表明身份的 User-Agent{{Glossary(“HTTP”)}} 的协议头，叫作用户代理（UA，User Agent）字符串。 
此字符串通常标识浏览器、及其版本号及其主机操作系统。 
垃圾邮件机器人、下载管理器和一些浏览器通常会发送一个假 UA 字符串来宣称自己是不同的客户端。 
这被称为用户代理欺骗。 
用户代理的字符串可以被 {{Glossary(“JavaScript”)}} 在客户端中使用 navigator.userAgent 获取。 
典型的用户代理字符串如下所示： "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:35.0) Gecko/20100101 Firefox/35.0". 
了解更多 
基础知识 
在维基百科上的 User agent 
技术参考 
在 RFC 2616 的 User agent 协议头 

{{GlossarySidebar}} 
UTF-8 (UCS Transformation Format 8) 是万维网上最常用的{{Glossary(“Character encoding”, “字符编码”)}}。 
每个字符由 1 到 4 个字节表示。 
UTF-8 与 {{Glossary(“ASCII”)}} 向后兼容，可以表示任何标准的 Unicode 字符。 
前 128 个 UTF-8 字符与前 128 个 ASCII 字符 (编号为 0-127) 精确匹配，这意味着现有的 ASCII 文本已经是有效的 UTF-8。 
所有其他字符都使用 2 到 4 个字节。 
每个字节都有一些用于编码目的的保留位。 
由于非 ASCII 字符需要一个以上的字节来存储，如果字节被分隔而不重组，那么它们就会有损坏的风险。 
了解更多 
UTF-8 on Wikipedia 
FAQ about UTF-8 on Unicode website 

{{GlossarySidebar}} 
UX(User eXperience) 是用户体验的首字母缩写。 
它是研究用户和系统之间的交互。 
其目标是使系统易于从用户的角度进行交互。 
该系统可以是用户最终可以交互的任何类型的产品或应用程序。 
例如，在网页上进行的 UX 研究可以证明用户是否容易理解页面，引导到不同的页面并完成一般操作，以及减少这些过程中用户的操作步骤。 
更多 
维基百科User experience 

{{GlossarySidebar}} 
在数据或对象{{Glossary(“Wrapper”, “包装器”)}}的概念下，值是对象包装器包含的{{Glossary(“Primitive”, “原始值”)}}。 
在{{Glossary(“Variable”, “变量”)}}或{{Glossary(“Property”, “属性”)}}的概念下，值可以是原始类型或{{Glossary(“Object reference”, “对象引用”)}}。 
在 CSS 属性值的概念下，存在指定值、计算值和实际值，应用于每个元素和伪元素的每个 CSS 属性的最终值是一个四步计算的结果：值由定义决定（指定值），然后解析成一个用于继承的值（计算值），然后在必要时转换为绝对的值（应用值），最终根据本地环境的限制进行转化（实际值）。 
关于 CSS 的数据类型，详见 CSS 值和单位。 
参见 
维基百科上的原始值包装类词条 

{{GlossarySidebar}} 
变量是{{Glossary(“Value”, “值”)}}的具名引用。 
这样，不可预测的值可以通过预定的名称来访问。 
参见 
维基百科上的变量（程序设计）词条 
在 JavaScript 中声明变量 
JavaScript 的 var 语句 

{{GlossarySidebar}} 
浏览器厂商们有时会给实验性的或者非标准的 CSS 属性和 JavaScript API 添加前缀，这样开发者就可以用这些新的特性进行试验，同时（理论上）防止他们的试验代码被依赖，从而在标准化过程中破坏 web 开发者的代码。 
开发者应该等到浏览器行为标准化之后再使用未加前缀的属性。 
备注： 浏览器厂商们正在努力停止使用前缀来表示实验性质的代码的行为。 
Web 开发者一直在生产环境的网站上使用这些实验性代码，这使得浏览器厂商更难保证浏览器兼容性和处理新特性；这也伤害了更小众的浏览器，它们被迫添加其他浏览器前缀以加载热门网站。 
现在的趋势是将实验性功能添加在需要用户自行设置偏好或标记（flag）的地方，同时编写一个更小规模的规范，以更快达到稳定状态。 
CSS 前缀 
主流浏览器引擎前缀： 
-webkit- （谷歌，Safari，新版 Opera 浏览器，以及几乎所有 iOS 系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于 WebKit 内核的浏览器） 
-moz- （火狐浏览器） 
-o- （旧版 Opera 浏览器） 
-ms- （IE 浏览器 和 Edge 浏览器） 
示例： 
-webkit-transition: all 4s ease; 
-moz-transition: all 4s ease; 
-ms-transition: all 4s ease; 
-o-transition: all 4s ease; 
transition: all 4s ease; 
API 前缀 
过去，浏览器引擎也使用前缀修饰实验性质的 API。 
如果整个接口都是实验性的，前缀修饰的就是接口名（但不包括其中的属性或者方法）。 
如果将一个实验性的接口或者方法添加到一个标准化的接口中，这个新增的接口或者方法被前缀修饰。 
接口前缀 
需要使用大写的前缀修饰接口名： 
WebKit (谷歌，Safari, 新版 Opera 浏览器，以及几乎所有 iOS 系统中的浏览器 (包括 iOS 系统中的火狐浏览器); 简单的说，所有基于 WebKit 内核的浏览器) 
Moz (火狐浏览器) 
O (旧版 Opera 浏览器) 
MS (IE 浏览器 和 Edge 浏览器) 
属性和方法前缀 
需要使用小写的前缀修饰属性或者方法 
webkit (谷歌，Safari, 新版 Opera 浏览器，以及几乎所有 iOS 系统中的浏览器 (包括 iOS 系统中的火狐浏览器); 简单的说，所有基于 WebKit 内核的浏览器) 
moz (火狐浏览器) 
o (旧版 Opera 浏览器等 
ms (IE 浏览器 和 Edge 浏览器) 
示例： 
var requestAnimationFrame = 
window.requestAnimationFrame || 
window.mozRequestAnimationFrame || 
window.webkitRequestAnimationFrame || 
window.oRequestAnimationFrame || 
window.msRequestAnimationFrame; 
了解更多 
基础知识 
维基百科浏览器引擎前缀（Vendor prefix） 

{{GlossarySidebar}} 
在电脑图形学里面，视口代表了一个可看见的多边形区域（通常来说是矩形）。 
在浏览器范畴里，它代表的是浏览器中网站可见内容的部分。 
视口外的内容在被滚动进来前都是不可见的。 
视口当前可见的部分叫做可视视口（visual viewport）。 
可视视口可能会比布局视口（layout viewport）更小，因为当用户缩小浏览器缩放比例时，布局视口不变，而可视视口变小了。 
了解更多 
常规知识 
Viewport 维基百科 

{{GlossarySidebar}} 
空元素（empty element）是 HTML 中不能存在子节点（例如内嵌的元素或者文本节点）的{{Glossary(“element”, “元素”)}}。 
空元素只有开始标签且不能指定结束标签。 
在 HTML 中，空元素不能有结束标签。 
例如，<input type="text"></input> 是无效的 HTML。 
相反，不能有任何子节点的 SVG 或 MathML 元素可以使用结束标签来代替 XML 开始标签中的自闭合标签语法。 
HTML、SVG 和 MathML 的规范都详细定义了每个元素能包含的具体内容。 
所以一些标签的组合是没有任何语义的。 
尽管无法使用具有子元素的空元素标记，但可以使用 JavaScript 在这些元素的 DOM 中添加子节点。 
但这并不是一个被推荐的做法，因为其结果不可靠。 
在 HTML 中有以下空元素： 
{{HTMLElement(“area”)}} 
{{HTMLElement(“base”)}} 
{{HTMLElement(“br”)}} 
{{HTMLElement(“col”)}} 
{{HTMLElement(“embed”)}} 
{{HTMLElement(“hr”)}} 
{{HTMLElement(“img”)}} 
{{HTMLElement(“input”)}} 
{{HTMLElement(“link”)}} 
{{HTMLElement(“meta”)}} 
{{HTMLElement(“param”)}} {{deprecated_inline}} 
{{HTMLElement(“source”)}} 
{{HTMLElement(“track”)}} 
{{HTMLElement(“wbr”)}} 
自闭合标签 
HTML 中不存在自闭合标签（<tag />）。 

{{GlossarySidebar}} 
WebDAV (Web Distributed Authoring and Versioning) 是一种允许 web 开发者使用客户端远程更新内容的 {{Glossary(“HTTP”)}} 扩展。 
WebDAV 很少单独使用，其通常与以下两个扩展一起使用：{{Glossary(“CalDAV”)}} 和 {{Glossary(“CardDAV”)}}。 
复制和移动网页 

{{GlossarySidebar}} 
浏览器扩展是一种跨浏览器系统，用于开发 Firefox 的浏览器扩展。 
这个系统能够提供许多 API，在很大程度上能够被不同的浏览器所支持，例如 Mozilla Firefox，Google Chrome，Opera 浏览器，微软 Edge 和 Apple Safari 浏览器。 
参见 
MDN 上的 浏览器扩展。 

{{GlossarySidebar}} 
WebGL (Web 图形库) 是一个用于绘制交互式 2D/3D 图形的 {{Glossary(“JavaScript”)}} {{Glossary(“API”)}} ，基于 {{Glossary(“OpenGL”)}} ES 2.0。 
你可以在 {{Glossary(“HTML”)}} {{HTMLElement(“canvas”)}} 元素中调用 WebGL。 
目前所有主流 {{Glossary(“Browser”,“浏览器”)}} 都支持 WebGL，即便如此，WebGL 是否可用还是取决于硬件设备等其他因素（比如 GPU 是否支持 WebGL）。 了解更多 常识 维基百科上的 WebGL 检查你的设备是否支持 WebGL 技术信息 MDN 上的 WebGL 参考资料 WebGL 支持列表 

{{GlossarySidebar}} 
Learn more 
WebP on Wikipedia 

{{GlossarySidebar}} 
WebRTC (Web Real-Time Communication) 是一个可以用在视频聊天，音频聊天或 P2P 文件分享等 Web App 中的 {{Glossary(“API”)}}。 
WebRTC 主要由以下几个部分组成： 
getUserMedia : 为一个 RTC 连接获取设备的摄像头与 (或) 麦克风权限，并为此 RTC 连接接入设备的摄像头与 (或) 麦克风的信号。 
RTCPeerConnection 
: 用于配置音频或视频聊天。 
RTCDataChannel 
: 用于设置两个浏览器之间的{{Glossary(“P2P”, “端到端”)}} 数据连接。 
了解更多 
WebRTC on Wikipedia 
Guide to WebRTC on MDN 
Browser support of WebRTC 

{{GlossarySidebar}} 
WebSocket 是一种在客户端与{{Glossary(“Server”, “服务器”)}}之间保持{{Glossary(“TCP”)}}长连接的{{Glossary(“protocol”,“网络协议”)}}，这样它们就可以随时进行信息交换。 
虽然任何客户端或服务器上的应用都可以使用 WebSocket，但原则上还是指{{Glossary(“Browser”, “浏览器”)}}与服务器之间使用。 
通过 WebSocket，服务器可以直接向客户端发送数据，而无须客户端周期性的请求服务器，以动态更新数据内容。 深入了解 
基本知识 
Websocket 维基百科 
WebSocket 的 MDN 参考 
学习了解 编写 WebSocket 客户端应用 
编写 WebSocket 服务器应用 

{{GlossarySidebar}} 
WHATWG（Web Hypertext Application Technology Working GroupWeb 超文本应用程序技术工作组）是一个负责维护与开发 Web 标准的社区，他们的工作成果包括 {{Glossary(“DOM”)}}、Fetch API，和 {{Glossary(“HTML”)}}。 
一些来自 Apple、Mozilla，和 Opera 的员工在 2004 年建立了 WHATWG。 
了解更多 
General Knowledge 
WHATWG 的网站 

{{GlossarySidebar}} 
万维网（World Wide Web）——一般称其为 WWW、W3 或 the Web——是通过{{Glossary(“Internet”,“互联网”)}}访问公共网页的互连系统。 
Web 与互联网不一样：Web 是建立在互联网之上的许多应用程序之一。 
Tim Berners-Lee 提出了被称为万维网的架构。 
他在 1990 年在 CERN 物理研究实验室的计算机上创建了第一个 web {{Glossary(“server”,“服务器”)}}、web {{Glossary(“Browser”,“浏览器”)}}和网页。 
1991 年，他在 alt.hypertext 新闻组上宣布了他的创作，那一刻标志着 Web 的首次公开。 
我们今天认为的“Web”系统由几个组件组成： 
{{Glossary(“HTTP”)}} 协议，管理服务器和客户端之间的数据传输。 
要访问 Web 组件，客户端提供唯一的通用标识符，称为 {{Glossary(“URL”)}}（统一资源定位符）或 {{Glossary(“URI”)}}（统一资源标识符）（正式称为通用文档标识符（UDI））。 
{{Glossary(“HTML”)}}（超文本标记语言）是发布 Web 文档的最常用格式。 
通过{{Glossary(“Hyperlink”,“超链接”)}}连接资源是 Web 的定义概念，帮助其身份作为连接文档的集合。 
Tim Berners-Lee 在发明 Web 之后不久就创建了 {{Glossary(“W3C”)}}（万维网联盟），进一步规范和开发 Web。 
该联盟由核心 Web 兴趣小组组成，如网页浏览器开发人员、政府机构、研究人员和大学。 
其使命包括教育和外联。 
参见 
学习网络 
维基百科上的万维网词条 
W3C 网站 

{{GlossarySidebar}} 
XHTML（eXtensible HyperText Markup Language，可扩展超文本标记语言）是在历史上被用来描述 HTML文档的术语，这些文档是按照 {{Glossary(“XML”)}} 语法规则编写的。 
下面的例子显示了一个 HTML 文档和相应的“XHTML”文档，以及应当搭配使用的 {{Glossary(“HTTP”)}} {{HTTPHeader(“Content-Type”)}} 标头。 
HTML 文档 
<!-- Content-Type: text/html --> 
<! 
doctype html> 
<html lang="zh-CN"> 
<head> 
<meta charset="utf-8" /> 
<title>HTML</title> 
</head> 
<body> 
<p>我是 HTML 文档</p> 
</body> 
</html> 
XHTML 文档 
<!-- Content-Type: application/xhtml+xml --> 
<? 
xml version="1.0" encoding="UTF-8"? 
> 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN"> 
<head> 
<title>XHTML</title> 
</head> 
<body> 
<p>我是 XHTML 文档</p> 
</body> 
</html> 
在实践中，很少有“XHTML”文档在网络上以 Content-Type: application/xhtml+xml 标头提供。 
即使这些文件是按照 XML 语法规则编写的，它们也是以 Content-Type: text/html 标头提供的——因此浏览器使用 HTML 解析器而不是 XML 解析器来解析这些文件。 
参见 
HTML 
HTML5 
SVG 
MathML XML 

{{GlossarySidebar}} 
{{domxref(“XMLHttpRequest”)}} (XHR) 是一种创建 {{Glossary(“AJAX”)}} 请求的 {{Glossary(“JavaScript”)}} {{Glossary(“API”)}} 。 
它的方法提供了在{{Glossary(“browser”,“浏览器”)}}和{{Glossary(“server”,“服务器”)}}之间发送请求的能力。 了解更多 
常识 
维基百科上的 XMLHttpRequest 

{{GlossarySidebar}} 
可扩展标记语言（XML）是由 W3C 指定的一种通用标记语言。 
信息技术（IT）行业使用许多基于 XML 的语言作为数据描述性语言。 
XML 标签 类似 HTML 标签，但由于 XML 允许用户定义他们自己的标签，所以 XML 更加灵活。 
从这个层面来看，XML 表现的像一种元语言——也就是说，它可以被用来定义其他语言，例如 {{Glossary(“RSS”)}}。 
不仅如此，HTML 是陈述性语言，而 XML 是数据描述性语言。 
这意味着 XML 除了 Web 之外有更远更广的应用。 
例如，Web 服务可以利用 XML 去交换请求和响应。 
了解更多 
XML 介绍 

{{GlossarySidebar}} 
XPath 是一种可以访问{{glossary(“XML”)}} 文件中的节和内容的查询语言 了解更多 
技术参考 
XPath documentation on MDN 
XPath specification 
基本信息 
Official website 

{{GlossarySidebar}} 
XQuery 是一门用于更新、检索以及计算 {{glossary(“XML”)}} 数据库中数据的计算机语言。 
了解更多 
Official website 
维基百科上的XQuery 




{{LearnSidebar}} 
如果你想成为一个 web 开发者，学习一些 HTML、CSS 和 JavaScript 是很有用的，但是仅仅使用这些技术是不够的，重要的是要学会如何负责任地使用这些技术，以便所有读者都可能在网上使用你的创作。 
为了达到这个目的，要遵循一般最佳实践（这些最佳实践已经被 HTML、CSS 和 JavaScript 相关的主题所证明）进行跨浏览器测试，并且从项目最初阶段就把无障碍性考虑在内。 
在这个模块中我们将会详细讨论后者。 
概述 
当有人将一个网站描述为“无障碍”时，他们的意思是，任何用户都可以使用其所有的功能和内容，无论用户是如何访问网络的——甚至特别是有身体或精神障碍的用户。 
键盘、鼠标和触摸屏用户，以及用户访问网络的任何其他方式，包括像 Alexa 和 Google Home 这样的屏幕阅读器等语音助手，都应该能够访问网站。 
无论人们的听觉、视觉、身体或认知能力如何，应用程序都应该是可以理解和使用的。 
网站也不应该造成伤害：像动画（motion）这样的 web 特性会导致偏头痛或癫痫发作。 
默认情况下，HTML 在使用正确的时候是可以实现无障碍的。 Web 无障碍涉及确保内容保持无障碍，无论访问 web 的人员或方式。 
Firefox 浏览器无障碍检查器是一个非常有用的工具，用于检查网页的无障碍问题。 
下面的视频对它做了很好的介绍： 
{{EmbedYouTube(“7mqqgIxX_NU”)}} 
标注： 
想要成为一名前端工程师？ 
我们汇总了一门课程，其中包含你实现成为前端工程师目标所需要的所有基本信息。 
从这里开始 
为了充分理解这个模块，你至少需要读过 HTML、CSS 和 JavaScript 各个主题的前两个模块，或者有可能的话，在你学习相关联的技术话题时也把无障碍相关的内容学习了，这样会更好。 
备注： 如果在你所使用的设备上不能建立自己的文件，你可以使用在线编码平台运行大多数样例代码，比如 JSBin 或者 Glitch。 
指南 
什么是无障碍？ 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/Accessibility/Multimedia”,“Learn/Accessibility/Accessibility_troubleshooting”, “Learn/Accessibility”)}} 
随着通过手机设备访问 web 愈加常见，iOS 和 Android 等流行的平台都拥有了完善的无障碍工具，在这些平台上考虑 web 的无障碍是一件很重要事情。 
本文将着重介绍移动端无障碍的注意事项。 
前提： 
具备基本的计算机知识，对 HTML、CSS 和 JavaScript 基本的了解，并理解之前课程中的文章。 


{{LearnSidebar}}{{PreviousMenuNext(“Learn/Accessibility/CSS_and_JavaScript”,“Learn/Accessibility/Multimedia”, “Learn/Accessibility”)}} 
紧接上文继续，有时候，我们制作涉及非语义 HTML 和动态的 JavaScript 内容更新的复杂 UI 控件可能很困难。 
WAI-ARIA 是一项技术，它可以通过浏览器和一些辅助技术来帮助我们进一步地识别以及实现语义化，这样一来能帮助我们解决问题，也让用户可以了解发生了什么。 
接下来我们将展示如何运用它来优化无障碍体验： 
前提要求： 
基础的电脑知识，对于 HTML，CSS，JavaScript 的了解，还有对于前文课程的了解。 



{{LearnSidebar}} 
本节列出了与美学、页面结构、辅助功能等相关的问题。 
我该怎样开始设计我的网站？ 



{{LearnSidebar}} 



{{QuicklinksWithSubPages(“/zh-CN/docs/Learn/Common_questions”)}} 
Google App Engine 是一个功能强大的平台，它能让你在谷歌的 infrastructure 上构建并运行应用，你可以在这上面：从头构建多层 WEB 应用，或建立一个静态网站。 
接下来是手把手入门的教程： 
创建一个谷歌云平台项目 
为了在你自己的网站或者 app 使用谷歌的工具，你需要在谷歌云平台上创建一个新项目 ( a new project ) 当然，需要谷歌账号。 
打开谷歌云平台控制台（Google Cloud Platform Console），再打开 App Engine dashboard 页面 并点击 Create . 
如果从未创建过项目 (project)，会提示你是否选择接收邮箱升级，并需要同意团队服务条款才能继续。 
键入项目名，并编辑项目 ID(请记下你的项目 ID) 本教程的示例值： 
Project Name: GAE Sample Site 
Project ID: gaesamplesite 
点击 Create 以创建工程 
创建一个应用 (application) 
每个云平台项目都可以包含一个 APP 引擎应用，所以我们来为自己的项目准备一个 app 
我们需要一个样例应用来发布。 
如果你还没有，请下载 sample app 并解压。 
看一下这个样例应用的结构—website文件夹包括你的网站内容，app.yaml文件是你的应用配置文件 
你的网站内容必须放在website文件夹下，并且入口文件必须取名为index.html，其他部分可以自行定义。 
app.yaml 文件是一个配置文件，它高速应用引擎怎么映射 UR 到你的静态文件，你不需要编辑它。 
发布你的应用 
打开Google Cloud Shell. 
把 sample-app目录拖拽到代码编辑器左边 
gcloud config set project gaesamplesite 
键入如下命令 进入到 app 的 目录： cd sample-app 
你现在可以部署应用程序，即将应用程序上传到 App Engine： 
gcloud app deploy 
现在你可以在浏览器中访问你的站点了，比如对于项目 ID 是gaesamplesite 的网站, go 输入 gaesamplesite.appspot.com访问。 
更多信息 


{{LearnSidebar}} 
本部分列出了与可用于构建网站的工具/软件相关的问题。 
你需要什么软件用来造一个网站？ 

{{QuicklinksWithSubPages(“/zh-CN/docs/Learn/Common_questions”)}} 
本文将会介绍如何在你的计算机上安装一个简单的本地测试服务器，以及它的基本用法。 
前提： 
你需要知道互联网是怎么工作的，以及什么是 web 服务器。 


{{QuicklinksWithSubPages(“/zh-CN/docs/Learn/Common_questions”)}} 
GitHub是一个“公共编码”网站。 
它允许你上传代码存储库并存储在 Git 版本控制系统上。 然后，你可以在代码项目上进行协作，默认情况下系统是开源的，这意味着世界上任何人都可以找到你的 GitHub 代码，使用它，从中学习，并改进它。 同样的，对于其他人的代码你也可以这么做！ 
本文提供了一个基本的指南，即使用 Github 的 gh-pages 功能发布内容。 发布内容 
GitHub 有一个非常有用的功能，称为GitHub Pages，它允许你在 Web 上实时发布网站代码。 基本 Github 设置 
准备上传代码 
你可以将任何你喜欢的代码存储在 Github 资源库中，但要使用 GitHub Pages 功能实现全面效果，你的代码应该被构造为典型的网站，例如主入口点是一个名为 index.html 的 HTML 文件。 
如果你已经将你的网站放到了位于桌面上的 test-site 目录中，则可以输入以下内容： 
cd Desktop/test-site 
Linux: 通常你可以用 Ctrl + Alt + T 启动一个终端。 
git remote add origin https://github.com/chrisdavidmills/my-repository.git 
git commit -m 'adding my files to my repository' 
git push -u origin master 
如果你的网站的入口点不是这个，例如 myPage.html，你需要访问 https://xxxxxx/myPage.html。 更多的 GitHub 知识 
git commit -m 'another commit' 

{{QuicklinksWithSubPages(“/zh-CN/docs/Learn/Common_questions”)}} 
每一个现代网络浏览器都包含一套强大的开发工具套件。 
这些工具可以检查当前加载的 HTML、CSS 和 JavaScript，显示每个资源页面的请求以及载入所花费的时间。 
本文阐述了如何利用浏览器的开发工具的基本功能。 
备注： 在你运行下面的例子之前，打开我们在Web 开发入门系列文章中建立的初学者示例网站。 
你应该按照下面的步骤打开。 
如何在浏览器中打开开发者工具 
开发者工具内置在你的浏览器的子窗口之中，大概像这样： 
如何打开它？ 
有三种方式： 
Internet Explorer. F12 
Mac OS X. ⌘ + ⌥ + I 
菜单栏 
Firefox：菜单 ➤ Web 开发者 ➤ 切换工具箱（译者注：此处修改为最新的 Firefox Quantum），或者工具栏中的 ➤ Web 开发者 ➤ 切换工具箱 
Chrome：菜单 ➤ 更多工具 ➤ 开发者工具 
Safari：Develop ➤ Show Web Inspector。 
如果你看不到 Develop 菜单，去到Safari ➤ Preferences ➤ Advanced，然后点击Show Develop menu in menu bar 复选框。 
Opera. Developer ➤ Web Inspector 
右键菜单：右键单击网页中的一个项目上（在 Mac 上按 Ctrl 点击），并从弹出的菜单中选择检查元素（译者注：选择检查（Chrome）或查看元素（Firefox））。（ 
检查器（Inspector）：DOM 浏览器和 CSS 编辑器 
开发者工具在打开时默认为检查器页面，如下图所示。 
这个工具可以让你看到你的网页的 HTML 运行时的样子，以及哪些 CSS 规则被应用到了页面上元素。 
它还允许你立即修改 HTML 和 CSS 并在浏览器中实时观察修改的结果。 
如果你看不到调试器， 
点击“检查”选项卡。 
在 Internet Explorer 中，点击 DOM Explorer，或按 Ctrl + 1。 
在 Safari 中，控制就不是很清楚了，但是你如果你没有选择的东西出现在窗口看到 HTML。 
按下按钮查看 CSS 样式。 
探索 DOM 检查器 
首先在 DOM 检查器中右键单击（按 Ctrl 点击）一个 HTML 元素，看上下文菜单。 
菜单选项各不相同，但主要功能是相同的： 



{{LearnSidebar}} 
本部分涵盖与 Web 生态系统的一般知识及其工作原理相关的问题。 
互联网是怎么工作的？ 

{{QuicklinksWithSubPages(“/zh-CN/docs/Learn/Common_questions”)}} 
在本文中我们描述了各种与网络相关的概念：网页，网站，网络服务器，以及搜索引擎。 
这些概念常被网络新手混淆，或被误用。 
让我们看看它们到底代指的是什么吧！ 
前提： 
了解 互联网是怎么工作的 
目标： 
了解网页，网站，网络服务器和搜索引擎间的区别 
概述 
正如任何领域的知识一样，网络也有很多的术语。 
别担心，我们不会把你淹没在这些术语里的（但如果你感兴趣的话，我们也弄了一个术语表）然而，一开始你还是需要了解一些基本概念，因为当你读下去的时候，这些词汇会一再出现。 
有时候这些概念容易被混淆，因为他们指的是相关但不同的功能。 
事实上，有时你会见到这些概念在新闻中或者其他地方被误用，所以把他们弄混了也是情有可原的！ 
随着进一步地探讨，我们将会涵盖这些概念和技术的方方面面，但以下的这些简单定义可以帮助你快速开始： 
网页（webpage） 
: 一份能够显示在网络浏览器（如 Firefox,，Google Chrome，Microsoft Internet Explorer 或 Edge，Apple 的 Safari）上的文档。 
网页也常被称作”web pages”（网页）或者就叫”pages”（页面）。 
网站（website） 
: 一个由许多网页组合在一起，并常常以各种方式相互连接的网页组成的集合。 
网站常被称作”web site”（网站）或简称”site”（站点）。 
搜索引擎（search engine） 
: 帮助你寻找其他网页的网站，比如 Google，Bing，或 Yahoo。 
自主学习 


{{QuicklinksWithSubPages(“/zh-CN/docs/Learn/Common_questions”)}} 
本文中我们讨论了域名是什么，域名是如何被构建的，以及如何获得一个域名。 
前提： 首先你得知道 互联网是怎么工作的 并理解 什么是 URL。 











{{LearnSidebar}}{{PreviousMenuNext(“Learn/CSS/Building_blocks/Backgrounds_and_borders”, “Learn/CSS/Building_blocks/Overflowing_content”, “Learn/CSS/Building_blocks”)}} 


{{LearnSidebar}} 
该任务的目的是帮助你检查对我们在本课程Images, Media and Form elements(图像，媒体及表格元素）中了解的一些值和单位的理解。 
备注： 你可以在下面的交互式编辑器中尝试解决方案，但是下载代码并使用诸如CodePen, jsFiddle, Glitch 之类的在线工具来完成任务可能会更加有所帮助。 
如果你遇到困难，联系我们获得帮助 — 参见页面底部的评价以及更多帮助 
任务一 
在此任务中，你有一张溢出盒子的图像。 
我们希望图像缩小到适合盒子的大小，而没有多余的空白，并不介意某些图像是否被裁剪。 
An image in a box 
在下面的例子中看看你能否能符合上面的图片 
{{EmbedGHLiveSample(“css-examples/learn/tasks/images/object-fit.html”, ‘100%’, 1000)}} 
备注： 为了为了评估或进一步完成任务，请下载此任务的起点，以便在你自己的编辑器或在线编辑器中工作。 
任务二 
在此任务中，你会获得一个简单的表格。 
你的任务是对该表单的外观进行以下更改： 
使用属性选择器定位.myform 中的搜索 (search)字段和按钮。 
使表单字段和按钮使用与表单其余部分相同的文本大小。 
给表单字段和按钮设置 10 像素的内边距。 
为按钮提供紫色背景，白色前景，无边框和 5px 的圆角。 
A single line form 
尝试更改下面的实时代码以重新创建图像中显示的示例： 
{{EmbedGHLiveSample(“css-examples/learn/tasks/images/form.html”, ‘100%’, 600)}} 
备注： 为了为了评估或进一步完成任务，请下载此任务的起点，以便在你自己的编辑器或在线编辑器中工作。 
评价以及更多帮助 
你可以在上面提到的交互式编辑器中练习这些示例。 
如果你希望对自己的工作进行评估，或者遇到困难并希望寻求帮助，请执行以下操作： 
将你的工作上传到在线共享编辑器中，例如 CodePen, jsFiddle, Glitch.。 
你可以自己编写代码，也可以使用以上部分中链接到的起点文件。 
在MDN Discourse forum Learning category. “学习”类别中写一篇帖子，要求评估帮助。 
你的帖子应包括： 
描述性标题，例如“Assessment wanted for Images skill test 1”。 
你已经尝试过的内容以及你希望我们做什么的详细信息，例如 如果你陷入困境并需要帮助，或者需要评估。 
指向你要评估或需要帮助的示例的链接（如上面的步骤 1 中所述）。 
这是很好好习惯 - 如果看不到代码，很难帮助存在问题的人。 
指向实际任务或评估页面的链接，因此我们可以找到你需要帮助的问题。 

{{LearnSidebar}} 
这个模块承接学习 CSS 第一步——即你对 (CSS) 语言和其语法已经足够熟悉、并且有了一些基本的使用经验，该是稍微深入点学习的时候了。 
这个模块着眼于级联和继承，所有可供使用的选择器类型，单位，尺寸，背景、边框样式，调试，等等等等。 
本文目标是，在你进一步了解为文本添加样式和 CSS 布局之前，为你提供一个助你写出合格 CSS 和理解所有基本理论的工具箱。 
先决条件 
在开始本模块之前，你应该已经掌握： 
使用计算机的基本知识，能够被动使用网络（也就是查看网页的内容）。 
建立基本工作环境（详见安装基础软件），知道如何建立和管理文档（详见处理文件）。 
HTML 基础知识（参见 HTML 介绍模块）。 
CSS 基础知识（参见学习 CSS 第一步模块）。 
备注： 如果你此刻正使用一台电脑/笔记本/其他设备，而你无法创建自己的文件，那你可以在诸如 JSBin 或 Glitch 等网络编辑程序上尝试（多数）程序案例。 
指南 
本模块包含以下文章，这些文章覆盖了绝大部分 CSS 语言基础。 
在学习这些文章的过程中，会有很多练习题供你检验自己的理解程度。 
层叠与继承 
: 本节目标是帮你建立对——层叠、优先级和继承——这三个最基本的 CSS 概念的理解。 
这些概念控制着 CSS 如何应用于 HTML 以及应用时的优先顺序。 
: 有各种类型的 CSS 选择器，以供我们精确选出要添加样式的元素。 
在本文及其子文章中，我们会详细过一遍不同类型的选择器，以此窥探 CSS 选择器的运行机理。 
子文章包括了： 
类型、类以及 ID 选择器 
属性选择器 
伪类与伪元素 
关系选择器 
盒模型 
: 所有 CSS 都是包在盒子里的，那么理解这些盒子就是让我们能够创建 CSS 布局或排列元素的关键点了。 
为了接下来能完成编写复杂布局的任务，本节我们会认真看看CSS 盒模型，了解其原理及相关术语。 
背景与边框 
: 在这一节课中，我们将会看一下你可以用 CSS 对背景和边框进行哪些创新。 
通过添加渐变、背景图片和圆角，背景和边框可以解决许多 CSS 中的样式问题。 
处理不同的文本方向 
: 最近几年来，CSS 进行了演化，以更好地支持不同方向的内容，既包括自左至右，又包括自上至下（如日语）的内容——这些不同的排布方向被称作书写模式。 
随着你在这部分学习中不断前进并开始设计网页布局，理解书写模式将会非常有帮助，因此我们会在本文中进行介绍。 
溢出的内容 
: 这一节我们会关注 CSS 中的另一个重要的概念——溢出。 
溢出发生在一个盒子中包含了过多内容以致超出适当的范围时。 
在这篇指南中，你将学到什么是溢出以及如何处理它。 
值和单位 
: CSS 中每一个属性都有一个取值或者一系列合理的取值。 
这一节，我们将了解一些最常用的取值和单位。 
在 CSS 中调整大小 
: 通过目前为止的一系列课程，你已经了解了许多使用 CSS 调整网页项目大小的方法。 
了解你所设计的不同特性将呈现的大小很重要，我们将在这节课中总结使用 CSS 调整大小的不同方法，并定义几个有关尺寸的术语，这将对你有所帮助。 
图片、媒体和表单元素 
: 在这一节，我们会了解 CSS 是如何处理一些特殊元素的。 
与常规的盒子相比，图片、其他媒体和表格元素对你使用 CSS 设置样式的能力提出了不同的要求。 
理解什么能够实现和什么不能够实现将会免去你一些沮丧，这节课会突出一些你需要了解的主要问题。 
样式化表格 
: 设计 HTML 表格的样式并不是多么美妙的工作，但有时却是我们都需要去做的。 
这篇文章通过突出一些特定的表格样式技巧，为设计好看的 HTML 表格提供了一份指南。 
调试 CSS 
: 有时在编写 CSS 的过程中，你会遇到这样一个问题：你的 CSS 并没有实现你想要的效果。 
这篇文章将为你提供指导，教你如何调试 CSS 问题，以及如何使用所有现代浏览器带有的开发者工具找到问题所在。 
组织 CSS 
: 当你开始处理更大的样式表和项目时，你将会发现维护一个庞大的样式表非常具有挑战性。 
在这篇文章中，我们将会简要了解使得 CSS 易于维护的最佳做法，以及其他人所使用的一些有助于增进可维护性的解决方案。 
评估 
下面这些评估将测试你对以上那些指南中的 CSS 技能的掌握。 
基本的 CSS 理解 
: 这项评估测试你对基本语法、选择器、特异性、盒子模型的掌握。 
设计漂亮的信头信笺 
: 如果你想留下良好的印象，用一张漂亮的信头信笺写一封信一定是个好的开始。 
在这一评估中，你将挑战创建这样一个漂亮的网络样板。 
一个炫酷的盒子 
: 在这里，你将练习使用背景和边距来创建一个吸引眼球的盒子。 
参见 
高级区块效果 
: 这篇文章展示了盒子的小技巧，提供了一些高级特性的介绍，这些特性不适合其他类别的样式，比如盒子阴影、混合模式和滤镜。 







{{LearnSidebar}} 
这个任务的目的是帮助你理解 CSS 里的选择器。 
备注： 你可以在下面的交互式编辑器中尝试解决问题，然而把代码下载然后使用一个在线工具比如 CodePen、jsFiddle 或 Glitch 去解决这些问题可能对你更有作用。 
如果你卡住了，可以向我们寻求帮助——请参阅本页底部的打分评估或进一步帮助部分。 选择器一 
在没有改变 HTML 的情况下，使用 CSS 去完成下面的要求：: 使一级标题的字体颜色为蓝色 
Text with the CSS applied for the solution to task 1. 
尝试更新下面的实时代码，以重现完整的示例： 
{{EmbedGHLiveSample(“css-examples/learn/tasks/selectors/type.html”, ‘100%’, 700)}} 
如需提交测评或进一步练习，下载本任务的初始文件，然后在本地或在线编辑器中练习。 选择器二 
让 id 为 special 的元素有一个黄色背景。 
让使用类 alert 的元素有一个 1px 的灰色边框。 
如果一个元素使用了 alert 类还有 stop类，让它的背景变为红色。 
如果一个元素使用 alert 类还有 go类，让它的背景变为绿色。 
Text with the CSS applied for the solution to task 2. 
尝试更新下面的实时代码，以重现完整的示例： 
{{EmbedGHLiveSample(“css-examples/learn/tasks/selectors/class-id.html”, ‘100%’, 800)}} 
标注： 
如需提交测评或进一步练习，下载本任务的初始文件，然后在本地或在线编辑器中练习。 
选择器三 
链接文本的样式：使链接为橘色，被访问后变为绿色，当被 hover 时，移除链接文本的下划线。 
Text with the CSS applied for the solution to task 3. 
尝试更新下面的实时代码，以重现完整的示例： 
{{EmbedGHLiveSample(“css-examples/learn/tasks/selectors/pseudo.html”, ‘100%’, 800)}} 
标注： 
如需提交测评或进一步练习，下载本任务的初始文件，然后在本地或在线编辑器中练习。 
选择器四 
移除使用了 list 类的无序列表的子元素前面的圆点，并给他们添加一个 1px 的灰色下边框。 
Text with the CSS applied for the solution to task 4. 
尝试更新下面的实时代码，以重现完整的示例： 
{{EmbedGHLiveSample(“css-examples/learn/tasks/selectors/combinators.html”, ‘100%’, 800)}} 
标注： 
如需提交测评或进一步练习，下载本任务的初始文件，然后在本地或在线编辑器中练习。 
选择器五 
在最后一个任务中，使用属性选择器添加 CSS 以执行以下操作： 
选择带有 title 属性的 <a> 元素，将其边框颜色设置为粉色（border-color: pink）。 
选择带有 href 属性且属性值中包含 contact 的 <a> 元素，将其边框颜色设置为橙色（border-color: orange）。 
选择 href 属性值以 https 开头的 <a> 元素，将其边框颜色设置为绿色（border-color: green）。 
Four links with different color borders. 
尝试更新下面的实时代码，以重现完整的示例： 
{{EmbedGHLiveSample(“css-examples/learn/tasks/selectors/attribute-links.html”, ‘100%’, 800)}} 
标注： 
如需提交测评或进一步练习，下载本任务的初始文件，然后在本地或在线编辑器中练习。 
打分评估或进一步帮助 
你可以在上面的交互式编辑器中练习示例这些示例。 
如果你想得到任务评价，或者遇到了问题需要帮助，请按如下操作进行： 
将你的作业上传到可共享的在线编辑器上，比如 CodePen、jsFiddle 或 Glitch。 
你可以自己编写代码，也可以使用上面给出的初始文件。 
在 MDN 论坛的学习板块上发帖以寻求打分或帮助。 
你的帖子中应包含： 
如“Assessment wanted for Selectors skill test 1”（请使用英文发帖）。 
详细描述你的尝试和你预期的网页效果。 比如你在哪个位置需要帮助，或者你需要打分评估。 
你需要打分或帮助的作业链接（通过上述的在线编辑器上传）。 
只有让别人看到你的代码，你才能得到更好的帮助。 
本题的链接。 让别人知道你所问的具体题目。 




{{LearnSidebar}} 
此任务的目的是为了帮助你检测在样式化表格课程中学到的技巧的理解。 
备注： You can try out solutions in the interactive editors below, however it may be helpful to download the code and use an online tool such as CodePen, jsFiddle, or Glitch to work on the tasks. 
If you get stuck, then ask us for help — see the Assessment or further help section at the bottom of this page. 
任务 
在之前的课程中，我们以一种杀马特的方式样式化了一个表格。 
在这个任务中，我们打算样式化同样的表格，但是使用一些在外部文章Web 排版：设计可读而不是可看的表格概述的表格设计良好实践。 
我们要完成的表格如下图所示。 
完成这个任务有许多方法，但是我建议你使用和向导中所用的相似的模式来完成以下的事情。 
把标题和包含数字的列数据右对齐 
把标题和包含文本的列数据左对齐 
添加顶部和底部边框，以及页脚上方的边框 
将主表的所有奇数行条纹化 
A table with striped rows. 
{{EmbedGHLiveSample(“css-examples/learn/tasks/tables/table.html”, ‘100%’, 1000)}} 
备注： For assessment or further work purposes, download the starting point for this task to work in your own editor or in an online editor. 
Assessment or further help 
You can practice these examples in the Interactive Editors mentioned above. 
If you would like your work assessed, or are stuck and want to ask for help: 
Put your work into an online shareable editor such as CodePen, jsFiddle, or Glitch. 
You can write the code yourself, or use the starting point files linked to in the above sections. 
Write a post asking for assessment and/or help at the MDN Discourse forum Learning category. 
Your post should include: 
A descriptive title such as “Assessment wanted for tables skill test”. 

{{learnsidebar}} 
本技能测试的目的是评估你是否完全理解了 CSS 中的背景和边框教程的内容。 
备注： 你可以在下面的互动编辑器中尝试解决方案。 
然而，下载代码并使用在线工具，如 CodePen、jsFiddle 或 Glitch 来完成任务可能会有所帮助。 
如果你遇到了困难，那就向我们寻求帮助吧——见本页面底部的评估或进一步帮助部分。 
任务 1 
在这个任务中，我们希望你能为一个页面的标题添加背景、边框和一些简单的样式： 
令这个盒子的边框宽度为 5px，且为黑色实心（solid）的，圆角半径为 10px。 
添加背景图片（使用 balloons.jpg URL），调整它的大小，令其覆盖整个盒子。 
给予 <h2> 一个半透明的黑色背景颜色，并使文本为白色。 
你的最终结果看起来应该如下图所示： 
图片显示了一个有照片背景的盒子，圆形的边框和半透明的黑色背景上的白色文字 
尝试更新下面的实时代码，重现完成的示例： 
{{EmbedGHLiveSample(“css-examples/learn/tasks/backgrounds/backgrounds1.html”, ‘100%’, 700)}} 
标注： 
下载这项任务的初始代码，在你自己的编辑器或在线编辑器中完成测试。 
任务 2 
在这个任务中，我们希望你为一个装饰性的盒子添加背景图片、边框和其他一些样式： 
给这个盒子加一个 5px 的淡蓝色（lightblue）边框，设定左上角圆角半径为 20px，右下角圆角半径为 40px。 
标题使用 star.png 图像作为背景图像，左边是一颗居中的星星，右边是重复的星星图案。 
确保标题文本不覆盖图像，并且居中——你将需要使用在以前的课程中学到的技术来实现这一点。 
你的最终结果看起来应该如下图所示： 
图片显示了一个在左上角和右下角有圆角蓝色边框的盒子。 
文字的左边有一颗星星，右边有 3 颗星星 
尝试更新下面的实时代码，重现完成的示例： 
{{EmbedGHLiveSample(“css-examples/learn/tasks/backgrounds/backgrounds2.html”, ‘100%’, 700)}} 
标注： 
下载这项任务的初始代码，在你自己的编辑器或在线编辑器中完成测试。 
评估或进一步帮助 
可以在互动编辑器中完成上面的练习。 
如果你期望对练习结果进行评估，或者遇到困难需要帮助，可以： 
可借助 CodePen、jsFiddle、Glitch 等在线编程实用工具完成任务。 
在那里你可以自行编写代码，也可以使用上文中所给的初始代码。 
在 MDN 论坛学习区发帖寻求他人的评估和帮助。 
你发表的文章应包括： 
一个描述性的标题，比如“Assessment wanted for backgrounds and borders skill test 1”。 
讲清你已经做出的努力，以及需要我们做什么，比如你遇到了困难并需要帮助，或者期望得到评估。 
一个链接指向你需要得到评估或帮助的实例，步骤 1 中三个在线编程工具之一均可。 
我们对希望得到帮助但由不提供代码的求助也很无奈。 
一个链接指向 MDN 测试的原始页面，在那里我们可以找到你需要获得帮助的原始信息。 





{{LearnSidebar}} {{PreviousMenu(“Learn/CSS/CSS_layout/Supporting_Older_Browsers”, “Learn/CSS/CSS_layout”)}} 
如果你已经完成了本模块的学习，那么你就已经掌握了今天进行 CSS 布局所需要的基本知识，并且也可以使用旧的 CSS。 
这个任务将通过使用各种技术开发一个简单的网页布局来测试你的一些知识。 
预备条件： 
在尝试此评估之前，你应该已经阅读了本模块中的所有文章。 
学习目标： 
测试对 CSS 弹性盒、栅格、浮动和定位布局方法的基本理解。 
从这里开始 
你可以在这里下载基本的 HTML、CSS 和六张图片素材。 
将 HTML 文档和样式表文件保存到你自己计算机的目录中，并将图像添加到名为 images 的文件夹中，在浏览器中打开 index.html 文件应该会提供一个具有基本样式但没有布局的页面，该页面应该类似下面所示的图像。 
布局任务的起点。 
这些元素没有被整齐地排列。 
有一个网站的标题，上面是一个黑色的导航条，有 5 个链接平齐在左边，后面是博客文章的标题和文章内容。 
在博客标题和博客内容之间，有一张照片是平齐在左边。 


{{LearnSidebar}} 
此任务的目的是让你使用 CSS 网格布局，并测试你是否了解网格和网格项的行为方式。 
你将会完成三个包括不同的元素小任务。 
备注： 你可以在下面的交互式编辑器中试用解决方案，不过，下载代码并使用在线工具 (如 CodePen、jsFiddle 或 Glitch) 处理这些任务可能会更有帮助。 
如果你遇到困难，请向我们寻求帮助 — 参阅本页底部的 评估或进一步帮助 部分。 
网格布局 一 
在此任务中，你需要创建一个网格，要求其中的四个子元素能自动排布。 
网格内要有三列并且将可用空间等分，列和行的间距均为 20px。 
在三列网格布局中有四个物体放入其中。 
尝试更新下面的实时代码以复现上面的示例： 
{{EmbedGHLiveSample(“css-examples/learn/tasks/grid/grid1.html”, ‘100%’, 700)}} 
备注： 评估或进一步的工作目的，可以下载此任务的源文件在你自己的编辑器或使用线编辑器。 
网格布局 二 
在此例中，我们已经定义好了一个 grid, 请通过修改下面两个子元素的 CSS 规则，导致它们跨过彼此的网格轨道; 第二个 item 应该在第一个 item 之上 (如下图所示). 
盒子中的两个元素，其中一个元素覆盖在另一个元素上。 

{{LearnSidebar}} 
此刻，我们已经看过 CSS 的基础知识，如何设置文本的样式，以及如何设置和操作内容所在的框。 
现在是时候看看如何把你的盒子放在与视口相关的正确位置上。 
我们已经涵盖了必要的先决条件，所以我们现在可以深入到 CSS 布局，查看不同的显示设置，涉及浮动和定位的传统布局方法，以及像 flexbox 这样的现代布局工具。 
前提条件： 
在开始前，你应该已经具备： 
对 HTML 的基础了解，在Introduction to HTML部分讨论过的。 
一定的 CSS 基础，在Introduction to CSS部分讨论过的。 
了解如何样式化盒子模型. 
备注： 如果你在一台电脑/平板电脑/其他设备上工作，而你没有能力创建自己的文件，你可以尝试（大部分）在线编码程序中的代码示例，如 JSBin 或 Glitch 。 
指南 
这些文章将提供在 CSS 中可用的基本布局工具和技术的指导。 
介绍 CSS 布局 
: 本文将重述一些我们在之前的模块中已经涉及的 CSS 布局功能——例如不同的 {{cssxref(“display”)}} 值——并介绍我们将在本单元中涵盖的一些概念。 
正常布局流 
: 这篇文章介绍正常的流布局，或者说，在你没有改变默认布局规则情况下的页面元素布局方式。 
弹性盒 
: 弹性盒 是一种新技术，但在如今各个浏览器都广泛支持的情况下，它已经开始准备广泛应用了。 
弹性盒子提供了工具，允许快速创建曾经被证明用 CSS 很难实现的一些复杂，灵活的布局和功能。 
本文将解释所有的基本原理。 
网格 
: 网格是一个成熟的设计工具，许多现代网站布局是基于规则网格。 
在本文中，我们将看看基于网格的设计，以及如何使用 CSS 来创建网格——两者都通过现在的工具，和刚刚开始在浏览器中可用的新技术。 
浮动 
: 最初对于文本块中的浮动图像，{{cssxref(“float”)}}属性已经成为在网页上创建多个列布局的最常用工具之一。 
本文解释所有。 
定位 
: 定位允许你从常规文档布局流程中取出元素，并使它们具有不同的行为，例如坐在另一个之上，或始终保持在浏览器视口内的同一位置。 
本文解释不同的{{cssxref(“position”)}} 值，以及如何使用它们。 
多列布局 
: 多列布局声明提供了一种多列组织内容的方式，正如你在一些报纸中看到的那样。 
这篇文章介绍怎么使用这一特性。 
响应式设计 
: 随着越来越多的屏幕尺寸出现在支持 Web 的设备上，响应式 Web 设计（RWD）的概念出现了：一组允许网页改变其布局和外观以适应不同的屏幕宽度、分辨率等的实践。 
这一想法改变了我们为多设备 Web 设计的方式，在本文中，我们将帮助你了解掌握它所需的主要技术。 
媒体查询入门指南 
: 媒体查询 提供了一种仅当浏览器和设备环境与你指定的规则匹配时才应用 css 的方法，例如“viewport（视区）宽度大于 480 像素”。 
媒体查询是响应式 Web 设计的一个关键部分，因为它们允许你根据视区的大小创建不同的布局，但也可以用于检测有关网站运行环境的其他内容，例如用户是否使用触摸屏而不是鼠标。 
在本节中，你将首先了解媒体查询中使用的语法，然后在一个演示如何使简单设计具有响应性的示例中继续使用它们。 
传统布局方法 
: 网格系统是 css 布局中使用的一个非常常见的特性，在 css 网格布局之前，它们往往使用浮动或其他布局特性来实现。 
你可以将布局想象为一组列（例如 4、6 或 12），然后将网页内容放入这些列中。 
在本文中，我们将探讨这些旧方法是如何工作的，以便你了解在处理旧项目时如何使用它们。 
支持旧浏览器 
: 在本模块中，我们建议使用弹性盒和网格作为主要布局方法。 
但是，你的网站会遇到使用旧浏览器的访问者，或者不支持你使用的新布局方法的浏览器。 
在网络开发上一直有这种状况——那就是随着新特性的开发，不同的浏览器将优先支持不同的特性。 
本文解释了如何使用现代 web 技术而不将使用旧版本浏览器的用户拒之门外。 
测试：基本布局掌握 
: 通过布置网页来测试你对不同布局方法的知识的掌握。 
参见 
练习定位案例 
: 在最后一篇文章中介绍了定位的基础知识，现在将讨论构建几个真实世界的例子，以说明你可以通过定位做什么样的事情。 


{{LearnSidebar}} 
{{PreviousMenuNext(“Learn/CSS/CSS_layout/Multiple-Column_Layout”, “Learn/CSS/CSS_layout/Supporting_Older_Browsers”, “Learn/CSS/CSS_layout”)}} 

{{learnsidebar}}{{PreviousMenuNext(“Learn/CSS/CSS_layout/Responsive_Design”, “Learn/CSS/CSS_layout/Legacy_Layout_Methods”, “Learn/CSS/CSS_layout”)}} 
CSS 媒体查询为你提供了一种应用 CSS 的方法，仅在浏览器和设备的环境与你指定的规则相匹配的时候 CSS 才会真的被应用，例如“视口宽于 480 像素”的时候。 
媒体查询是响应式 Web 设计的关键部分，因为它允许你按照视口的尺寸创建不同的布局，不过它也可以用来探测和你的站点运行的环境相关联的其他条件，比如用户是在使用触摸屏还是鼠标。 
在本节课，你将会先学习到媒体查询的语法，然后继续在一个被安排好的示例中使用它，这个示例还会告诉你一个简单的设计是可以怎么被弄成响应式的。 
学习前提： 
HTML 基础知识（学习Introduction to HTML），对 CSS 工作方式的大致了解（学习CSS first steps和CSS building blocks） 
目标： 
理解如何使用媒体查询和用它建立响应式设计的最常见方法。 



{{PreviousMenuNext(“Learn/CSS/CSS_layout/Floats”, “Learn/CSS/CSS_layout/Practical_positioning_examples”, “Learn/CSS/CSS_layout”)}} 
定位允许你从正常的文档流布局中取出元素，并使它们具有不同的行为，例如放在另一个元素的上面，或者始终保持在浏览器视窗内的同一位置。 
本文解释的是定位 ({{cssxref(“position”)}}) 的各种不同值，以及如何使用它们。 
前提： 
HTML 基础 (学习 HTML 导学) 和 CSS 怎样工作的 (学习 CSS 导学) 
目标： 
了解 CSS 定位的工作原理 
定位是一个相当复杂的话题，所以我们深入了解代码之前，让我们审视一下布局理论，并让我们了解它的工作原理。 
默认情况下，块级元素的内容宽度是其父元素的宽度的 100％，并且与其内容一样高。 
内联元素高宽与他们的内容高宽一样。 
默认情况下，块级元素在视口中垂直布局——每个都将显示在上一个元素下面的新行上，并且它们的外边距将分隔开它们。 
内联元素表现不一样——它们不会出现在新行上；相反，它们互相之间以及任何相邻（或被包裹）的文本内容位于同一行上，只要在父块级元素的宽度内有空间可以这样做。 
让我们来看一个简单的例子来解析这一切： 
<p> inline elements <span>like this one</span> and <span>this one</span> sit on the same line as one another, and adjacent text nodes, if there is space on the same line. Overflowing inline elements will 
or just go on to a new line if not, much like this image will do: 
{{ EmbedLiveSample(‘文档流’, ‘100%’, 500) }} 
定位的整个想法是允许我们覆盖上面描述的基本文档流行为，以产生有趣的效果。 
定位是你的工具。 
要使某个元素上的特定类型的定位，我们使用{{cssxref(“position”)}}属性。 静态定位 
静态定位是每个元素获取的默认值——它只是意味着“将元素放入它在文档布局流中的正常位置 ——这里没有什么特别的。 
为了演示这一点，并为以后的部分设置示例，首先在 HTML 中添加一个positioned 的 class 到第二个{{htmlelement(“p”)}}： 
<p class="positioned">...</p> 
现在，将以下规则添加到 CSS 的底部： 
.positioned { 
position: static; 
background: yellow; 
} 
如果现在保存和刷新，除了第 2 段的更新的背景颜色，根本没有差别。 
这很好——正如我们之前所说，静态定位是默认行为！ 
备注： 你可以在 1_static-positioning.html 查看这个例子 (see source code)。 
相对定位 
相对定位是我们将要看的第一个位置类型。 
它与静态定位非常相似，占据在正常的文档流中，除了你仍然可以修改它的最终位置，包括让它与页面上的其他元素重叠。 
让我们继续并更新代码中的 position 属性： 
position: relative; 
如果你在此阶段保存并刷新，则结果根本不会发生变化。 
那么如何修改元素的位置呢？ 
你需要使用{{cssxref(“top”)}}，{{cssxref(“bottom”)}}，{{cssxref(“left”)}}和{{cssxref(“right”)}}属性，我们将在下一节中解释。 
介绍 top、bottom、left 和 right 
{{cssxref(“top”)}}, {{cssxref(“bottom”)}}, {{cssxref(“left”)}}, 和 {{cssxref(“right”)}} 来精确指定要将定位元素移动到的位置。 
要尝试这样做，请在 CSS 中的 .positioned 规则中添加以下声明： 
top: 30px; 
left: 30px; 
备注： 这些属性的值可以采用逻辑上期望的任何单位 ——px，mm，rems，％等。 
如果你现在保存和刷新，你会得到一个这样的结果： 
```html hidden 
Relative positioning 
I am a basic block level element. 
My adjacent block level elements sit on new lines below me. 
By default we span 100% of the width of our parent element, and our are as tall as our child content. 
Our total width and height is our content + padding + border width/height. 
We are separated by our margins. 
Because of margin collapsing, we are separated by the width of one of our margins, not both. 
inline elements like this one and this one sit on the same line as one another, and adjacent text nodes, if there is space on the same line. 
Overflowing inline elements wrap onto a new line if possible — like this one containing text, or just go on to a new line if not, much like this image will do: 
```css hidden 
body { 
width: 500px; 
margin: 0 auto; 
} 
p { 
background: aqua; 
border: 3px solid blue; 
padding: 10px; 
margin: 10px; 
} 
span { 
background: red; 
border: 1px solid black; 
} 
.positioned { 
position: relative; 
background: yellow; 
top: 30px; 
left: 30px; 
} 
{{ EmbedLiveSample(‘介绍 top、bottom、left 和 right’, ‘100%’, 500) }} 
酷，是吗？ 
好吧，所以这个结果这可能不是你期待的——为什么它移动到底部和右边，但我们指定顶部和左边？ 
听起来不合逻辑，但这只是相对定位工作的方式——你需要考虑一个看不见的力，推动定位的盒子的一侧，移动它的相反方向。 
所以例如，如果你指定 top: 30px;一个力推动框的顶部，使它向下移动 30px。 
备注： 你可以在 2_relative-positioning.html 查看这个例子 (see source code)。 
绝对定位 
绝对定位带来了非常不同的结果。 
让我们尝试改变代码中的位置声明如下： 
position: absolute; 
如果你现在保存和刷新，你应该看到这样： 
```html hidden 
Absolute positioning 
I am a basic block level element. 
My adjacent block level elements sit on new lines below me. 
By default we span 100% of the width of our parent element, and we are as tall as our child content. 
Our total width and height is our content + padding + border width/height. 
We are separated by our margins. 
Because of margin collapsing, we are separated by the width of one of our margins, not both. 
inline elements like this one and this one sit on the same line as one another, and adjacent text nodes, if there is space on the same line. 
Overflowing inline elements wrap onto a new line if possible — like this one containing text, or just go on to a new line if not, much like this image will do: 
```css hidden 
body { 
width: 500px; 
margin: 0 auto; 
} 
p { 
background: aqua; 
border: 3px solid blue; 
padding: 10px; 
margin: 10px; 
} 
span { 
background: red; 
border: 1px solid black; 
} 
.positioned { 
position: absolute; 
background: yellow; 
top: 30px; 
left: 30px; 
} 
{{ EmbedLiveSample(‘绝对定位’, ‘100%’, 450) }} 
首先，请注意，定位的元素应该在文档流中的间隙不再存在——第一和第三元素已经靠在一起，就像第二个元素不再存在！ 
好吧，在某种程度上，这是真的。 
绝对定位的元素不再存在于正常文档布局流中。 
相反，它坐在它自己的层独立于一切。 
这是非常有用的：这意味着我们可以创建不干扰页面上其他元素的位置的隔离的 UI 功能。 
例如，弹出信息框和控制菜单；翻转面板；可以在页面上的任何地方拖放的 UI 功能…… 
第二，注意元素的位置已经改变——这是因为{{cssxref(“top”)}}，{{cssxref(“bottom”)}}，{{cssxref(“left”)}}和{{cssxref(“right”)}}以不同的方式在绝对定位。 
它们指定元素应距离每个包含元素的边的距离，而不是指定元素应该移入的方向。 
所以在这种情况下，我们说的绝对定位元素应该位于从“包含元素”的顶部 30px，从左边 30px。 
备注： 如果需要，你可以使用 {{cssxref(“top”)}}，{{cssxref(“bottom”)}}、{{cssxref(“left”)}} 和 {{cssxref(“right”)}} 调整元素大小。 
尝试设置 top: 0; bottom: 0; left: 0; right: 0; 和 margin: 0; 对你定位的元素，看看会发生什么！ 
之后再回来 
备注： 是的，margins 仍会影响定位的元素。 
然而 margin collapsing 不会。 
备注： 你可以在3_absolute-positioning.html 查看这个例子 (see source code)。 
定位上下文 
哪个元素是绝对定位元素的“包含元素“？ 
这取决于绝对定位元素的父元素的 position 属性。( 参见 Identifying the containing block). 
如果所有的父元素都没有显式地定义 position 属性，那么所有的父元素默认情况下 position 属性都是 static。 
结果，绝对定位元素会被包含在初始块容器中。 
这个初始块容器有着和浏览器视口一样的尺寸，并且<html>元素也被包含在这个容器里面。 
简单来说，绝对定位元素会被放在<html>元素的外面，并且根据浏览器视口来定位。 
绝对定位元素在 HTML 源代码中，是被放在<body>中的，但是在最终的布局里面，它离页面 (而不是<body>) 的左边界、上边界有 30px 的距离。 
我们可以改变定位上下文 —— 绝对定位的元素的相对位置元素。 
通过设置其中一个父元素的定位属性 —— 也就是包含绝对定位元素的那个元素（如果要设置绝对定位元素的相对元素，那么这个元素一定要包含绝对定位元素）。 
为了演示这一点，将以下声明添加到你的 body 规则中： 
position: relative; 
应该得到以下结果： 
```html hidden 
Positioning context 
I am a basic block level element. 
My adjacent block level elements sit on new lines below me. 
Now I’m absolutely positioned relative to the <body> element, not the <html> element! 
We are separated by our margins. 
Because of margin collapsing, we are separated by the width of one of our margins, not both. 
inline elements like this one and this one sit on the same line as one another, and adjacent text nodes, if there is space on the same line. 
Overflowing inline elements wrap onto a new line if possible — like this one containing text, or just go on to a new line if not, much like this image will do: 
```css hidden 
body { 
width: 500px; 
margin: 0 auto; 
position: relative; 
} 
p { 
background: aqua; 
border: 3px solid blue; 
padding: 10px; 
margin: 10px; 
} 
span { 
background: red; 
border: 1px solid black; 
} 
.positioned { 
position: absolute; 
background: yellow; 
top: 30px; 
left: 30px; 
} 
{{ EmbedLiveSample(‘定位上下文’, ‘100%’, 420) }} 
定位的元素现在相对于{{htmlelement(“body”)}}元素。 
备注： 你可以在这里看到这个例子 4_positioning-context.html (see source code). 
介绍 z-index 
所有这些绝对定位很有趣，但还有另一件事我们还没有考虑到 ——当元素开始重叠，什么决定哪些元素出现在其他元素的顶部？ 
在我们已经看到的示例中，我们在定位上下文中只有一个定位的元素，它出现在顶部，因为定位的元素胜过未定位的元素。 
当我们有不止一个的时候呢？ 
尝试添加以下到你的 CSS，使第一段也是绝对定位： 
p:nth-of-type(1) { 
position: absolute; 
background: lime; 
top: 10px; 
right: 30px; 
} 
此时，你将看到第一段的颜色为绿色，移出文档流程，并位于原始位置上方一点。 
它也堆叠在原始的 .positioned 段落下，其中两个重叠。 
这是因为 .positioned 段落是源顺序 (HTML 标记) 中的第二个段落，并且源顺序中后定位的元素将赢得先定位的元素。 
是的，你可以使用{{cssxref(“z-index”)}}属性。 
“z-index”是对 z 轴的参考。 
你可以从源代码中的上一点回想一下，我们使用水平（x 轴）和垂直（y 轴）坐标来讨论网页，以确定像背景图像和阴影偏移之类的东西的位置。 
（0,0）位于页面（或元素）的左上角，x 和 y 轴跨页面向右和向下（适合从左到右的语言，无论如何）。 
网页也有一个 z 轴：一条从屏幕表面到你的脸（或者在屏幕前面你喜欢的任何其他东西）的虚线。{{ cssxref(“z-index”)}} 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。 
默认情况下，定位的元素都具有 z-index 为 auto，实际上为 0。 
要更改堆叠顺序，请尝试将以下声明添加到 p:nth-of-type(1) 规则中： 
z-index: 1; 
你现在应该可以看到完成的例子： 
```html hidden 
z-index 
I am a basic block level element. 
My adjacent block level elements sit on new lines below me. 
Now I’m absolutely positioned relative to the <body> element, not the <html> element! 
We are separated by our margins. 
Because of margin collapsing, we are separated by the width of one of our margins, not both. 
inline elements like this one and this one sit on the same line as one another, and adjacent text nodes, if there is space on the same line. 
Overflowing inline elements wrap onto a new line if possible — like this one containing text, or just go on to a new line if not, much like this image will do: 
```css hidden 
body { 
width: 500px; 
margin: 0 auto; 
position: relative; 
} 
p { 
background: aqua; 
border: 3px solid blue; 
padding: 10px; 
margin: 10px; 
} 
span { 
background: red; 
border: 1px solid black; 
} 
.positioned { 
position: absolute; 
background: yellow; 
top: 30px; 
left: 30px; 
} 
p:nth-of-type(1) { 
position: absolute; 
background: lime; 
top: 10px; 
right: 30px; 
z-index: 1; 
} 
{{ EmbedLiveSample(‘介绍 z-index’, ‘100%’, 400) }} 
请注意，z-index 只接受无单位索引值；你不能指定你想要一个元素是 Z 轴上 23 像素—— 它不这样工作。 
较高的值将高于较低的值，这取决于你使用的值。 
使用 2 和 3 将产生与 300 和 40000 相同的效果。 
备注： 你可以在这里看到这个例子 5_z-index.html (see source code). 
固定定位 
还有一种类型的定位覆盖——fixed。 
这与绝对定位的工作方式完全相同，只有一个主要区别：绝对定位将元素固定在相对于其位置最近的祖先。（ 
如果没有，则为初始包含它的块）而固定定位固定元素则是相对于浏览器视口本身。 
这意味着你可以创建固定的有用的 UI 项目，如持久导航菜单。 
让我们举一个简单的例子来说明我们的意思。 
首先，从 CSS 中删除现有的 p:nth-of-type(1) 和.positioned 规则。 
现在，更新 body 规则以删除position: relative; 声明并添加固定高度，如此： 
body { 
width: 500px; 
height: 1400px; 
margin: 0 auto; 
} 
现在我们要给{{htmlelement(“h1”)}}元素 position: fixed;，并让它坐在视口的顶部中心。 
将以下规则添加到 CSS： 
h1 { 
position: fixed; 
top: 0; 
width: 500px; 
margin: 0 auto; 
background: white; 
padding: 10px; 
} 
top: 0;是要使它贴在屏幕的顶部；我们然后给出标题与内容列相同的宽度，并使用可靠的老技巧 margin: 0 auto; 使它居中。 
然后我们给它一个白色背景和一些内边距，所以内容将不会在它下面可见。 
如果你现在保存并刷新，你会看到一个有趣的小效果，标题保持固定，内容显示向上滚动并消失在其下。 
但是我们可以改进这一点——目前标题下面挡住一些内容的开头。 
这是因为定位的标题不再出现在文档流中，所以其他内容向上移动到顶部。 
我们要把它向下移动一点；我们可以通过在第一段设置一些顶部边距来做到这一点。 
添加： 
p:nth-of-type(1) { 
margin-top: 60px; 
} 
你现在应该看到完成的例子： 
```html hidden 
Fixed positioning 
I am a basic block level element. 
My adjacent block level elements sit on new lines below me. 
I’m not positioned any more… 
We are separated by our margins. 
Because of margin collapsing, we are separated by the width of one of our margins, not both. 
inline elements like this one and this one sit on the same line as one another, and adjacent text nodes, if there is space on the same line. 
Overflowing inline elements wrap onto a new line if possible — like this one containing text, or just go on to a new line if not, much like this image will do: 
```css hidden 
body { 
width: 500px; 
height: 1400px; 
margin: 0 auto; 
} 
p { 
background: aqua; 
border: 3px solid blue; 
padding: 10px; 
margin: 10px; 
} 
span { 
background: red; 
border: 1px solid black; 
} 
h1 { 
position: fixed; 
top: 0px; 
width: 500px; 
background: white; 
padding: 10px; 
} 
p:nth-of-type(1) { 
margin-top: 60px; 
} 
{{ EmbedLiveSample(‘固定定位’, ‘100%’, 400) }} 
备注： 你可以在这里看到这个例子6_fixed-positioning.html (see source code). 
position: sticky 
还有一个可用的位置值称为 position: sticky，比起其他位置值要新一些。 
它基本上是相对位置和固定位置的混合体，它允许被定位的元素表现得像相对定位一样，直到它滚动到某个阈值点（例如，从视口顶部起 10 像素）为止，此后它就变得固定了。 
例如，它可用于使导航栏随页面滚动直到特定点，然后粘贴在页面顶部。 Sticky positioning example 
```html hidden 
Sticky positioning 
Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. 
Duis felis orci, pulvinar id metus ut, rutrum luctus orci. 
Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. 
Sed auctor cursus massa at porta. 
Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. 
Curabitur vehicula tellus neque, ac ornare ex malesuada et. 
In vitae convallis lacus. 
Aliquam erat volutpat. 
Suspendisse ac imperdiet turpis. 
Aenean finibus sollicitudin eros pharetra congue. 
Duis ornare egestas augue ut luctus. 
Proin blandit quam nec lacus varius commodo et a urna. 
Ut id ornare felis, eget fermentum sapien. 
Sticky 
Nam vulputate diam nec tempor bibendum. 
Donec luctus augue eget malesuada ultrices. 
Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed est. 
Nam id risus quis ante semper consectetur eget aliquam lorem. 
Vivamus tristique elit dolor, sed pretium metus suscipit vel. 
Mauris ultricies lectus sed lobortis finibus. 
Vivamus eu urna eget velit cursus viverra quis vestibulum sem. 
Aliquam tincidunt eget purus in interdum. 
Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. 
Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. 
Duis felis orci, pulvinar id metus ut, rutrum luctus orci. 
Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. 
Sed auctor cursus massa at porta. 
Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. 
Curabitur vehicula tellus neque, ac ornare ex malesuada et. 
In vitae convallis lacus. 
Aliquam erat volutpat. 
Suspendisse ac imperdiet turpis. 
Aenean finibus sollicitudin eros pharetra congue. 
Duis ornare egestas augue ut luctus. 
Proin blandit quam nec lacus varius commodo et a urna. 
Ut id ornare felis, eget fermentum sapien. 
```css hidden 
body { 
width: 500px; 
margin: 0 auto; 
} 
.positioned { 
background: rgba(255, 84, 104, 0.3); 
border: 2px solid rgb(255, 84, 104); 
padding: 10px; 
margin: 10px; 
border-radius: 5px; 
} 
.positioned { 
position: sticky; 
top: 30px; 
left: 30px; 
} 
{{ EmbedLiveSample(‘Sticky positioning example’, ‘100%’, 200) }} 
滚动索引 
position: sticky 的另一种有趣且常用的用法，是创建一个滚动索引页面。 
在此页面上，不同的标题会停留在页面顶部。 
<h1>Sticky positioning</h1> 
<dl> 
<dt>A</dt> 
<dd>Apple</dd> 
<dd>Ant</dd> 
<dd>Altimeter</dd> 
<dd>Airplane</dd> 
<dt>B</dt> 
<dd>Bird</dd> 
<dd>Buzzard</dd> 
<dd>Bee</dd> 
<dd>Banana</dd> 
<dd>Beanstalk</dd> 
<dt>C</dt> 
<dd>Calculator</dd> 
<dd>Cane</dd> 
<dd>Camera</dd> 
<dd>Camel</dd> 
<dt>D</dt> 
<dd>Duck</dd> 
<dd>Dime</dd> 
<dd>Dipstick</dd> 
<dd>Drone</dd> 
<dt>E</dt> 
<dd>Egg</dd> 
<dd>Elephant</dd> 
<dd>Egret</dd> 
</dl> 
CSS 可能如下所示。 
在正常布局流中，{{htmlelement(“dt”)}}元素将随内容滚动。 
当我们在{{htmlelement(“dt”)}}元素上添加position: sticky，并将{{cssxref(“top”)}}的值设置为 0，当标题滚动到视口的顶部时，支持此属性的浏览器会将标题粘贴到那个位置。 
随后，每个后续标题将替换前一个标题，直到它向上滚动到该位置。 
dt { 
background-color: black; 
color: white; 
padding: 10px; 
position: sticky; 
top: 0; 
left: 0; 
margin: 1em 0; 
} 
css hidden body { width: 500px; height: 1400px; margin: 0 auto; } 
```html hidden 
Sticky positioning 
A 
Apple 
Ant 
Altimeter 
Airplane 
B 
Bird 
Buzzard 
Bee 
Banana 
Beanstalk 
C 
Calculator 
Cane 
Camera 
Camel 
D 
Duck 
Dime 
Dipstick 
Drone 
E 
Egg 
Elephant 
Egret 
``` 
{{ EmbedLiveSample(‘滚动索引’, ‘100%’, 200) }} 
备注： 你可以在 7_sticky-positioning.html 查看这个例子 (see source code)。 
试试你的技术！ 
这篇文章到此为止了，但你们能记住最重要的信息吗？ 
在继续之前，你可以找到一些进一步的测试来验证是否完全掌握了这个知识：试试你的技术。 
总结 
我相信你用基本定位愉快地玩耍；它是创建复杂的 CSS 布局和 UI 功能背后的基本工具之一。 
考虑到这一点，在下一篇文章中，我们将更有趣的定位——我们将进一步，开始建立一些真实世界有用的东西。 
{{PreviousMenuNext(“Learn/CSS/CSS_layout/Floats”, “Learn/CSS/CSS_layout/Practical_positioning_examples”, “Learn/CSS/CSS_layout”)}} 

{{LearnSidebar}} 
此任务的目的是让你使用在我们的 position 课程中介绍的 CSS {{CSSxRef(“position”)}}属性以及对应值，你将通过两个小任务来复习刚才课程材料中介绍的不同元素。 
备注： 你可以在下面的交互式编辑器中尝试解决方案，下载代码并使用在线工具（如 CodePen、jsFiddle 或 Glitch）处理任务可能会有帮助。 
如果你遇到困难，请向我们寻求帮助 - 请参阅本页底部的 Assessment or further help 部分 
定位练习一 
在这项任务中，你需要将目标类别为 5px 灰色边框的元素定位到外部容器的右上角。 
The green box is at the top right of a container with a grey border. 
尝试更改下面的代码示例，重新完成的上述任务： 
{{EmbedGHLiveSample(“css-examples/learn/tasks/position/position1.html”, ‘100%’, 1000)}} 
作为一个额外的挑战，你能改变目标元素显示在文本下面吗？ 
备注： 为了评估和进一步编辑，下载源代码在本地编辑器或在线编辑器中编辑 
定位练习二 
在下面的示例中，滚动条滚动时侧边栏将随内容一起滚动。 
更改它使滚动条滚动时侧边栏保持原位并且只滚动内容。 
The content is scrolled but the sidebar has stayed in place. 
尝试更改下面的代码示例，重新完成的上述任务： 
{{EmbedGHLiveSample(“css-examples/learn/tasks/position/position2.html”, ‘100%’, 1000)}} 
备注： 为了评估和进一步编辑，下载源代码在本地编辑器或在线编辑器中编辑 
Assessment or further help 
You can practice these examples in the Interactive Editors mentioned above. 
If you would like your work assessed, or are stuck and want to ask for help: 
Put your work into an online shareable editor such as CodePen, jsFiddle, or Glitch. 
You can write the code yourself, or use the starting point files linked to in the above sections. 
Write a post asking for assessment and/or help at the MDN Discourse forum Learning category. 
Your post should include: 
A descriptive title such as “Assessment wanted for Position skill test 1”. 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/CSS/CSS_layout/Positioning”, “Learn/CSS/CSS_layout/Flexbox”, “Learn/CSS/CSS_layout”)}} 
掌握了上一篇文章中的定位的基础知识，我们将着眼于实现一些现实中的例子，来演示你能用定位来做什么。 
前提： 
HTML 基础 (学习Introduction to HTML),和 CSS 怎么工作的 (学习Introduction to CSS.) 
目标： 
了解定位的实例 
列表消息盒子 
我们研究的第一个例子是一个经典的选项卡消息框，你想用一块小区域包括大量信息时，一个非常常用的特征。 
这包括含有大信息量的应用，比如策略战争游戏，比如从移动版的网页，屏幕狭小、空间有限；比如你可能想要放置许多信息的紧凑消息框，不用就会充满整个 UI。 
我们简单的例子完成后就会像下面这样： 
备注： 你能看完整的示例，可运行在 info-box.html (source code)。 
检出它以理解你在本文章里要建立什么。 
你可能会想：”为什么不仅仅做独立的选项卡为一个独立的网页，然后通过点击不同的标签来在不同的页面跳转来达到这个效果？“ 
这样代码可能会简单一些，是的。 但是这样每个独立的”页面“视图将会实际上是一个新加载的网页，跨视图更难保存信息，并把这个特征融入一个更大的 UI 设计。 
另外，所谓的”单页应用“正在变得非常流行——尤其是移动网页 UI——因为把一切的服务放在一个单独的文件上可以减少 HTTP 请求的数量来浏览所有内容，从而提高性能。 
备注： 一些网络开发者甚至更超前，每次只加载一页的信息，并且使用 JavaScript 诸如 XMLHttpRequest特征动态改变信息显示。 
但是，在你此时的学习中，我们希望尽可能保持简单。 
接下来会有一些 JavaScript，但是只有一点。 
在开始之前，我们需要你拷贝文件到本地，当作起始的 HTML 文件—— info-box-start.html. 
保存到你的计算机合适的位置，然后在你的编辑器里打开。 
让我们看看包含在 body 里的 HTML 代码： 
<section class="info-box"> 
<ul> 
<li><a href="#" class="active">Tab 1</a></li> 
<li><a href="#">Tab 2</a></li> 
<li><a href="#">Tab 3</a></li> 
</ul> 
<div class="panels"> 
<article class="active-panel"> 
<h2>The first tab</h2> 
<p> 
Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
Pellentesque 
turpis nibh, porttitor nec venenatis eu, pulvinar in augue. 
Vestibulum 
et orci scelerisque, vulputate tellus quis, lobortis dui. 
Vivamus varius 
libero at ipsum mattis efficitur ut nec nisl. 
Nullam eget tincidunt 
metus. 
Donec ultrices, urna maximus consequat aliquet, dui neque 
eleifend lorem, a auctor libero turpis at sem. 
Aliquam ut porttitor 
urna. 
Nulla facilisi. 
</p> 
</article> 
<article> 
<h2>The second tab</h2> 
<p> 
This tab hasn't got any Lorem Ipsum in it. 
But the content isn't very 
exciting all the same. 
</p> 
</article> 
<article> 
<h2>The third tab</h2> 
<p> 
Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
Pellentesque 
turpis nibh, porttitor nec venenatis eu, pulvinar in augue. 
And now an 
ordered list: how exciting! 


{{LearnSidebar}} 
{{PreviousMenuNext(“Learn/CSS/CSS_layout/Legacy_Layout_methods”, “Learn/CSS/CSS_layout/Fundamental_Layout_Comprehension”, “Learn/CSS/CSS_layout”)}} 
本文中，我们推荐使用弹性盒和网格作为你的设计的主要布局方式。 
但是，你的网站的访客会有人使用旧浏览器，或者是不支持你已经使用的方式。 
这总是 Web 上存在的情况，因为新的特性被开发出来，不同的浏览器会优先支持不同的特性。 
本文解释了如何使用现代的 Web 技术，而无需让采用旧技术的用户被拒之门外。 
学习前提： 
HTML 基础（学习HTML 介绍），了解 CSS 工作的原理（学习CSS 介绍和样式化盒子） 
目标： 
理解怎么让你的布局为旧有的、不支持你想要使用的特性的浏览器提供支持。 




{{LearnSidebar}} 
CSS（层叠样式表）用于设置和布置网页——例如，更改内容的字体、颜色、大小和间距，将其拆分为多个列，或添加动画和其他装饰功能。 
这个模块为你掌握 CSS 的过程提供了一个温和的开端，包括它如何工作的基础知识，语法是什么样的，以及如何开始使用它来为 HTML 添加样式。 前提 
在开始本单元之前，你应该： 
备注： 如果你在一个无权创建自己文件的电脑/平板/其他设备上工作，你可以在在线编程工具上尝试（大部分）代码示例，如 JSBin 或者 Glitch 等。 指南 
CSS 入门 
CSS 的结构 
以下测验将检验你对上述指南中涵盖的 CSS 基础知识的理解。 

{{LearnSidebar}}{{PreviousMenu(“Learn/CSS/First_steps/How_CSS_works”, “Learn/CSS/First_steps”)}} 
通过在前几节课程中学到的知识，你应该学会了用 CSS 组织一个简单的文本文件，并且在其中添加自己的 CSS 样式。 
本节中你将实现这一功能。 
前提： 
基本熟悉使用计算机，基本工作环境的设置，基本的文件处理知识，基本的 HTML 知识（在 HTML 概述中学习）和 CSS 基础（查看本模块其他内容） 
目标： 
尝试使用一些 CSS 的新玩法并检验新的知识 
你可以使用下面的实时编辑器，或者下载这个download the starting point在自己的编辑器中进行编辑。 
这是一个独立的 HTML 文件，在 head 中包含了初始 CSS 样式。 
你可以将这些 CSS 样式从 HTML 文件中移出，保存为另一个独立文件。 
你可以选择 CodePen、jsFiddle 或 Glitch 中的任意一个完成这些工作。 
备注： 如果遇到困难，你可以向我求助——参见本页下面的测评或请求帮助部分。 
让我们来学一些 CSS 样式 
接下来的实例是一个个人主页，我们用 CSS 设定它的样式。 
以下是我用到的一些 CSS 属性，通过这些链接，你可以打开相应的 MDN 页面了解更多。 
{{cssxref(“font-family”)}} 
{{cssxref(“color”)}} 
{{cssxref(“border-bottom”)}} 
{{cssxref(“font-weight”)}} 
{{cssxref(“font-size”)}} 
{{cssxref(“text-decoration”)}} 
我使用了许多不同的选择器（样式元素），如 h1 和 h2，也为工作职务建立了一个类别。 
尝试使用 CSS 更改这一页面的显示，试着修改已有属性的取值，删除一些规则，或添加新的样式。 
然后通过CSS 参考找到本文未提及的一些属性，尽管大胆尝试！ 
举例来说，你可以： 
使用 CSS 的颜色关键词 hotpink，将一级标题设定为粉红色。 
使用 CSS 颜色关键词 purple，为标题添加 10 像素宽的点线边距。 
将二级标题设为斜体。 
用#eeeeee 为联系人列表中的超链接添加背景颜色和一个 5 像素宽的紫色加粗边框。 
使用一些内边距属性，拉开正文与外边距的距离。 
当鼠标在某些 HTML 元素上悬停时增加动画 (推荐改变颜色和字体)。 
设置链接在鼠标悬停时变为绿色。 
最终，你得到的页面将如下图所示： 
Screenshot of how the example should look after completing the assessment. 
记住这里没有错误的答案——在这个阶段你可以在学习中娱乐一下。 
{{EmbedGHLiveSample(“css-examples/learn/getting-started/biog.html”, ‘100%’, 1600)}} 
测评或请求帮助 
将你的文件提交到可网络共享的编辑器，如 CodePen、jsFiddle 或 Glitch。 
在 MDN 论坛（MDN Discourse forum）发帖请求测评或帮助。 
发帖时添加“学习”的标签，这样我们能够更容易找到它。 
你的帖子应包括以下内容： 
一个描述性标题，例如“CSS 的初步尝试需要测试”。 
详细描述你希望我们做些什么——比如，你已经尝试过了，但是卡住了，需要帮助。 
你希望测试的例子的在网络编辑器上的链接。 
这是很好的做法，因为如果不让帮助你的看到你的程序，他们就很难帮助你解决程序的问题。 
你的网页的测评页面链接，这样我们就可以找到你所求助的问题。 
接下来是什么？ 


{{LearnSidebar}} 
在本篇文章中，你会发现一些有关 CSS 的常见问题，这些问题及其解答可能会有助于你成为一名网站开发人员。 
为什么有效的 CSS 没有正确的渲染？ 
浏览器使用 DOCTYPE 声明来选择是否使用更符合 Web 标准或兼容旧浏览器缺陷的模式。 
在你的 HTML 的开始使用一个正确的和现代的 DOCTYPE 声明将改善浏览器标准执行。 
现代浏览器主要有两种渲染模式： 
怪异模式：又称向后兼容模式，允许按照旧版浏览器使用的非标准渲染规则，按作者的意图呈现旧版网页。 
如果文档中存在不完整、不正确或缺失的 DOCTYPE 声明，或已知的 2001 年以前常用的 DOCTYPE 声明，则会以怪异模式渲染。 
标准模式：浏览器试图严格遵守 W3C 标准。 
新的 HTML 页面预计是为符合标准的浏览器设计的，因此，带有现代 DOCTYPE 声明的页面将使用标准模式渲染。 
有三分之一的基于 Gecko 的浏览器处于接近标准模式，只是有一些怪异行为。 
这是最常用的触发标准模式的 DOCTYPE 声明： 
<! 
doctype html> 
你应该尽可能使用上述 doctype 声明。 
还有其他有效的传统 doctype 说明，它们会触发标准模式或接近标准模式： 
<! 
DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 
<! 
DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"> 
<! 
DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<! 
DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"> 
为什么有效的 CSS 完全没有被渲染？ 
可能的原因如下： 
引入的 CSS 文件路径写错了。 
为了使浏览器渲染样式文件，CSS 样式表必须用 text/css 的 MIME 类型。 
如果 Web 服务器没有使用这种类型处理文件，则 CSS 也不会被应用。 
id 和 class 有什么不同？ 
HTML 元素可以拥有一个 id 和（或）class 属性。 
id 属性为元素指定应用一个有效名称，只能有一个具有该名称的元素。 
class 属性指定一个类名的元素，而这个名称可以被页面内的许多元素被使用。 
CSS 允许你可以对特定的 id 和/或类名的元素应用样式。 
当你想要将样式规则应用于多个块和元素时，你应该使用特定于类的样式。 
当你想给一个特定元素或块应用样式规则时就使用特定于 id 的样式。 
此样式将只用于与该特定 id 匹配的元素。 
一般建议尽量使用类，只有在特定用途（如连接标签和表单元素或用于必须在语义上唯一的样式元素）绝对必要时才使用 id： 
使用类名可以让样式具有可扩展性——即使目前只有一个元素使用这个规则集来定义样式，未来可能会添加更多。 
类名可以让你同时为多个元素赋予样式，减少样式表的大小，避免了为每一个 id 选择器撰写同样的样式信息。 
越小的样式表带来的性能体验也就越好。 
类名选择器比 id 选择器的优先级更低，所以可以很方便地覆盖它们。 
备注： 参见 CSS 选择器，以了解详情。 
我如何还原属性的默认值？ 
最初 CSS 没有提供“default”关键字和还原默认属性的值，唯一途径是显式地重新声明该属性。 
例如： 
/* 标题元素的默认颜色为黑色 */ 
h1 { 
color: red; 
} 
h1 { 
color: black; 
} 
从 CSS2 开始，情况就不一样了。 
关键字 initial 现在是一个有效的 CSS 属性值。 它将给定的 CSS 属性值重置为默认值。 
/* 标题元素的默认颜色为黑色 */ 
h1 { 
color: red; 
} 
h1 { 
color: initial; 
} 
我如何才可以从一个样式中衍生出另一种样式？ 
CSS 并不完全允许用一种样式来定义另一种样式。 
但是，将多个类分配给单个元素，可以提供相同的效果。 CSS 变量也提供了一种方法来定义在多处复用的样式信息。 
我该如何给一个元素分配多个类？ 
HTML 元素可以通过列出的类属性，用空格分开它们。 
<style> 
.news { 
background: black; 
color: white; 
} 
.today { 
font-weight: bold; 
} 
</style> 
<div class="news today">这是今天的新闻内容。 </div> 
如果两个规则中都声明了相同的属性，则首先通过特异性解决冲突，然后根据 CSS 声明的顺序解决冲突。 
class 属性中类的顺序与此无关。 
为什么我的样式规则不能正确地工作？ 
在语法上正确的样式规则可能在某些情况下不适用。 
你可以使用调试工具 CSS 面板的规则视图来调试这类问题。 下面列出了最常见的忽略样式规则的实例： 
HTML 元素层次结构 
CSS 应用于 HTML 元素依靠于元素的层次结构。 
在任何 CSS 特异性或优先级规则中，子元素定义的样式会覆盖父元素的样式。 
.news { 
color: black; 
} 
.corpName { 
font-weight: bold; 
color: red; 
} 
<!-- news 的文字是黑色的，但是 corpName 是红色且加粗的 --> 
<div class="news"> 
(Reuters) <span class="corpName">General Electric</span> (GE.NYS) announced on 
Thursday... 
</div> 
在某些复杂的 HTML 层级中，如果某条规则看起来被忽略了，请检查该元素是否处于拥有其他样式的另一个元素之内。 
显式重定义样式规则 
在 CSS 样式表中，顺序非常重要。 
如果先定义了一个规则，然后又重新定义了同样的规则，会使用最后一个定义。 
#stockTicker { 
font-weight: bold; 
} 
.stockSymbol { 
color: red; 
} 
/* 其他规则 */ 
/* 其他规则 */ 
/* 其他规则 */ 
.stockSymbol { 
font-weight: normal; 
} 
<!-- 除了”GE“以外，大部分文字都是加粗的，“GE”本身是红色不加粗的 --> 
<div id="stockTicker">NYS: <span class="stockSymbol">GE</span> +1.0 ...</div> 
为了避免此类错误，请对特定选择器仅定义一次规则，将属于那个选择器的规则归类于此组。 
使用简写属性 
使用简写属性的好处是语法更加紧凑。 
仅使用一部分简写属性完全没有问题，但要注意，没有声明的属性将自动重置为默认状态，这意味着单个属性较靠前的规则可能会被隐式覆盖。 
#stockTicker { 
font-size: 12px; 
font-family: Verdana; 
font-weight: bold; 
} 
.stockSymbol { 
font: 14px Arial; 
color: red; 
} 
<div id="stockTicker">NYS: <span class="stockSymbol">GE</span> +1.0 ...</div> 
在前一个示例中，问题发生在不同元素的规则中；但在同一个元素中问题也可能出现，因为顺序是重要的。 
#stockTicker { 
font-weight: bold; 
font: 12px Verdana; /* font-weight 现在为 normal */ 
} 
使用 * 选择器 
* 通配符选择器可以指代任何元素，必须小心使用。 
body * { 
font-weight: normal; 
} 
#stockTicker { 
font: 12px Verdana; 
} 
.corpName { 
font-weight: bold; 
} 
.stockUp { 
color: red; 
} 
<div id="section"> 
NYS: <span class="corpName"><span class="stockUp">GE</span></span> +1.0 ... 
</div> 
在这个示例中，body * 选择器应用于 body 内部任何层级的所有元素，包含了 .stockUp 类。 
故应用于 .corpName 类的 font-weight: bold; 样式就会被应用于所有元素的 font-weight: normal; 覆盖。 
由于速度缓慢，尽量不要使用 * 选择器，特别是不作为选择器的首个元素时。 
CSS 中的优先级 
当某个元素应用了多个规则时，规则的选择依赖于样式的优先级。 
内联样式（HTML 的 style 属性）最高，ID 选择器次之，再其次是类选择器，最后是元素名称选择器。{{ 
htmlelement(“div”)}} 的文本颜色将是红色的。 
div { 
color: black; 
} 
#orange { 
color: orange; 
} 
.green { 
color: green; 
} 
<div id="orange" class="green" style="color: red;">我是红的</div> 
当选择器具有多个部分时，规则会更加复杂。 
有关优先级计算的更多信息，请参阅 CSS 优先级文档。 
-moz-*， -ms-*， -webkit-*， -o-* 以及 -khtml-* 属性有什么用？ 
这些被称为前缀属性的属性是 CSS 标准的扩展。 
这些是出于测试目的的使用，不至于污染标准命名空间，防止标准扩展时产生兼容性问题。 
不推荐在生产环境网站中使用这些属性，它们已经产生了巨大的网页兼容性混乱。 
例如，很多开发者只使用了 -webkit- 前缀版本的属性，但非前缀的版本已经在所有浏览器中得到支持，没有基于 Webkit 的浏览器很有可能会在今后丢失显示效果。 
这个问题过于严重，以至于其他浏览器也开始实现 -webkit- 前缀属性的别名以提升网站兼容性，即兼容性动态标准。 
实际上，大部分浏览器在实现实验性功能时都不使用 CSS 前缀，或者仅在 Nightly 浏览器版本或相似机制上实现它们。 
如果需要使用前缀，建议先写带前缀的属性，然后再写不带前缀的标准版本。 
这样就可以在标准版本支持的时候覆盖掉前缀版本。 
例如： 
-webkit-text-stroke: 4px navy; 
text-stroke: 4px navy; 
备注： 为更深层次了解处理前缀属性，请参阅跨浏览器测试模块的处理常见的 HTML 和 CSS 问题——处理 CSS 前缀。 
备注： 请参阅 Mozilla CSS 扩展和 WebKit CSS 扩展，以了解浏览器前缀 CSS 属性的列表。 
z-index 属性与定位有什么关系？ 
z-index 属性指定了元素的栈序。 
具有较高 z-index/栈序的元素总是渲染于具有较低 z-index/栈序的元素之前。 
z-index 只会在有着指定 position（position:absolute、position:relative 或 position:fixed）的元素上工作。 
备注： 请参阅定位文章，特别是介绍 z-index 部分来深入学习。 

{{LearnSidebar}} 
本文介绍了一些通过 CSS 改变文档内容的方法。 
这样，仅修改样式表你就能把文本内容及图片添加到文档。 
CSS 的一个重要优势是它可以帮助你将文档内容和其样式分离。 
但是有时候在样式而非文档中定义一些内容也是很有用的。 
当内容与文档结构紧密相关的时候，你可以在样式表中定义文本和图片内容。 
备注： 样式表中指定的内容不会成为 DOM 的一部分。 
在样式表中指定内容会使事情变得复杂：你可能有多个语言版本的文档共享同一个样式表。 
如果样式表的一部分需要翻译，这就意味着你需要将这部分单独保存在多个样式表中，并在不同语言的文档中引用。 
如果你指定的内容由通用符号和图片组成的话，就不存在这个问题。 
示例 
文本内容 
CSS 可以在元素的前后插入文本：在选择器的后面加上 {{cssxref(“::before”)}} 或 {{cssxref(“::after”)}}。 
在声明中，指定 {{cssxref(“content”)}} 属性，并设置文本内容。 
HTML 
A text where I need to <span class="ref">something</span> 
CSS 
.ref::before { 
font-weight: bold; 
color: navy; 
content: "Reference "; 
} 
结果 
{{EmbedLiveSample(‘文本内容’, 600, 30)}} 
样式表默认使用 UTF-8 字符集。 但也可以通过 link 属性或样式表以及其他方式指定其他字符集。 
参见 CSS 规范中的 4.4 CSS style sheet representation。 
还可以通过转义机制（通过反斜杠转义）指定单个字符。 
比如，“\265B”是国际象棋黑皇后的符号 ♛。 
详细内容请参见 Referring to characters not represented in a character encoding 和 CSS 规范中的 Characters and case。 
图片内容 
可以通过将 {{cssxref(“content”)}} 属性值设置为某个图片的 URL，可以将图片插到元素的前面或后面。 
下面这条规则在所有类名包含 glossary 的 a 标签后面插入一个空格和一个图标： 
HTML 
<a href="developer.mozilla.org" class="glossary">developer.mozilla.org</a> 
CSS 
a.glossary::after { 
content: " " url("glossary-icon.gif"); 
} 
{{EmbedLiveSample(‘图片内容’, 600, 40)}} 

{{LearnSidebar}} 以下链接提供了一些你在使用 CSS 时可能遇到的常见问题的解决方案。 
主要使用事项 
基础 如何应用 CSS 到 DOM 中？ 

{{LearnSidebar}} 
层叠样式表 — 也就是{{glossary(“CSS”)}} — 是你在{{glossary(“HTML”)}}之后应该学习的第二门技术。 
HTML 用于定义内容的结构和语义，CSS 用于设计风格和布局。 
比如，你可以使用 CSS 来更改内容的字体、颜色、大小、间距，将内容分为多列，或者添加动画及其他的装饰效果。 
学习路径 
在尝试学习 CSS 之前，你应该了解 HTML 的基础知识。 
建议你先学习 HTML 简介模块 — 这一模块主要介绍了以下内容： 
CSS，从 CSS 模块简介开始 更高级的HTML 模块 
JavaScript，如何使用 Javascript 给网页加上动态功能 
我们建议你同时学习 HTML 和 CSS，在这两个主题之间来回切换。 
因为有着 CSS 的 HTML 更加有趣，并且不了解 HTML 就不能真正掌握 CSS。 
在学习本章节之前，你应该会使用计算机，熟练的使用网页操作（哪怕只是盯着屏幕看）。 
你应该配置好一个基本的操作环境（见安装基本软件），知道如何创建和管理文件（见处理文件）—这两个都是 Web 入门 的初学者模块的一部分。 
我们建议你在学习本章内容前，先完成 Web 入门，尽管这不是必须的；CSS 基础文章中涵盖的大部分内容在 CSS 模块简介中也有，而且 CSS 模块涵盖了更多的细节。 
模块 
本主题包含以下模块，建议按顺序阅读这些模块。 
你应该从第一个模块开始。 
CSS 初步 
: 这个模块介绍了使用 CSS 的基础知识，包括选择器和属性，编写 CSS 的规则，将 CSS 应用于 HTML 的方法，如何在 CSS 中指定长度、颜色和其他单位，层叠与继承，盒模型基础以及 CSS 的调试。 
构建 CSS 块 
: 本模块承接CSS 初步，进行进一步的学习——既然你已经熟悉了 CSS 的语言和语法，有了一些使用 CSS 的基本经验，是时候再深入一些了。 
本模块涉及了层叠与继承、可用的所有种类的选择器、单位、尺寸、样式化背景和边框、调试，还有更多。 
这样做的目的是，在继续深入到更加具体的规则，例如样式化文本和CSS 布局前，为你提供一个用于编写堪用的 CSS 的工具箱，帮你理解所有必要的理论。 
样式化文本 
: 这个模块介绍基础的文本样式，包括字体属性的设置，粗体和斜体，行和字母间距，阴影和其他文本功能。 
我们通过在网页上设置特定的字体，指定列表和链接的样式来完成这一模块。 
CSS 布局 
: 到目前为止，我们已经学习了 CSS 基础知识、如何设置文本样式、如何设计并操作内容所在的框。 
现在应该考虑如何把你的框以合适的位置放置在视口内和其他框旁边了。 
我们已经学习了在深入 CSS 布局之前需要学会的必要知识，下一步我们通过学习设置 display 属性、使用新的布局工具如弹性盒（flexbox），CSS 网格和定位、以及你仍想知道的一些传统技术，来深入学习 CSS 布局。 
解决常见的 CSS 问题 
使用 CSS 解决常见问题解释了怎样使用 CSS 解决创建一个网页时常遇到的问题。 
从这里开始，你大致就能在 HTML 元素和它们的背景上应用颜色、改变形状尺寸和元素的位置、向元素上添加并定义边框。 
不过一旦你牢固掌握了即便是 CSS 最基础的部分，也没有很多做不到的事情。 
学习 CSS 最棒的一件事情就是，一旦你知道了基本的原理，即使你实际上不知道怎么做，你通常还是会很清楚什么能做到而什么不能做到！ 
参阅 
CSS on MDN 
: MDN 上 css 文档的主要入口，包括详细的参考到高级的教程一系列内容。 


{{LearnSidebar}} 
掌握了 CSS 语言的基础之后，对于你来说，下一个需要关心的 CSS 主题就是为文本添加样式——一个你将会最经常使用 CSS 做的事情。 
在这里，我们专注于为文本样式的基础，包括设置字体、粗细、斜体、行还有字符间距、阴影以及文本的其他特征。 
我们将会通过在你的网页中应用自定义字体、样式化列表以及链接来圆满地结束本模块。 
前提 
在开始这一模块之前，你应当像 HTML 介绍 模块中所探讨的，已经熟悉了基本的 HTML，以及像 CSS 介绍 中所详述的，对自己的 CSS 基础感觉还满意。 
备注： 如果你所使用的是不能创建自己的文件的电脑、平板电脑或其他设备的话，你可以在一个在线编码程序 JSBin 或 Glitch 中尝试（大部分的）代码例子。 
导引 
这个模块包括了以下文章，这些文章将教会你所有的基本功以支持你为 HTML 文本内容添加样式。 
基本的文本以及字体样式 
: 在本文章中，我们将通篇了解文本、字体样式的所有基础，包括设置字体粗细（font weight）、字体系列及样式（family and style）、字体缩写（font shorthand）、文本排列（text alignment）和其他的效果，还有行（line）以及字符间距（letter spacing）。 
样式化列表 
: 对于大部分内容来说，列表的行为表现跟其他任何文本其实差不多，但你也需要了解还有一些专门用于列表的 CSS 样式以及考虑一些最好的实践方式。 
本文章将阐释这一切。 
样式化链接 
: 当你为链接添加样式时，很重要的一点是要去理解怎样有效地使用伪类去修饰链接的状态，以及怎么去修饰不同的接口功能例如导航菜单和面板中所使用的链接。 
我们将会在这篇文章中讨论这些话题。 
网络字体 
: 在这里我们将会详细地探索网络字体——这会允许你与你的网页一同下载自定义字体，来实现更为不同的个性化字体样式。 
评估 
以下的评估将会评测你对以上导引所涵盖的为文本添加样式的技术的理解。 
对一个社区学校的主页进行排版 
: 在这个评估中，我们通过让你为一个社区学校的主页添加文本样式来测试你对文本样式的理解程度。 





{{LearnSidebar}}{{PreviousMenuNext(“Learn/Forms/Styling_web_forms”, “Learn/Forms/UI_pseudo-classes”, “Learn/Forms”)}} 
在本文中，我们将看到HTML表单怎样使用CSS装饰难以定制的表单小部件。 如前面章节所示，文本域和按钮完全可以使用 CSS，现在我们将深入探索 HTML 表单样式。 
bad : 这个元素很难设计，需要一些复杂的技巧，有时还涉及到高级的 CSS3 的知识。 
ugly 
: 忘记使用 CSS 来设计这些元素吧。 
CSS 表现力 
除了文本框和按钮之外，使用其他表单小部件的主要问题是在许多情况下，CSS 的表现不能满足设计复杂的小部件的要求。 
HTML 和 CSS 最新的发展扩展了 CSS 的表现力： 
CSS 2.1 非常受限，只给出三个伪类： {{cssxref(“:active”)}} 
{{cssxref(“:focus”)}} 
{{cssxref(“:hover”)}} 
CSS Selector Level 3 增加了三个与 HTML 表单相关的伪类： 
{{cssxref(“:enabled”)}} 
{{cssxref(“:disabled”)}} 
{{cssxref(“:checked”)}} 
{{cssxref(“:indeterminate”)}} 
CSS Basic UI Level 3 也增加了几个伪类用于描述小部件的状态： 
{{cssxref(“:default”)}} 
{{cssxref(“:valid”)}} 
{{cssxref(“:invalid”)}} 
{{cssxref(“:in-range”)}} 
{{cssxref(“:out-of-range”)}} 
{{cssxref(“:required”)}} 
{{cssxref(“:optional”)}} 
{{cssxref(“:read-only”)}} 
{{cssxref(“:read-write”)}} 
CSS Selector Level 4 目前处于积极应用和重点讨论的状态，但并不打算为表单做更多的改善： 
{{cssxref(“:user-error”)}} 只是改进了伪类{{cssxref(“:invalid”)}}。 
{{cssxref(“:-moz-placeholder”)}} 
{{cssxref(“:-moz-submit-invalid”)}} 
{{cssxref(“:-moz-ui-invalid”)}} 
{{cssxref(“:-moz-ui-valid”)}} 
WebKit CSS 扩展 
{{cssxref(“::-webkit-input-placeholder”)}} 
其他 
Microsoft CSS 扩展 
:-ms-input-placeholder 
控制表单元素的外观 
基于 WebKit(Chrome, Safari) 和 Gecko(Firefox) 的浏览器提供更高级的 HTML 部件定制。 
它们也实现了跨平台，因此需要一种方式把原生小部件转换为用户可设置样式的小部件。 
为此，它们使用了专有属性：{{cssxref(“-webkit-appearance”)}}或{{cssxref(“-moz-appearance”)}}。 
这些属性是非标准的，不应该使用。 
事实上，它们在 WebKit 和 Gecko 中的表现也是不相同的。 
然而，有一个值很好用：none，用这个值，你（几乎完全）能控制一个已知小部件的样式。 
我们下面有一些例子，这个属性最成功的例子是 WebKit 浏览器中的搜索域的样式： <form> 
<input type="search" /> 
</form> <style> 
input[type=search] { 
border: 1px dotted #999; border-radius: 0; 
-webkit-appearance: none; } </style> 
{{EmbedLiveSample(“控制表单元素的外观”, 250, 40)}} 
备注： 当我们谈及 Web 技术的时总是很难预测未来。 
扩展 CSS 表现力是很困难的，其他规范也做了一些探索性的工作，如Shadow DOM提供了一些观点。 
可完全设置样式的表单的问题还远未结束。 
独自设计复选框或单选按钮的样式是让人抓狂的。 
例如由于浏览器反应各不相同，在修改复选框和单选按钮的大小时，并不保证确实能改变它们。 一个简单的测试用例 
让我们研究一下下面的测试用例： 
<span><input type="checkbox" /></span> 
span { 
display: inline-block; 
background: red; 
} 
input[type="checkbox"] { 
width: 100px; 
height: 100px; 
} 
这里是不同的浏览器的处理方式： 
浏览器 
视图 
Firefox 57 (Mac OSX) 
Firefox 57 (Windows 10) 
Chrome 63 (Mac OSX) 
Chrome 63 (Windows 10) 
Internet Explorer 11 (Windows 10) 
Edge 16 (Windows 10) 更复杂的例子 
由于 Opera 和 Internet Explorer 没有像{{cssxref(“-webkit-appearance”)}}或{{cssxref(“-moz-appearance”)}}这样的特性，使用它们是不合适的。 
<form> 
<fieldset> 
<p> 
<input type="checkbox" id="first" name="fruit-1" value="cherry" /> 
<label for="first">I like cherry</label> 
</p> 
<p> 
<input 
type="checkbox" id="second" 
name="fruit-2" 
disabled /> 
</p> 
<p> 
<input type="checkbox" id="third" name="fruit-3" value="strawberry" /> 
<label for="third">I like strawberry</label> 
</p> 
</fieldset> 
</form> 
带有一些基本的样式： body { 
font: 1em sans-serif; } 
display: inline-block; 
} 
fieldset { 
border: 1px solid #ccc; border-radius: 5px; 
margin: 0; 
padding: 1em; 
} 
label { 
cursor: pointer; 
} 
p { 
} p + p { 
margin: 0.5em 0 0; 
} 
备注： 下面的内容（仅限样式化 checkbox 部分）与英文版出入极大，猜测已经是过时内容 
现在，让我们设计一个定制复选框的样式 
计划用自己的图像替换原生的复选框，首先需要准备复选框在所有状态下的图像，那些状态是：未选、已选、禁用不选、禁用已选。 
该图像将用作 CSS 精灵： 
Check box CSS Sprite 
一开始要隐藏初始复选框。 可以简单的把它们从页面视图中拿开。 这里要考虑两个重要的事情： 
不能用display:none来隐藏复选框，因为后面我们需要把复选框对用户可见。 
而使用display:none，用户不能再访问这个复选框，这就表示复选框不能选择或不选择。 
我们将使用 CSS3 选择器来实现定制的样式，为了支持旧版浏览器，可以在所有选择器前设置{{cssxref(“:root”)}}伪类。 
目前所有我们需要支持的浏览器都支持{{cssxref(“:root”)}}伪类，但是其他的并不能保证。 
这是一个过滤旧的 Internet Explorer 的便利方式的例子。 那些旧版浏览器将看到传统的复选框，而新式的浏览器可以看到定制的复选框。 :root input[type="checkbox"] { /* original check box are push outside the viexport */ position: absolute; left: -1000em; } 
现在加上自己的图像就可以摆脱原来的复选框了，为此，要在初始的复选框后面加上{{HTMLElement(“label”)}}元素，并使用它的{{cssxref(“:before”)}}伪元素。 
因此在下面章节中，要使用selector 属性来选择复选框，然后使用adjacent sibling selector来选择原有复选框后面的label。 
最后，访问{{cssxref(“:before”)}}伪元素来设计复选框显示定制样式。 
:root input[type="checkbox"] + label:before { 
content: ""; 
display: inline-block; 
width: 16px; 
height: 16px; 
margin: 0 0.5em 0 0; 
no-repeat 0 0; 
vertical-align: bottom; 
position: relative; 
} 
因为使用了 CSS 精灵，我们需要做的只是修改背景的位置。 
:root input[type="checkbox"]:checked + label:before { 
} 
:root input[type="checkbox"]:disabled + label:before { 
:root input[type="checkbox"]:focus + label:before { 
outline: 1px dotted black; } 
你可以在线查看结果： 
{{EmbedLiveSample(“更复杂的例子”, 250, 130)}} 
Dealing with the select nightmare 
<select> 
<option>Cherry</option> 
<option>Banana</option> 
<option>Strawberry</option> 
</select> 
select { 
width: 80px; 
padding: 10px; 
} option { 
padding: 5px; 
color: red; 
} 
select, option { 
-webkit-appearance: none; /* To gain control over the appearance on WebKit/Chromium */ 
-moz-appearance: none; /* To gain control over the appearance on Gecko */ 
/* To gain control over the appearance on and Trident (IE) 
Note that it also works on Gecko and has partial effects on WebKit */ 
background: none; 
} 
Browser 
Regular rendering 
Tweaked rendering 
closed 
open 
closed 
open 
Firefox 57 (Mac OSX) 
Firefox 57 (Windows 10) 
Chrome 63 (Mac OSX) 
Chrome 63 (Windows 10) 
Opera 49 (Mac OSX) 
IE11 (Windows 10) 
Edge 16 (Windows 10) 
如你所见，计时使用了-*-appearance属性的帮助，任然有一些遗留的问题： 
不同的操作系统和浏览器对属性{{cssxref(“padding”)}} 属性的处理各不相同。 
Internet Explorer 旧版本不允许平滑样式 
Firefox 没有实现下拉箭头的样式。 
如果要在下拉列表内实现{{HTMLElement(“option”)}}元素样式，Chrome 和 Opera 浏览器的表现在不同的系统中是不一样的。 
在我们的例子中，只使用了三个 CSS 属性，在考虑使用更多 CSS 属性时，可以想象是很混乱的。 
正如我们看到的，CSS 始终不适合用来修改这些小部件的外观，但是仍然可以用来稍微做一些事情。 
如果愿意的话，可以演示一下在不同操作系统和浏览器之间的区别。 
我们也可以帮助了解在下一章节中哪个属性更合适：Properties compatibility table for form widgets 走向更完美表单之路：有用的库和 polyfills（腻子） 
虽然对于复选框和单选按钮而言，CSS 的表示方式足够丰富，但是对更高级的小部件来说差距仍然很大。 
即使可以用{{HTMLElement(“select”)}}元素作一些事情，但是对 file 小部件的样式完全没用。 
要实现对表单小部件的完全控制，你别无选择，只能选择依靠 JavaScript。 
在文章How to build custom form widgets中，我们将看到具体的做法，其中还有一些非常有用的库： 
Uni-form是一个对采用 CSS 样式的表单标记实现标准化的框架，在使用 jQuery 时，还提供一些附加特性，但这是可选的。 
Formalize是对公共 JavaScript 框架的扩展（如 jQuery, Dojo, YUI 等），有助于规范和定制表单。 
Niceforms是一个独立的 JavaScript 方法，能提供 web 表单的完整定制。 
下面的库不止应用于表单，他们在处理 HTML 表单时是非常有趣的： 
jQuery UI做了一些有趣的改进，可以定制象日期选择器（特别关注无障碍）这样的小部件。 
Twitter Bootstrap在规范表单时是非常有用的。 
WebShim是一个大型工具，可以用来处理浏览器对 HTML5 的支持。 
对 web 表单部分确实有用。 
记住，使用 CSS 和 JavaScript 是有副作用的。 
所以在选择使用那些库时，应该在脚本失败的情况下能回滚样式表。 
脚本失败的原因很多，尤其在手机应用中，因此你需要尽可能好的设计你的 Web 站点或应用。 
总结 
虽然 HTML 表单使用 CSS 仍有一些困难，但通常也有方法绕过它们。 
即使没有清楚的，通用的解决方案，但新式的浏览器也提供了新的可能性。 
目前最好的方法是更多的学习不同浏览器支持 CSS 的方式，并应用于 HTML 表单小部件。 
在本指南的下一章节中，我们将探讨现代浏览器中用于为不同表单状态添加样式的可用的 UI 伪类。 
{{PreviousMenuNext(“Learn/Forms/Styling_web_forms”, “Learn/Forms/UI_pseudo-classes”, “Learn/Forms”)}} 
进阶内容 
如何构建自定义表单控件 
通过 JavaScript 发送表单 
表单控件的属性兼容性列表 



这是第一个如何构建自定义表单控件的代码解释事例。 
基本状态 
HTML 
<div class="select"> 
<span class="value">Cherry</span> 
<ul class="optList hidden"> 
<li class="option">Cherry</li> 
<li class="option">Lemon</li> 
<li class="option">Banana</li> 
<li class="option">Strawberry</li> 
<li class="option">Apple</li> 
</ul> 
</div> 
CSS 
/*--------- */ 
/* 所需的样式 */ 
/* -------- */ 
.select { 
position: relative; 
display: inline-block; 
} 
.select.active, 
.select:focus { 
box-shadow: 0 0 3px 1px #227755; 
outline: none; 
} 
.select .optList { 
position: absolute; 
top: 100%; 
left: 0; 
} 
.select .optList.hidden { 
max-height: 0; 
visibility: hidden; 
} 
/* ------- */ 
/* 美化样式 */ 
/* ------- */ 
.select { 
font-size: 0.625em; /* 10px */ 
font-family: Verdana, Arial, sans-serif; 
box-sizing: border-box; 
padding: 0.1em 2.5em 0.2em 0.5em; /* 1px 25px 2px 5px */ 
width: 10em; /* 100px */ 
border: 0.2em solid #000; /* 2px */ 
border-radius: 0.4em; /* 4px */ 
box-shadow: 0 0.1em 0.2em rgba(0, 0, 0, 0.45); /* 0 1px 2px */ 
background: #f0f0f0; 
background: linear-gradient(0deg, #e3e3e3, #fcfcfc 50%, #f0f0f0); 
} 
.select .value { 
display: inline-block; 
width: 100%; 
overflow: hidden; 
white-space: nowrap; 
text-overflow: ellipsis; 
vertical-align: top; 
} 
.select::after { 
content: "▼"; 
position: absolute; 
z-index: 1; 
height: 100%; 
width: 2em; /* 20px */ 
top: 0; 
right: 0; 
padding-top: 0.1em; 
box-sizing: border-box; 
text-align: center; 
border-left: 0.2em solid #000; 
border-radius: 0 0.1em 0.1em 0; 
background-color: #000; 
color: #fff; 
} 
.select .optList { 
z-index: 2; 
list-style: none; 
margin: 0; 
padding: 0; 
background: #f0f0f0; 
border: 0.2em solid #000; 
border-top-width: 0.1em; 
border-radius: 0 0 0.4em 0.4em; 
box-shadow: 0 0.2em 0.4em rgba(0, 0, 0, 0.4); 
box-sizing: border-box; 
min-width: 100%; 
max-height: 10em; /* 100px */ 
overflow-y: auto; 
overflow-x: hidden; 
} 
.select .option { 
padding: 0.2em 0.3em; 
} 
.select .highlight { 
background: #000; 
color: #ffffff; 
} 
基本状态结果 
{{ EmbedLiveSample(‘基本状态’, 120, 130) }} 
活动状态 
HTML 
<div class="select active"> 
<span class="value">Cherry</span> 
<ul class="optList hidden"> 
<li class="option">Cherry</li> 
<li class="option">Lemon</li> 
<li class="option">Banana</li> 
<li class="option">Strawberry</li> 
<li class="option">Apple</li> 
</ul> 
</div> 
CSS 
/*--------- */ 
/* 所需的样式 */ 
/* -------- */ 
.select { 
position: relative; 
display: inline-block; 
} 
.select.active, 
.select:focus { 
box-shadow: 0 0 3px 1px #227755; 
outline: none; 
} 
.select .optList { 
position: absolute; 
top: 100%; 
left: 0; 
} 
.select .optList.hidden { 
max-height: 0; 
visibility: hidden; 
} 
/* ------- */ 
/* 美化样式 */ 
/* ------- */ 
.select { 
font-size: 0.625em; /* 10px */ 
font-family: Verdana, Arial, sans-serif; 
box-sizing: border-box; 
padding: 0.1em 2.5em 0.2em 0.5em; /* 1px 25px 2px 5px */ 
width: 10em; /* 100px */ 
border: 0.2em solid #000; /* 2px */ 
border-radius: 0.4em; /* 4px */ 
box-shadow: 0 0.1em 0.2em rgba(0, 0, 0, 0.45); /* 0 1px 2px */ 
background: #f0f0f0; 
background: linear-gradient(0deg, #e3e3e3, #fcfcfc 50%, #f0f0f0); 
} 
.select .value { 
display: inline-block; 
width: 100%; 
overflow: hidden; 
white-space: nowrap; 
text-overflow: ellipsis; 
vertical-align: top; 
} 
.select::after { 
content: "▼"; 
position: absolute; 
z-index: 1; 
height: 100%; 
width: 2em; /* 20px */ 
top: 0; 
right: 0; 
padding-top: 0.1em; 
box-sizing: border-box; 
text-align: center; 
border-left: 0.2em solid #000; 
border-radius: 0 0.1em 0.1em 0; 
background-color: #000; 
color: #fff; 
} 
.select .optList { 
z-index: 2; 
list-style: none; 
margin: 0; 
padding: 0; 
background: #f0f0f0; 
border: 0.2em solid #000; 
border-top-width: 0.1em; 
border-radius: 0 0 0.4em 0.4em; 
box-shadow: 0 0.2em 0.4em rgba(0, 0, 0, 0.4); 
box-sizing: border-box; 
min-width: 100%; 
max-height: 10em; /* 100px */ 
overflow-y: auto; 
overflow-x: hidden; 
} 
.select .option { 
padding: 0.2em 0.3em; 
} 
.select .highlight { 
background: #000; 
color: #ffffff; 
} 
活动状态结果 
{{ EmbedLiveSample(‘活动状态’, 120, 130) }} 
展开状态 
HTML 
<div class="select active"> 
<span class="value">Cherry</span> 
<ul class="optList"> 
<li class="option highlight">Cherry</li> 
<li class="option">Lemon</li> 
<li class="option">Banana</li> 
<li class="option">Strawberry</li> 
<li class="option">Apple</li> 
</ul> 
</div> 
CSS 
/*--------- */ 
/* 所需的样式 */ 
/* -------- */ 
.select { 
position: relative; 
display: inline-block; 
} 
.select.active, 
.select:focus { 
box-shadow: 0 0 3px 1px #227755; 
outline: none; 
} 
.select .optList { 
position: absolute; 
top: 100%; 
left: 0; 
} 
.select .optList.hidden { 
max-height: 0; 
visibility: hidden; 
} 
/* ------- */ 
/* 美化样式 */ 
/* ------- */ 
.select { 
font-size: 0.625em; /* 10px */ 
font-family: Verdana, Arial, sans-serif; 
box-sizing: border-box; 
padding: 0.1em 2.5em 0.2em 0.5em; /* 1px 25px 2px 5px */ 
width: 10em; /* 100px */ 
border: 0.2em solid #000; /* 2px */ 
border-radius: 0.4em; /* 4px */ 
box-shadow: 0 0.1em 0.2em rgba(0, 0, 0, 0.45); /* 0 1px 2px */ 
background: #f0f0f0; 
background: linear-gradient(0deg, #e3e3e3, #fcfcfc 50%, #f0f0f0); 
} 
.select .value { 
display: inline-block; 
width: 100%; 
overflow: hidden; 
white-space: nowrap; 
text-overflow: ellipsis; 
vertical-align: top; 
} 
.select::after { 
content: "▼"; 
position: absolute; 
z-index: 1; 
height: 100%; 
width: 2em; /* 20px */ 
top: 0; 
right: 0; 
padding-top: 0.1em; 
box-sizing: border-box; 
text-align: center; 
border-left: 0.2em solid #000; 
border-radius: 0 0.1em 0.1em 0; 
background-color: #000; 
color: #fff; 
} 
.select .optList { 
z-index: 2; 
list-style: none; 
margin: 0; 
padding: 0; 
background: #f0f0f0; 
border: 0.2em solid #000; 
border-top-width: 0.1em; 
border-radius: 0 0 0.4em 0.4em; 
box-shadow: 0 0.2em 0.4em rgba(0, 0, 0, 0.4); 
box-sizing: border-box; 
min-width: 100%; 
max-height: 10em; /* 100px */ 
overflow-y: auto; 
overflow-x: hidden; 
} 
.select .option { 
padding: 0.2em 0.3em; 
} 
.select .highlight { 
background: #000; 
color: #fff; 
} 
展开状态结果 
{{ EmbedLiveSample(‘展开状态’, 120, 130) }} 

这是解释如何构建自定义表单控件的第二个示例。 
使用 JS 
HTML 
<form class="no-widget"> 
<select name="myFruit"> 
<option>Cherry</option> 
<option>Lemon</option> 
<option>Banana</option> 
<option>Strawberry</option> 
<option>Apple</option> 
</select> 
<div class="select"> 
<span class="value">Cherry</span> 
<ul class="optList hidden"> 
<li class="option">Cherry</li> 
<li class="option">Lemon</li> 
<li class="option">Banana</li> 
<li class="option">Strawberry</li> 
<li class="option">Apple</li> 
</ul> 
</div> 
</form> 
CSS 
.widget select, 
.no-widget .select { 
position: absolute; 
left: -5000em; 
height: 0; 
overflow: hidden; 
} 
/*--------- */ 
/* 所需的样式 */ 
/* -------- */ 
.select { 
position: relative; 
display: inline-block; 
} 
.select.active, 
.select:focus { 
box-shadow: 0 0 3px 1px #227755; 
outline: none; 
} 
.select .optList { 
position: absolute; 
top: 100%; 
left: 0; 
} 
.select .optList.hidden { 
max-height: 0; 
visibility: hidden; 
} 
/* ------- */ 
/* 美化样式 */ 
/* ------- */ 
.select { 
font-size: 0.625em; /* 10px */ 
font-family: Verdana, Arial, sans-serif; 
box-sizing: border-box; 
padding: 0.1em 2.5em 0.2em 0.5em; /* 1px 25px 2px 5px */ 
width: 10em; /* 100px */ 
border: 0.2em solid #000; /* 2px */ 
border-radius: 0.4em; /* 4px */ 
box-shadow: 0 0.1em 0.2em rgba(0, 0, 0, 0.45); /* 0 1px 2px */ 
background: #f0f0f0; 
background: linear-gradient(0deg, #e3e3e3, #fcfcfc 50%, #f0f0f0); 
} 
.select .value { 
display: inline-block; 
width: 100%; 
overflow: hidden; 
white-space: nowrap; 
text-overflow: ellipsis; 
vertical-align: top; 
} 
.select::after { 
content: "▼"; 
position: absolute; 
z-index: 1; 
height: 100%; 
width: 2em; /* 20px */ 
top: 0; 
right: 0; 
padding-top: 0.1em; 
box-sizing: border-box; 
text-align: center; 
border-left: 0.2em solid #000; 
border-radius: 0 0.1em 0.1em 0; 
background-color: #000; 
color: #fff; 
} 
.select .optList { 
z-index: 2; 
list-style: none; 
margin: 0; 
padding: 0; 
background: #f0f0f0; 
border: 0.2em solid #000; 
border-top-width: 0.1em; 
border-radius: 0 0 0.4em 0.4em; 
box-shadow: 0 0.2em 0.4em rgba(0, 0, 0, 0.4); 
box-sizing: border-box; 
min-width: 100%; 
max-height: 10em; /* 100px */ 
overflow-y: auto; 
overflow-x: hidden; 
} 
.select .option { 
padding: 0.2em 0.3em; 
} 
.select .highlight { 
background: #000; 
color: #ffffff; 
} 
JavaScript 
window.addEventListener("load", () => { 
const form = document.querySelector("form"); 
form.classList.remove("no-widget"); 
form.classList.add("widget"); 
}); 
结果 
{{ EmbedLiveSample(‘使用 JS’, 120, 130) }} 
不使用 JS 
HTML 
<form class="no-widget"> 
<select name="myFruit"> 
<option>Cherry</option> 
<option>Lemon</option> 
<option>Banana</option> 
<option>Strawberry</option> 
<option>Apple</option> 
</select> 
<div class="select"> 
<span class="value">Cherry</span> 
<ul class="optList hidden"> 
<li class="option">Cherry</li> 
<li class="option">Lemon</li> 
<li class="option">Banana</li> 
<li class="option">Strawberry</li> 
<li class="option">Apple</li> 
</ul> 
</div> 
</form> 
CSS 
.widget select, 
.no-widget .select { 
position: absolute; 
left: -5000em; 
height: 0; 
overflow: hidden; 
} 
结果 
{{ EmbedLiveSample(‘不使用 JS’, 120, 130) }} 

这是解释如何构建自定义表单控件的第三个示例。 
改变状态 
HTML 
<form class="no-widget"> 
<select name="myFruit" tabindex="-1"> 
<option>Cherry</option> 
<option>Lemon</option> 
<option>Banana</option> 
<option>Strawberry</option> 
<option>Apple</option> 
</select> 
<div class="select" tabindex="0"> 
<span class="value">Cherry</span> 
<ul class="optList hidden"> 
<li class="option">Cherry</li> 
<li class="option">Lemon</li> 
<li class="option">Banana</li> 
<li class="option">Strawberry</li> 
<li class="option">Apple</li> 
</ul> 
</div> 
</form> 
CSS 
.widget select, 
.no-widget .select { 
position: absolute; 
left: -5000em; 
height: 0; 
overflow: hidden; 
} 
/*--------- */ 
/* 所需的样式 */ 
/* -------- */ 
.select { 
position: relative; 
display: inline-block; 
} 
.select.active, 
.select:focus { 
box-shadow: 0 0 3px 1px #227755; 
outline: none; 
} 
.select .optList { 
position: absolute; 
top: 100%; 
left: 0; 
} 
.select .optList.hidden { 
max-height: 0; 
visibility: hidden; 
} 
/* ------- */ 
/* 美化样式 */ 
/* ------- */ 
.select { 
font-size: 0.625em; /* 10px */ 
font-family: Verdana, Arial, sans-serif; 
box-sizing: border-box; 
padding: 0.1em 2.5em 0.2em 0.5em; /* 1px 25px 2px 5px */ 
width: 10em; /* 100px */ 
border: 0.2em solid #000; /* 2px */ 
border-radius: 0.4em; /* 4px */ 
box-shadow: 0 0.1em 0.2em rgba(0, 0, 0, 0.45); /* 0 1px 2px */ 
background: #f0f0f0; 
background: linear-gradient(0deg, #e3e3e3, #fcfcfc 50%, #f0f0f0); 
} 
.select .value { 
display: inline-block; 
width: 100%; 
overflow: hidden; 
white-space: nowrap; 
text-overflow: ellipsis; 
vertical-align: top; 
} 
.select::after { 
content: "▼"; 
position: absolute; 
z-index: 1; 
height: 100%; 
width: 2em; /* 20px */ 
top: 0; 
right: 0; 
padding-top: 0.1em; 
box-sizing: border-box; 
text-align: center; 
border-left: 0.2em solid #000; 
border-radius: 0 0.1em 0.1em 0; 
background-color: #000; 
color: #fff; 
} 
.select .optList { 
z-index: 2; 
list-style: none; 
margin: 0; 
padding: 0; 
background: #f0f0f0; 
border: 0.2em solid #000; 
border-top-width: 0.1em; 
border-radius: 0 0 0.4em 0.4em; 
box-shadow: 0 0.2em 0.4em rgba(0, 0, 0, 0.4); 
box-sizing: border-box; 
min-width: 100%; 
max-height: 10em; /* 100px */ 
overflow-y: auto; 
overflow-x: hidden; 
} 
.select .option { 
padding: 0.2em 0.3em; 
} 
.select .highlight { 
background: #000; 
color: #ffffff; 
} 
JavaScript 
// ------- // 
// 函数定义 // 
// ------- // 
function deactivateSelect(select) { 
if (! 
select.classList.contains("active")) return; 
const optList = select.querySelector(".optList"); 
optList.classList.add("hidden"); 
select.classList.remove("active"); 
} 
function activeSelect(select, selectList) { 
if (select.classList.contains("active")) return; 
selectList.forEach(deactivateSelect); 
select.classList.add("active"); 
} 
function toggleOptList(select, show) { 
const optList = select.querySelector(".optList"); 
optList.classList.toggle("hidden"); 
} 
function highlightOption(select, option) { 
const optionList = select.querySelectorAll(".option"); 
optionList.forEach((other) => { 
other.classList.remove("highlight"); 
}); 
option.classList.add("highlight"); 
} 
// ------- // 
// 事件绑定 // 
// ------- // 
window.addEventListener("load", () => { 
const form = document.querySelector("form"); 
form.classList.remove("no-widget"); 
form.classList.add("widget"); 
}); 
window.addEventListener("load", () => { 
const selectList = document.querySelectorAll(".select"); 
selectList.forEach((select) => { 
const optionList = select.querySelectorAll(".option"); 
optionList.forEach((option) => { 
option.addEventListener("mouseover", () => { 
highlightOption(select, option); 
}); 
}); 
select.addEventListener( 
"click", 
(event) => { 
toggleOptList(select); 
}, 
false, 
); 
select.addEventListener("focus", (event) => { 
activeSelect(select, selectList); 
}); 
select.addEventListener("blur", (event) => { 
deactivateSelect(select); 
}); 
select.addEventListener("keyup", (event) => { 
if (event.key === "Escape") { 
deactivateSelect(select); 
} 
}); 
}); 
}); 
结果 
{{ EmbedLiveSample(‘改变状态’) }} 

这是解释如何构建自定义表单控件的第四个示例。 
改变状态 
HTML 
<form class="no-widget"> 
<select name="myFruit"> 
<option>Cherry</option> 
<option>Lemon</option> 
<option>Banana</option> 
<option>Strawberry</option> 
<option>Apple</option> 
</select> 
<div class="select"> 
<span class="value">Cherry</span> 
<ul class="optList hidden"> 
<li class="option">Cherry</li> 
<li class="option">Lemon</li> 
<li class="option">Banana</li> 
<li class="option">Strawberry</li> 
<li class="option">Apple</li> 
</ul> 
</div> 
</form> 
CSS 
.widget select, 
.no-widget .select { 
position: absolute; 
left: -5000em; 
height: 0; 
overflow: hidden; 
} 
/*--------- */ 
/* 所需的样式 */ 
/* -------- */ 
.select { 
position: relative; 
display: inline-block; 
} 
.select.active, 
.select:focus { 
box-shadow: 0 0 3px 1px #227755; 
outline: none; 
} 
.select .optList { 
position: absolute; 
top: 100%; 
left: 0; 
} 
.select .optList.hidden { 
max-height: 0; 
visibility: hidden; 
} 
/* ------- */ 
/* 美化样式 */ 
/* ------- */ 
.select { 
font-size: 0.625em; /* 10px */ 
font-family: Verdana, Arial, sans-serif; 
box-sizing: border-box; 
padding: 0.1em 2.5em 0.2em 0.5em; /* 1px 25px 2px 5px */ 
width: 10em; /* 100px */ 
border: 0.2em solid #000; /* 2px */ 
border-radius: 0.4em; /* 4px */ 
box-shadow: 0 0.1em 0.2em rgba(0, 0, 0, 0.45); /* 0 1px 2px */ 
background: #f0f0f0; 
background: linear-gradient(0deg, #e3e3e3, #fcfcfc 50%, #f0f0f0); 
} 
.select .value { 
display: inline-block; 
width: 100%; 
overflow: hidden; 
white-space: nowrap; 
text-overflow: ellipsis; 
vertical-align: top; 
} 
.select::after { 
content: "▼"; 
position: absolute; 
z-index: 1; 
height: 100%; 
width: 2em; /* 20px */ 
top: 0; 
right: 0; 
padding-top: 0.1em; 
box-sizing: border-box; 
text-align: center; 
border-left: 0.2em solid #000; 
border-radius: 0 0.1em 0.1em 0; 
background-color: #000; 
color: #fff; 
} 
.select .optList { 
z-index: 2; 
list-style: none; 
margin: 0; 
padding: 0; 
background: #f0f0f0; 
border: 0.2em solid #000; 
border-top-width: 0.1em; 
border-radius: 0 0 0.4em 0.4em; 
box-shadow: 0 0.2em 0.4em rgba(0, 0, 0, 0.4); 
box-sizing: border-box; 
min-width: 100%; 
max-height: 10em; /* 100px */ 
overflow-y: auto; 
overflow-x: hidden; 
} 
.select .option { 
padding: 0.2em 0.3em; 
} 
.select .highlight { 
background: #000; 
color: #ffffff; 
} 
JavaScript 
// ------- // 
// 函数定义 // 
// ------- // 
function deactivateSelect(select) { 
if (! 
select.classList.contains("active")) return; 
const optList = select.querySelector(".optList"); 
optList.classList.add("hidden"); 
select.classList.remove("active"); 
} 
function activeSelect(select, selectList) { 
if (select.classList.contains("active")) return; 
selectList.forEach(deactivateSelect); 
select.classList.add("active"); 
} 
function toggleOptList(select, show) { 
const optList = select.querySelector(".optList"); 
optList.classList.toggle("hidden"); 
} 
function highlightOption(select, option) { 
const optionList = select.querySelectorAll(".option"); 
optionList.forEach((other) => { 
other.classList.remove("highlight"); 
}); 
option.classList.add("highlight"); 
} 
function updateValue(select, index) { 
const nativeWidget = select.previousElementSibling; 
const value = select.querySelector(".value"); 
const optionList = select.querySelectorAll(".option"); 
nativeWidget.selectedIndex = index; 
value.innerHTML = optionList[index].innerHTML; 
highlightOption(select, optionList[index]); 
} 
function getIndex(select) { 
const nativeWidget = select.previousElementSibling; 
return nativeWidget.selectedIndex; 
} 
// ------------- // 
// 事件绑定 // 
// ------------- // 
window.addEventListener("load", () => { 
const form = document.querySelector("form"); 
form.classList.remove("no-widget"); 
form.classList.add("widget"); 
}); 
window.addEventListener("load", () => { 
const selectList = document.querySelectorAll(".select"); 
selectList.forEach((select) => { 
const optionList = select.querySelectorAll(".option"); 
optionList.forEach((option) => { 
option.addEventListener("mouseover", () => { 
highlightOption(select, option); 
}); 
}); 
select.addEventListener("click", (event) => { 
toggleOptList(select); 
}); 
select.addEventListener("focus", (event) => { 
activeSelect(select, selectList); 
}); 
select.addEventListener("blur", (event) => { 
deactivateSelect(select); 
}); 
}); 
}); 
window.addEventListener("load", () => { 
const selectList = document.querySelectorAll(".select"); 
selectList.forEach((select) => { 
const optionList = select.querySelectorAll(".option"); 
const selectedIndex = getIndex(select); 
select.tabIndex = 0; 
select.previousElementSibling.tabIndex = -1; 
updateValue(select, selectedIndex); 
optionList.forEach((option, index) => { 
option.addEventListener("click", (event) => { 
updateValue(select, index); 
}); 
}); 
select.addEventListener("keyup", (event) => { 
let index = getIndex(select); 
if (event.key === "Escape") { 
deactivateSelect(select); 
} 
if (event.key === "ArrowDown" && index < optionList.length - 1) { 
index++; 
} 
if (event.key === "ArrowUp" && index > 0) { 
index--; 
} 
updateValue(select, index); 
}); 
}); 
}); 
结果 
{{ EmbedLiveSample(‘改变状态’) }} 

这是解释如何构建自定义表单控件的最后一个示例。 
改变状态 
HTML 
<form class="no-widget"> 
<select name="myFruit"> 
<option>Cherry</option> 
<option>Lemon</option> 
<option>Banana</option> 
<option>Strawberry</option> 
<option>Apple</option> 
</select> 
<div class="select" role="listbox"> 
<span class="value">Cherry</span> 
<ul class="optList hidden" role="presentation"> 
<li class="option" role="option" aria-selected="true">Cherry</li> 
<li class="option" role="option">Lemon</li> 
<li class="option" role="option">Banana</li> 
<li class="option" role="option">Strawberry</li> 
<li class="option" role="option">Apple</li> 
</ul> 
</div> 
</form> 
CSS 
.widget select, 
.no-widget .select { 
position: absolute; 
left: -5000em; 
height: 0; 
overflow: hidden; 
} 
/*--------- */ 
/* 所需的样式 */ 
/* -------- */ 
.select { 
position: relative; 
display: inline-block; 
} 
.select.active, 
.select:focus { 
box-shadow: 0 0 3px 1px #227755; 
outline: none; 
} 
.select .optList { 
position: absolute; 
top: 100%; 
left: 0; 
} 
.select .optList.hidden { 
max-height: 0; 
visibility: hidden; 
} 
/* ------- */ 
/* 美化样式 */ 
/* ------- */ 
.select { 
font-size: 0.625em; /* 10px */ 
font-family: Verdana, Arial, sans-serif; 
box-sizing: border-box; 
padding: 0.1em 2.5em 0.2em 0.5em; /* 1px 25px 2px 5px */ 
width: 10em; /* 100px */ 
border: 0.2em solid #000; /* 2px */ 
border-radius: 0.4em; /* 4px */ 
box-shadow: 0 0.1em 0.2em rgba(0, 0, 0, 0.45); /* 0 1px 2px */ 
background: #f0f0f0; 
background: linear-gradient(0deg, #e3e3e3, #fcfcfc 50%, #f0f0f0); 
} 
.select .value { 
display: inline-block; 
width: 100%; 
overflow: hidden; 
white-space: nowrap; 
text-overflow: ellipsis; 
vertical-align: top; 
} 
.select::after { 
content: "▼"; 
position: absolute; 
z-index: 1; 
height: 100%; 
width: 2em; /* 20px */ 
top: 0; 
right: 0; 
padding-top: 0.1em; 
box-sizing: border-box; 
text-align: center; 
border-left: 0.2em solid #000; 
border-radius: 0 0.1em 0.1em 0; 
background-color: #000; 
color: #fff; 
} 
.select .optList { 
z-index: 2; 
list-style: none; 
margin: 0; 
padding: 0; 
background: #f0f0f0; 
border: 0.2em solid #000; 
border-top-width: 0.1em; 
border-radius: 0 0 0.4em 0.4em; 
box-shadow: 0 0.2em 0.4em rgba(0, 0, 0, 0.4); 
box-sizing: border-box; 
min-width: 100%; 
max-height: 10em; /* 100px */ 
overflow-y: auto; 
overflow-x: hidden; 
} 
.select .option { 
padding: 0.2em 0.3em; 
} 
.select .highlight { 
background: #000; 
color: #ffffff; 
} 
JavaScript 
// ------- // 
// 函数定义 // 
// ------- // 
function deactivateSelect(select) { 
if (! 
select.classList.contains("active")) return; 
const optList = select.querySelector(".optList"); 
optList.classList.add("hidden"); 
select.classList.remove("active"); 
} 
function activeSelect(select, selectList) { 
if (select.classList.contains("active")) return; 
selectList.forEach(deactivateSelect); 
select.classList.add("active"); 
} 
function toggleOptList(select, show) { 
const optList = select.querySelector(".optList"); 
optList.classList.toggle("hidden"); 
} 
function highlightOption(select, option) { 
const optionList = select.querySelectorAll(".option"); 
optionList.forEach((other) => { 
other.classList.remove("highlight"); 
}); 
option.classList.add("highlight"); 
} 
function updateValue(select, index) { 
const nativeWidget = select.previousElementSibling; 
const value = select.querySelector(".value"); 
const optionList = select.querySelectorAll(".option"); 
optionList.forEach((other) => { 
other.setAttribute("aria-selected", "false"); 
}); 
optionList[index].setAttribute("aria-selected", "true"); 
nativeWidget.selectedIndex = index; 
value.innerHTML = optionList[index].innerHTML; 
highlightOption(select, optionList[index]); 
} 
function getIndex(select) { 
const nativeWidget = select.previousElementSibling; 
return nativeWidget.selectedIndex; 
} 
// ------------- // 
// 事件绑定 // 
// ------------- // 
window.addEventListener("load", () => { 
const form = document.querySelector("form"); 
form.classList.remove("no-widget"); 
form.classList.add("widget"); 
}); 
window.addEventListener("load", () => { 
const selectList = document.querySelectorAll(".select"); 
selectList.forEach((select) => { 
const optionList = select.querySelectorAll(".option"); 
const selectedIndex = getIndex(select); 
select.tabIndex = 0; 
select.previousElementSibling.tabIndex = -1; 
updateValue(select, selectedIndex); 
optionList.forEach((option, index) => { 
option.addEventListener("mouseover", () => { 
highlightOption(select, option); 
}); 
option.addEventListener("click", (event) => { 
updateValue(select, index); 
}); 
}); 
select.addEventListener("click", (event) => { 
toggleOptList(select); 
}); 
select.addEventListener("focus", (event) => { 
activeSelect(select, selectList); 
}); 
select.addEventListener("blur", (event) => { 
deactivateSelect(select); 
}); 
select.addEventListener("keyup", (event) => { 
let index = getIndex(select); 
if (event.key === "Escape") { 
deactivateSelect(select); 
} 
if (event.key === "ArrowDown" && index < optionList.length - 1) { 
index++; 
} 
if (event.key === "ArrowUp" && index > 0) { 
index--; 
} 
updateValue(select, index); 
}); 
}); 
}); 
结果 
{{ EmbedLiveSample(‘改变状态’) }} 

{{LearnSidebar}} 
在许多情况下，可用的原生 HTML 表单控件是不够的。 
如果要在某些控件（例如 {{HTMLElement(“select”)}} 元素）上设置高级样式，或者如果要提供自定义行为，你就需要考虑构建自己的控件。 
在本文中，我们会看到如何构建自定义控件。 
为此，我们将使用这样一个示例：重建 {{HTMLElement(“select”)}} 元素。 
我们还将讨论如何构建、何时构建自定义控件、构建是否存在意义，以及构建控件的相关注意事项。 
备注： 我们将专注于构建控件，而不是怎样让代码更通用或可复用；那会涉及一些非基础的 JavaScript 代码和未知上下文下的 DOM 操作，这超过了这篇文章的范畴。 
设计、结构和语义 
在构建一个自定义控件之前，首先你要确切的知道你要什么。 
这将为你节省宝贵的时间。 
特别地，清楚地定义控件的所有状态非常重要。 
要做到这一点，从状态和行为表现都为人所熟知的现有控件开始是很好的选择，这样你可以充分地模仿这些控件。 
在我们的示例中，我们将重建 {{HTMLElement(“select”)}} 元素，这是我们希望实现的结果： 
选择框的三种状态 
用户按下 tab 键使控件获得了焦点。 
当鼠标悬停在某个选项上时，该选项将被突出显示，并且之前突出显示的选项将返回其正常的状态 
在团队环境中尤其是这样，因为设计控件行为的人与实现的人通常是不同的。 
在我们的示例中，规范的缺失是显而易见的，所以我们将着手处理它们，但是对于一些没有人想到去定义正确行为的控件而言，这的确是一个问题。 
设计新的交互方式只是行业中重要参与者的一种选择，他们有足够的影响力来推动他们创建的交互方式成为标准。 
他们拥有足够的市场份额，而成功推出了一种全新的设备交互方式，这是大多数设备公司无法做到的。 
最好不要发明新的用户交互方式。 
定义语义化的 HTML 结构 
第一步就是去确定它的 HTML 结构并给予一些基本的语义规则。 



{{LearnSidebar}} 
所有 web 开发者很快就会（有时候是痛苦地）发现 Web 是一个令人不快的地方。 
我们碰到的最恶毒的诅咒是旧式浏览器。 
好吧，让我们承认吧，当我们提到“旧式浏览器”时，脑海中出现就是 Safari 和 Internet Explorer……但是，这远远不是全部。 那么，在移动世界呢？ 
当浏览器和 OS（操作系统）都不能更新时？ 是的，有非常多老版本的 Android 手机或 iPhone 没有更新到最新的浏览器。 它们同样是旧式浏览器。 
可悲的是，处理这些传统浏览器的问题是工作的一部分。 
幸运的是，有一些技巧可以帮助你解决旧式浏览器导致的大多数问题。 
如果浏览器不支持某种 HTML {{htmlelement(‘input’)}} 类型，它不会停止工作，而只是回退为默认的 type=text 类型。 
了解这些问题 
实际上，最重要的事情是阅读那些浏览器的文档，并尝试理解通用的（解决）模式。 
如果你在 MDN 上阅读了本篇文档，这将是个良好的开始，只需要检查你想用的元素或 DOM 接口的支持情况即可。 
对于大部分 HTML 中可用的元素、属性或 API，MDN 提供了兼容性表格以供查询。 
由于 HTML 表单包含了复杂的交互，有一个非常重要的规则：保持简单化，也常称做“KISS 原则”。 
有很多情况下，我们希望表单“更漂亮”或“具有高级功能”，但构建高效的 HTML 表单并不是一个设计或技术问题，而是一个简单直观且便利的用户互动问题。 
记得花时间读一下这篇文章 forms usability on UX For The Masses。 
优雅降级 (Graceful degradation) 是 web 开发者最好的朋友 
优雅降级和渐进增强是一种开发模式，它允许你通过同时支持多种浏览器来构建优秀内容。 
当你为现代浏览器构建内容时，你想确保它能在旧式浏览器中以某种方式工作，这就是优雅降级（graceful degradation）。 
让我们看一些关于 HTML 表单的例子： 
HTML input 类型 
HTML5 引入的新 input 类型十分酷，因为他们的降级 (degrade) 是高度可预测的。 
如果一个浏览器不能理解 {{HTMLElement(“input”)}}元素的 type 属性，它将会后退到text一样的行为。 
<label for="myColor"> 
Pick a color 
<input type="color" id="myColor" name="color" /> 
</label> 
支持 
不受支持 
表单按钮 
有两种在 HTML 表单中定义按钮的方式： 
type 属性值为 button、submit、reset 或 image 的 {{HTMLElement(“input”)}} 元素 
{{HTMLElement(“button”)}} 元素 
{{HTMLElement(“input”)}} 
{{HTMLElement(“input”)}} 元素可能使得通过元素选择器应用 CSS 变得有些困难： 
<input type="button" value="click me" /> 
如果我们把所有 input 的外框移除，我们能否只恢复 input 按钮的默认外观？ 
input { 
/* 这条规则关闭了含有外边框的 input 类型的默认渲染效果，包括了使用 input 元素定义的按钮 */ 
border: 1px solid #ccc; 
} 
input[type="button"] { 
/* 这条规则并不能恢复默认渲染行为！ */ 
border: none; 
} 
input[type="button"] { 
/* 这条也不行！ 
实际上在任何浏览器上都没有标准的方案 */ 
border: auto; 
border: initial; 
} 
input[type="button"] { 
/* 这条是恢复默认渲染最接近的答案，只要浏览器支持就可以这么做 */ 
border: revert; 
} 
请查看全局的 CSS {{cssxref(‘revert’)}} 值以获得更多信息。 
{{HTMLElement(“button”)}} 
{{HTMLElement(“button”)}} 元素曾经受到两个问题的影响，现在已经得到解决： 
在旧版本的 Internet Explorer 中，存在一个错误，当点击 {{HTMLElement(“button”)}} 元素时，会发送该元素开始和结束标签之间的 HTML 内容，而不是 value 属性中的值。 
仅在需要发送该值时才会出现问题，例如当数据处理取决于用户点击的按钮时。 
某些非常旧的浏览器不使用 submit 作为 type 属性的默认值。 
即使在现代浏览器中得到了解决，也推荐总是设置 {{HTMLElement(“button”)}} 元素的 type 属性。 
<!-- 某些情形下，点击按钮将发送 "<em>Do A</em>" 而不是值"A" --> 
<button type="submit" name="IWantTo" value="A"> 
<em>Do A</em> 
</button> 
选择哪种解决方案由项目的限制条件决定。 
摆脱 CSS 
HTML 表单的一个大问题是用 CSS 对表单小部件进行样式化。 
表单控件的外观是针对浏览器和操作系统的。 
例如，颜色类型的输入在 Safari、Chrome 和 Firefox 浏览器中看起来是不同的，但颜色选择器小部件在设备上的所有浏览器中都是一样的，因为它打开了操作系统的本地颜色选择器。 
不改变表单控件的默认外观往往是个好主意，因为改变某个 CSS 属性值可以改变一些 input 类型，却不能改变另一些类型。 
例如，如果你声明了 input { font-size: 2rem; }，它会影响到 number、date 和 text，却不会影响 color 和 range。 
如果你改变了一个属性，会在不可预知的情况下影响到组件的外观。 
例如，[value] { background-color: #ccc; } 可能会用于改变所有含有 value 属性的 {{HTMLElement(“input”)}} 元素，但改变 {{HTMLElement(“meter”)}} 的 border radius 值可能会在不同浏览器中引起无法预期的显示。 
你可以声明 {{cssxref(‘appearance’, ‘appearance: none;’)}} 来移除浏览器默认样式，但这通常会违背目的：因为你失去了所有的样式，删除了你的访问者所习惯的默认外观和感受。 
总而言之，当涉及到表单控件小部件的样式时，用 CSS 为它们设计样式的副作用可能是不可预测的。 
所以不要这样做。 
正如从这篇表单控件的 CSS 属性兼容性表格中所看到的复杂性那样，它非常的困难。 
即使仍然可以对文本元素（如大小、字体颜色等）进行一些调整，但那样做会有副作用。 
最好的办法还是不要美化 HTML 表单小组件。 
但你仍然可以将样式应用到表单周围的项目上。 
如果你是一个专业人士，并且你的客户需要那么做，在这种情况下，你可以研究一些硬技能，如使用 JavaScript 重建组件。 
但在那种情况下，最好还是毫不犹豫的让客户收回这些愚蠢的决定。 
特性检测和 polyfill 
CSS 和 JavaScript 是了不起的技术，但重要的是确保不会破坏传统的浏览器。 
在使用你的目标浏览器不完全支持的特性之前，你应该进行特性检测。 
CSS 特性检测 
在设计一个表单控件的样式之前，你可以使用 {{cssxref(‘@supports’)}} 检查一下浏览器是否支持你打算使用的特性： 
@supports (appearance: none) { 
input[type="search"] { 
appearance: none; 
/* 重新为 search input 添加样式 */ 
} 
} 
{{cssxref(‘appearance’)}} 属性可用于以平台原生的方式显示元素的样式，如果指定为 none，则移除默认基于不同平台的样式。 
非侵入式 JavaScript 
API 的兼容性是最大的问题。 
由于这个原因，与“非侵入式（unobtrusive）”JavaScript 一起工作被认为是最佳实践（译者注：此处意思是说没有或忽略 JavaScript 或 JavaScript 出了问题也能工作）。 
这个开发模式定义了两个需求： 
结构和行为之间的严格隔离 
如果代码出错，内容和基本功能必须保持可访问和可用状态 
The principles of unobtrusive JavaScript（最早是由 Peter-Paul Koch 为 Dev.Opera.com 所撰写）这篇文章同样阐述了上述观点。 
Modernizr 库 
有很多情形，好的”polyfill“能通过提供缺少的 API 以提供帮助。 一个 polyfill 是一些用于填补旧式浏览器中缺失功能的 JavaScript 脚本。 
虽然它们可以用来改善对任何功能的支持，但对 JavaScript 使用它们比对 CSS 或 HTML 使用风险要小；有很多情况下 JavaScript 会崩溃（网络问题、脚本冲突等）。 
但是对于 JavaScript 来说，如果你在工作中考虑到非侵入式 JavaScript，如果 polyfill 缺失，那也没什么大不了的。 
最好的 polyfill 缺失 API 的方式是使用 Modernizr 库以及它的子项目 YepNope。 
Modernizr 库允许你测试功能可用性，以便采取相应的行动。 
下面是一个例子： Modernizr.load({ // 这会测试你的浏览器是否支持 HTML5 表单验证 API 
test: Modernizr.formvalidation, // 如果浏览器不支持它，则会加载以下 polyfill 
app.init(); 
Modernizr 团队按照惯例维护着一个优秀的 polyfill 列表，按需使用即可。 
备注： Modernizr 还有其他很棒的功能可以帮助你处理非侵入式 JavaScript 和优雅降级的技术。 
请阅读 Modernizr 文档。 注意性能 
尽管像 Modernizr 这样的脚本非常注重性能，但加载 200 KB 的 polyfill 仍然会影响你的应用程序的性能。 
这对旧式浏览器来说尤其重要，这些浏览器的 JavaScript 引擎处理速度很慢，让 polyfills 的执行对于用户来说变得很痛苦。 
性能本身就是一个主题，但旧式浏览器对它非常敏感：基本上，它们速度慢，需要的 polyfill 越多，它们需要处理的 JavaScript 越多。 
与现代浏览器相比，它们承受双重负担。 
使用旧版浏览器测试你的代码，了解它们的实际表现。 
有时，放弃某些功能会带来更好的用户体验，而不是在所有浏览器中具有完全相同的功能。 
作为最后提醒，总是优先考虑用户。 
总结 
如果你阅读了 HTML 表单指南中的所有文章，你应该可以放心的使用表单了。 
如果你想探索新技术，请帮助我们提升指南的写作水平。 
进阶内容 
通过 JavaScript 发送表单 
如何构建自定义表单控件 
旧版浏览器中的 HTML 表单 
高级表单样式 
表单控件的属性兼容性列表 

{{LearnSidebar}} 
这个模块提供了一系列帮助你掌握 web 表单的文章。 
web 表单是与用户交互的强大工具，它们经常用于收集用户的数据，或允许他们控制用户界面。 
然而，由于历史和技术上的原因，如何充分发挥它们的潜力并不总是显而易见的。 
在下方列出的文章中，我们将介绍 Web 表单的各个方面：HTML 结构、样式、验证表单数据，以及提交数据到服务器。 
标注： 
想成为一名前端网页开发者？ 
我们整理了一个课程，其中包含你实现目标所需的所有基本内容。 
开始使用 
在开始这个模块之前，你至少应该熟悉对 HTML 的介绍系列。 
此时此刻，你应该会发现基本指南很容易理解，并且能够使用我们的原生表单控件指南。 
然而，掌握表单需要的不仅仅是 HTML 知识——你还需要学习一些特定的技术来设置表单控件的样式，并且需要一些编码知识来处理诸如验证和创建自定义表单控件之类的事情。 
因此，在你查看下面列出的其他部分之前，我们建议你先离开，并学习一些 CSS 和 JavaScript。 
以上内容明确地说明了为什么我们将 web 表单独立放在一个模块中，而不是将其与 HTML、CSS 和 JavaScript 这些模块放在一起——表单元素比绝大多数其他的 HTML 元素都要复杂，并且它们还需要与相关的 CSS 和 JavaScript 技术紧密集合才能充分利用它们。 
备注： 如果你正在使用一个无法创建自己的文件的计算机、平板电脑或其他设备，那么你可以尝试（大多数）在线编码程序中的代码示例，例如 JSBin 或 Glitch。 
基本指南 
你的第一个表单 
: 本系列的第一篇文章提供了第一次创建 HTML 表单的经验，包括设计一个简单表单、使用正确的 HTML 元素实现它、通过 CSS 添加一些非常简单的样式，以及如何将数据发送到服务器。 
如何构造 HTML 表单 
: 有了基础知识，我们现在更详细地了解了用于为表单的不同部分提供结构和意义的元素。 
不同的表单控件 
原生表单控件 
: 我们从详细了解原始 HTML {{htmlelement(“input”)}} 元素的类型开始，同时学习在收集不同类型数据时可用的选择。 
HTML5 input 的类型 
: 在这里，我们深入挖掘 <input> 元素，了解 HTML5 发布时提供的其他 input 类型，以及它们提供的各种 UI 弓箭和数据收集增强功能。 
此外，我们可以了解 {{htmlelement(‘output’)}} 元素。 
其他表单控件 
: 接下来，我们学习所有非 <input> 表单控件，以及相关的工具，如：{{htmlelement(‘select’)}}、{{htmlelement(‘textarea’)}}、{{htmlelement(‘meter’)}} 和 {{htmlelement(‘progress’)}}。 
表单样式指南 
HTML 表单样式 
: 本文介绍了如何使用 CSS 为表单赋予样式，包括可能需要了解的基本样式任务的所有基础知识。 
高级表单样式 
: 在这里，我们将看到一些更高级的表单样式技术，这些技术需要在处理一些更难以设置样式的元素时使用。 
UI 伪类 
: 这是一篇对 UI 伪类的介绍，使 HTML 表单控件能够根据当前状态进行定位。 
验证和提交表单数据 
客户端表单验证 
: 仅仅发送数据还不够——我们还需要确保用户填写表单的数据格式是正确的，以在后续流程中正确处理它，而且它不会破坏我们的应用程序。 
我们还希望帮助用户正确填写表单，让他们在使用应用程序时不会感到困扰。 
表单验证可以帮助我们实现这些目标，本文将告诉你需要了解的内容。 
发送表单数据 
: 本文讨论当用户提交一个表单时，会发生什么情况——表单数据的去向，以及当表单数据到达指定位置时我们如何处理？ 
我们还研究了与发送表单数据相关的一些安全问题。 
高级指南 
通过 JavaScript 发送表单 : 本文将讨论如何使用表单来构建 HTTP 请求，并通过定制的 JavaScript 发送它，而不是标准的表单提交。 
表单控件的 CSS 属性兼容性表 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/Forms/HTML5_input_types”,“Learn/Forms/Styling_web_forms”, “Learn/Forms”)}} 
现在我们来具体看看非 <input> 表单控件的功能，从下拉列表菜单（drop-down list）、多行文本域（multi-line text field）到其他有用的表单功能，如我们在前一篇文章看到的 {{htmlelement(‘output’)}} 元素和进度条（progress bar）元素。 
前提： 
计算机基础知识和对于 HTML 的基本理解。 





{{LearnSidebar}}{{PreviousMenuNext(“Learn/Forms/Advanced_form_styling”, “Learn/Forms/Form_validation”, “Learn/Forms”)}} 
在以前的文章中，我们以一般的方式介绍了各种表单控件的样式。 
这包括一些伪类的使用，例如，使用 :checked 来选择一个选中的复选框。 
在这篇文章中，我们将详细探讨在现代浏览器中可用的不同 UI 伪类，以便在不同状态下对表单添加样式。 
前提： 
基本的计算机知识，对 HTML 和 CSS 的基本了解，包括对伪类和伪元素的基本认识。 


{{LearnSidebar}} 
欢迎阅读我们的 Web 前端开发者学习路线图！ 
该路线图提供一个结构化的课程，教会你成为一名 Web 前端开发所需要了解的一切。 
通过学习每个章节，获得新技能（或者提升原有的技能）。 
每个章节都包括练习和评估，让你能够继续之前测试你对章节内容的理解。 
涵盖的主题 
该路线图涵盖的主题大致范围如下： 
基础准备以及如何学习 
Web 标准和最佳实践 (例如辅助功能和跨浏览器兼容) 
HTML，一门赋予网站内容结构和意义的语言 
CSS，一门美化网站页面的语言 
JavaScript，用来为网站创建动态功能的脚本语言 
一些有助于现代化客户端 Web 开发的工具 
这些章节是按照学习顺序而进行设计的，但每个章节又自成一体。 
例如，如果你已经对 HTML 非常熟悉了，你大可放心地跳过这个章节直接学习 CSS 部分。 
预备知识 
你并不需要任何预备知识以开始这一章节，你仅需要一台可以运行现代浏览器并且联网的电脑和一颗好学之心。 
如果你不确定 Web 前端是否适合自己，或是想在开始一个更长、更完整的课程之前先对其有一个更通识的了解，可以先阅读 Web 入门章节。 
获得帮助 
我们尽量让 Web 前端开发学习尽可能的轻松，但是你仍可能因为一些难以理解的点、或某段无法像预期中的那样工作的代码等原因而止步不前。 
无论是新手还是富有经验的开发者都经常遇到困难，但是不要慌。“ 
如何学习”章节提供了一些实用的有关如何查找信息和自行解决问题的提示，如果仍然上述提示仍然无法解决你的问题，大胆的在讨论区提出你的问题。 
学习路线图 
起步 
学习用时：1–2 小时 
预备知识 
仅需基础的计算机知识。 
我怎么知道自己是否可以继续往下学习了？ 
本章节没有评估测试，但是请不要跳过它 — 这对于帮你准备好应对后面的练习和学习非常重要。 
核心提示 
安装基础软件 (15 分钟) (15 分钟) 
Web 和 Web 标准的背景介绍 (45 分钟) 
学习和获得帮助 (45 分钟) 
HTML 语义和结构 
学习用时：35–50 小时 
预备知识 
基础的计算机知识和基本的 Web 开发环境。 
我怎么知道自己是否可以继续往下学习了？ 
每个模块的评估练习都是针对测试你主题相关知识掌握能力设计的，完成了每个练习就表示你可以继续往后学习下一个模块了。 
核心模块 
HTML 介绍 (15–20 小时阅读/练习) 
多媒体与嵌入 (15–20 小时阅读/练习) 
HTML 表格 (5–10 小时阅读/练习) 
使用 CSS 布局和美化 
学习用时：90–120 小时 
预备知识 
学习 CSS 前需要有基础的 HTML 知识，请至少学习完 HTML 介绍再开始。 
我怎么知道自己是否可以继续往下学习了？ 
每个模块的评估练习都是针对测试你主题相关知识掌握能力设计的，完成了每个练习就表示你可以继续往后学习下一个模块了。 
核心模块 
学习 CSS 的第一步 (10–15 小时阅读/练习) 
编写 CSS (35–45 小时阅读/练习) 
添加文本样式 (15–20 小时阅读/练习) 
CSS 布局 (30–40 小时阅读/练习) 
额外资源 
CSS 布局 cookbook 
使用 JavaScript 开发交互 
学习用时：135–185 小时 
预备知识 
学习 JavaScript 前需要有基础的 HTML 知识，请至少学习完 HTML 介绍再开始。 
我怎么知道自己是否可以继续往下学习了？ 
每个模块的评估练习都是针对测试你主题相关知识掌握能力设计的，完成了每个练习就表示你可以继续往后学习下一个模块了。 
核心模块 
JavaScript 第一步 (30–40 小时阅读/练习) 
编写 JavaScript (25–35 小时阅读/练习) 
客户端 Web API (30–40 小时阅读/练习) 
JavaScript 对象入门 (25–35 小时阅读/练习) 
异步 JavaScript (25–35 小时阅读/练习) 
Web 表单 — 处理用户数据 
学习用时：40–50 小时 
预备知识 
高效使用 Web 表单需要 HTML、CSS 和 JavaScript 知识。 
鉴于与表单打交道的复杂性，这一节被独立了出来。 
我怎么知道自己是否可以继续往下学习了？ 
每个模块的评估练习都是针对测试你主题相关知识掌握能力设计的，完成了每个练习就表示你可以继续往后学习下一个模块了。 
核心模块 
Web 表单 (40–50 小时) 
让所有人都能使用 Web 
学习用时：45-55 小时 
预备知识 
学习本章前最好对 HTML、CSS 和 JavaScript 都有一定了解— 本章很多技术和最佳实践都需要用到它们。 
我怎么知道自己是否可以继续往下学习了？ 
每个模块的评估练习都是针对测试你主题相关知识掌握能力设计的，完成了每个练习就表示你可以继续往后学习下一个模块了。 
核心模块 
跨浏览器测试 (25–30 小时阅读/练习) 
无障碍（辅助功能） (20–25 小时阅读/练习) 
现代工具 
学习用时：55–90 小时 
预备知识 
学习本章前最好对 HTML、CSS 和 JavaScript 都有一定了解— 本章很多技术和最佳实践都需要用到它们。 
我怎么知道自己是否可以继续往下学习了？ 
本章节各模块均没有评估测试，但是第 2 章和第 3 章的学习教程应该能够让你很好的掌握现代工具的要义。 
核心模块 
Git 和 GitHub (5 hour read) 
客户端 Web 开发工具入门 (20–25 hour read) 
客户端 JavaScript 开发框架入门 (30-60 hour read/exercises) 

{{PreviousMenuNext(“Learn/Getting_started_with_the_web/HTML_basics”, “Learn/Getting_started_with_the_web/JavaScript_basics”, “Learn/Getting_started_with_the_web”)}} 
CSS（Cascading Style Sheets，层叠样式表）是为 web 内容添加样式的代码。 
本节将介绍 CSS 的基础知识，并解答像这样的问题：怎样将文本设置为红色？ 
怎样将内容显示在屏幕的特定位置？ 
怎样用背景图片或颜色来装饰网页？ 
什么是 CSS？ 
和 HTML 类似，CSS 也不是真正的编程语言，甚至不是标记语言。 
CSS 是一门样式表语言，这也就是说人们可以用它来选择性地为 HTML 元素添加样式。 
举例来说，以下 CSS 代码选择了所有的段落文字，并将它们设置为红色。 
p { 
color: red; 
} 
让我们来试一试！ 
在文本编辑器中，将上述的三行 CSS 代码粘贴到一个新的文件中，将文件命名为 style.css 并保存到 styles 文件夹下。 
为了使代码发挥作用，我们仍然需要将上述 CSS 样式应用到你的 HTML 文档中。 
否则，这些样式不会改变 HTML 的外观。（ 
如果你没有完成前几节的实践，请复习处理文件和 HTML 基础。） 
打开 index.html 文件，然后将下面一行粘贴到文档头部（也就是 {{HTMLElement(“head”)}} 和 </head> 标签之间）。 
<link href="styles/style.css" rel="stylesheet" /> 
保存 index.html 并用浏览器将其打开。 
应该看到以下页面： 
如果段落文字变红，那么祝贺你，CSS 样式已经生效了。 
“CSS 规则集”详解 
让我们来剖析一下红色段落文字的 CSS 代码，了解它是如何工作的： 
CSS p 声明，其中 color 为 red 
整个结构称为规则集（规则集通常简称规则），注意各个部分的名称： 
选择器（Selector） 
: HTML 元素的名称位于规则集开始。 
它选择了一个或多个需要添加样式的元素（在这个例子中就是 {{HTMLElement(“p”)}} 元素）。 
要给不同元素添加样式，只需要更改选择器。 
声明（Declaration） 
: 一个单独的规则，如 color: red; 用来指定添加样式元素的属性。 
属性（Properties） 
: 改变 HTML 元素样式的途径（本例中 color 就是 {{htmlelement(“p”)}} 元素的属性）。 
CSS 中，由编写人员决定修改哪个属性以改变规则。 
属性的值（Property value） 
: 在属性的右边，冒号后面即属性的值，它从指定属性的众多外观中选择一个值（我们除了 red 之外还有很多属性值可以用于 color ）。 
注意其他重要的语法： 
除了选择器部分，每个规则集都应该包含在成对的大括号里（{}）。 
在每个声明里要用冒号（:）将属性与属性值分隔开。 
在每个规则集里要用分号（;）将各个声明分隔开。 
如果要同时修改多个属性，只需要将它们用分号隔开，就像这样： 
p { 
color: red; 
width: 500px; 
border: 1px solid black; 
} 
选择多个元素 
也可以选择多种类型的元素并为它们添加一组相同的样式。 
将不同的选择器用逗号分开。 
例如： 
p, 
li, 
h1 { 
color: red; 
} 
不同类型的选择器 
选择器有许多不同的类型。 
上面只介绍了元素选择器，用来选择 HTML 文档中给定的元素。 
但是选择操作可以更加具体。 
下面是一些常用的选择器类型： 
选择器名称 
选择的内容 
示例 
元素选择器（也称作标签或类型选择器） 
所有指定类型的 HTML 元素 
p 
选择 <p> 
ID 选择器 
具有特定 ID 的元素。 
单一 HTML 页面中，每个 ID 只对应一个元素，一个元素只对应一个 ID 
#my-id 
选择 <p id=“my-id”> 或 <a id=“my-id”> 
类选择器 
具有特定类的元素。 
单一页面中，一个类可以有多个实例 
.my-class 
选择 <p class=“my-class”> 和 <a class=“my-class”> 
属性选择器 
拥有特定属性的元素 
img[src] 
选择 <img src=“myimage.png”> 但不是 <img> 
伪类选择器 
特定状态下的特定元素（比如鼠标指针悬停于链接之上） 
a:hover 
选择仅在鼠标指针悬停在链接上时的 <a> 元素 
选择器的种类远不止于此，更多信息请参阅 MDN 的选择器指南。 
字体和文本 
在探索了一些 CSS 基础后，我们来把更多规则和信息添加至 style.css 中，从而让示例更美观。 
第一步，找到之前在你的网站会是什么样子？ 中保存的 Google Font 输出的地址。 
并以 {{htmlelement(“link”)}} 元素的形式添加进 index.html 文档头部（ {{HTMLElement(“head”)}} 和 </head> 之间的任意位置）。 
代码如下： 
<link 
href="https://fonts.googleapis.com/css? 
family=Open+Sans" 
rel="stylesheet" /> 
这段代码将你的页面链接到一个样式表，该样式表将 Open Sans 字体家族与你的网页一起加载。 
接下来，删除 style.css 文件中已有的规则。 
虽然测试是成功的，但是红字看起来并不太舒服。 
添加以下几行（如下图所示），用你在你的网站会是什么样子？ 
中选择的 font-family 替换 font-family。 
font-family 属性指的是你想用于文本的字体。 
由于 {{HTMLElement(“html”)}} 是整个页面的父元素，它里面的所有元素都继承相同的 font-size 和 font-family。 
html { 
font-size: 10px; /* px 表示“像素（pixel）”: 基础字号为 10 像素 */ 
font-family: "Open Sans", sans-serif; /* 这应该是你从 Google Fonts 得到的其余输出。 */ 
} 
备注： CSS 文档中所有位于 /* 和 */ 之间的内容都是 CSS 注释。 
浏览器在渲染代码时会忽略注释。 
CSS 注释是一种让你写下关于你的代码或逻辑的有用注解的方式。 
接下来为 HTML 主体内的元素（{{htmlelement(“Heading_Elements”, “h1”)}}、{{htmlelement(“li”)}} 和 {{htmlelement(“p”)}}）设置字体大小。 
我们也将标题居中显示。 
最后，扩充下方的第二个规则集，为正文设置行高和字间距，从而提高页面的可读性。 
h1 { 
font-size: 60px; 
text-align: center; 
} 
p, 
li { 
font-size: 16px; 
line-height: 2; 
letter-spacing: 1px; 
} 
可以随时调整这些 px 值来获得满意的结果，以下是大体效果： 
一个 Mozilla 徽标和一些段落，设置了 sans-serif 字体，字体大小、行高和字间距已经调整，主页的标题已经居中 
CSS：一切皆盒子 
编写 CSS 时你会发现，你的工作好像是围绕着一个一个盒子展开的——设置尺寸、颜色、位置，等等。 
页面里大部分 HTML 元素都可以被看作若干层叠的盒子。 
一大堆箱子堆在一起 
照片来自 https://www.geograph.org.uk/photo/3418115 ，Jim Barton cc-by-sa/2.0 版权所有 
CSS 布局主要是基于盒子模型。 在你的页面上占用空间的每个盒子都有类似的属性： 
padding（内边距）：是指内容周围的空间。 
在下面的例子中，它是段落文本周围的空间。 
border（边框）：是紧接着内边距的线。 
margin（外边距）：是围绕元素边界外侧的空间。 
有三个彼此包含的盒子。 
从外到内，它们被标记为 margin、border 和 padding 
这里还使用了： 
width：元素的宽度 
background-color：元素内容和内边距底下的颜色 
color：元素内容（通常是文本）的颜色 
text-shadow：为元素内的文本设置阴影 
display：设置元素的显示模式（继续阅读文章以了解更多细节） 
开始在页面中添加更多 CSS 吧！ 
大胆将这些新规则都添加到 style.css 的底部，而不要纠结改变属性值会带来什么结果。 
更改页面颜色 
html { 
background-color: #00539f; 
} 
这条规则为整个页面设置了背景颜色。 
将颜色代码修改为设置为在“我的网站将会是什么样子？” 
body { 
width: 600px; 
margin: 0 auto; 
background-color: #ff9500; 
padding: 0 20px 20px 20px; 
border: 5px solid black; 
} 
这里有对于 {{htmlelement(“body”)}} 元素的几条声明，我们来逐条查看： 
width: 600px; 强制页面永远保持 600 像素宽。 
margin: 0 auto; 当你在 margin 或 padding 这样的属性上设置两个值时，第一个值影响元素的上下方向（在这个例子中设置为 0）；第二个值影响左右方向。( 
这里，auto 是一个特殊的值，它将可用的水平空间平均分配给左和右）。 
如 Margin 语法中所记载的那样，你也可以使用一个、两个、三个或四个值。 
background-color: #FF9500; 如前文所述，指定元素的背景颜色。 
我们给 body 用了一种略微偏红的橘色以与深蓝色的 {{htmlelement(“html”)}} 元素形成反差，你也可以尝试其他颜色。 
padding: 0 20px 20px 20px; 我们给内边距设置了四个值来让内容四周产生一点空间。 
这一次我们不设置上方的内边距，设置右边，下方，左边的内边距为 20 像素。 
值以上、右、下、左的顺序排列。 
与 margin 一样，你也可以像 Padding 语法中所记载的那样，使用一个、两个、三个或四个值。 
border: 5px solid black; 这是为边框的宽度、样式和颜色设置的值。 
在本例中，它是一个在主体的所有侧面的 5 像素宽的纯黑色边框。 
定位页面主标题并添加样式 
h1 { 
margin: 0; 
padding: 20px 0; 
color: #00539f; 
text-shadow: 3px 3px 1px black; 
} 
你可能已经注意到，在正文的顶部有一个难看的间隙。 
这是因为浏览器对 {{htmlelement(“Heading_Elements”, “h1”)}} 元素（以及其他元素）应用了默认样式。 
这可能看起来是个坏主意，但其目的是为没有样式的页面提供基本的可读性。 
为了消除这种间隙，我们用设置 margin: 0; 来覆盖浏览器的默认样式。 
接下来，我们将标题的顶部和底部内边距设置为 20 像素。 
之后，我们将标题文本设置为与 HTML 背景颜色相同的颜色。 
最后，text-shadow 对元素的文本内容施加阴影。 
它的四个值是： 
第一个像素值设置阴影与文本的水平偏移量：它横移的距离。 
第二个像素值设置阴影与文本的垂直偏移量：它向下移动的距离。 
第三个像素值设置阴影的模糊半径。 
一个更大的值会产生一个更模糊的阴影。 
第四个值设置阴影的基色。 
试着用不同的值进行试验，看看它是如何改变外观的。 
图像居中 
img { 
display: block; 
margin: 0 auto; 
} 
最后，我们把图像居中来使页面更美观。 
可以复用 body 的 margin: 0 auto，但有一些差异，需要额外的设置来使 CSS 发挥作用。 
{{htmlelement(“body”)}} 元素是块级元素，意味着它占据了页面的空间并且能够赋予外边距和其他改变间距的值。 
而图片是行级元素，不具备块级元素的一些功能。 
所以为了使图像有外边距，我们必须使用 display: block 给予其块级行为。 
备注： 以上说明假定所选图片小于页面宽度（600 像素）。 更大的图片会溢出 body 并占据页面的其他位置。 
要解决这个问题，可以： 1）使用图片编辑器 来减小图片宽度； 2）用 CSS 限制图片大小，即减小 <img> 元素 {{cssxref(“width”)}} 属性的值。 
备注： 如果你暂时不能理解 display: block 和块级元素与行级元素的差别也没关系；随着你对 CSS 学习的深入，你将明白这个问题。 
display 属性的更多信息请查看 display 属性参考页面。 
总结 
如果你按部就班完成本文的实践，那么最终可以得到以下页面： 
一个居中的 Mozilla 的标志，还有一个页眉和段落。 
现在它看起来很有风格，整个页面的背景是蓝色的，居中的主要内容条是橙色的背景 
（你可以在这里查看我们的版本。） 
若遇到问题，可以参考 GitHub 上的完整示例代码做对比。 
本章介绍的 CSS 知识非常有限，更多内容请访问学习使用 CSS 为 HTML 添加样式。 
{{PreviousMenuNext(“Learn/Getting_started_with_the_web/HTML_basics”, “Learn/Getting_started_with_the_web/JavaScript_basics”, “Learn/Getting_started_with_the_web”)}} 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/Getting_started_with_the_web/What_will_your_website_look_like”, “Learn/Getting_started_with_the_web/HTML_basics”, “Learn/Getting_started_with_the_web”)}} 
在你选择的地方，创建一个名为 web-projects（或类似）的新文件夹。 
许多计算机，特别是网络服务器，是区分大小写的。 因此，假如你把一张图片放在你的网站上 test-site/MyImage.jpg，然后在一个不同的文件中，你试图以 test-site/myimage.jpg 来调用该图片，它可能无法工作。 浏览器、网络服务器和编程语言对空格的处理并不一致。 
对比 my-file.html 与 my_file.html。 
现在让我们来创建这些： index.html：这个文件一般会包含主页内容，也就是人们第一次进入网站时看到的文字和图片。 
使用文本编辑器，创建一个名为index.html的新文件，并将其保存在test-site文件夹内。 images 文件夹：这个文件夹包含网站上使用的所有图片。 
在 test-site 文件夹内创建一个名为 images 的文件夹。 
在你的 test-site 文件夹内创建一个名为 styles 的文件夹。 
在 test-site 文件夹内创建一个名为 scripts 的文件夹。 
<meta charset="utf-8" /> <meta name="viewport" content="width=device-width" /> 
<title>My test page</title> </head> <body> 
<img src="" alt="My test image" /> 
你应该看到新网页显示了新的图像！ A screenshot of our basic website showing just the firefox logo - a flaming fox wrapping the world 
文件路径的一些通用规则： 
以上方法可以随意组合，比如：../subdirectory/another-subdirectory/my-image.jpg。 
{{PreviousMenuNext(“Learn/Getting_started_with_the_web/What_will_your_website_look_like”, “Learn/Getting_started_with_the_web/HTML_basics”, “Learn/Getting_started_with_the_web”)}} 

{{PreviousMenu(“Learn/Getting_started_with_the_web/Publishing_your_website”, “Learn/Getting_started_with_the_web”)}} 
这篇文章简单描述了你在计算机或手机上通过浏览器访问网页时发生了什么。 
这个理论在短期内对你编写网页代码不会有实质性的帮助，但是不久之后你就会真正受益于理解了后台究竟发生了什么。 
客户端和服务器 
连接到互联网的计算机被称作客户端和服务器。 
下面是一个简单描述它们如何交互的图表： 
Two circles representing client and server. 
An arrow labelled request is going from client to server, and an arrow labelled responses is going from server to client 
客户端是典型的 Web 用户入网设备（比如，你连接了 Wi-Fi 的电脑，或接入移动网络的手机）和设备上可联网的软件（通常使用像 Firefox 和 Chrome 的浏览器）。 
服务器是存储网页，站点和应用的计算机。 
当一个客户端设备想要获取一个网页时，一份网页的拷贝将从服务器上下载到客户端机器上来在用户浏览器上显示。 
上文所述的客户端和服务器并不能完成全部工作。 
还有其他必要的部分，我们将在下面讲述。 
现在，让我们假设 Web 就是一条路。 
路的一端是客户端，就像你的家。 
另一端则是服务器，就像你想去的商店。 
A black-and-white photo of a person crossing a road at a crosswalk 
备注： 我感觉下面的比喻还不是很契合。 
假如你生活在一个封闭的村子叫做“盘溪新村”，村子盛产苹果。 
从此，村子里的苹果就可以运出去卖了。 
TCP/IP：为了将村里的苹果能规范有效的运卖出去而不出问题，村长作出如下规定：“用规格刚好 20 cm * 20 cm * 20 cm 的泡沫箱来装，之后外面又用相应规格的纸箱包裹上，最后打上透明胶”。 
组成文件：送来的货可不止一车，而且也不止一种苹果，这车是红富士，那车黄富士的。 
一点拙见，在下抛砖引玉，希望有更好理解的比喻。 
基本上和你家到商店的街道差不多。 
这就像你去商店购物所使用的交通方式，比如汽车或自行车（或是你能想到的其他可能）。 
当你在浏览器内输入一个网址时，浏览器获取网页之前将会查看域名系统。 
浏览器需要找到存放你想要的网页的服务器，才能发送 HTTP 请求到正确的地方。 
HTTP: 超文本传输协议是一个定义客户端和服务器间交流的语言的协议（{{Glossary(“Protocol” , “protocol”)}} ）。 
就像你下订单时所说的话一样。 
组成文件: 一个网页由许多文件组成，就像商店里不同的商品一样。 
这些文件有两种类型： 
代码 : 网页大体由 HTML、CSS、JavaScript 组成，不过你会在后面看到不同的技术。 
资源 : 这是其他组成网页的东西的集合，比如图像、音乐、视频、Word 文档、PDF 文件。 
到底发生了什么？ 
当你在浏览器里输入一个网址时（在我们的例子里就是走向商店的路上时）： 
浏览器在域名系统（DNS）服务器上找出存放网页的服务器的实际地址（找出商店的位置）。 
浏览器发送 HTTP 请求信息到服务器来请拷贝一份网页到客户端（你走到商店并下订单）。 
这条消息，包括其他所有在客户端和服务器之间传递的数据都是通过互联网使用 TCP/IP 协议传输的。 
服务器同意客户端的请求后，会返回一个“200 OK”信息，意味着“你可以查看这个网页，给你～”，然后开始将网页的文件以数据包的形式传输到浏览器（商店给你商品，你将商品带回家）。 
浏览器将数据包聚集成完整的网页然后将网页呈现给你（商品到了你的门口 —— 新东西，好棒！）。 
解析组成文件的顺序 
当浏览器向服务器发送请求获取 HTML 文件时，HTML 文件通常包含 {{htmlelement(“link”)}} 和 {{htmlelement(“script”)}} 元素，这些元素分别指向了外部的 CSS 样式表文件和 JavaScript 脚本文件。 
了解这些文件被浏览器解析的顺序是很重要的： 
浏览器首先解析 HTML 文件，并从中识别出所有的 <link> 和 <script> 元素，获取它们指向的外部文件的链接。 
继续解析 HTML 文件的同时，浏览器根据外部文件的链接向服务器发送请求，获取并解析 CSS 文件和 JavaScript 脚本文件。 
接着浏览器会给解析后的 HTML 文件生成一个 DOM 树（在内存中），会给解析后的 CSS 文件生成一个 CSSOM 树（在内存中），并且会编译和执行解析后的 JavaScript 脚本文件。 
伴随着构建 DOM 树、应用 CSSOM 树的样式、以及执行 JavaScript 脚本文件，浏览器会在屏幕上绘制出网页的界面；用户看到网页界面也就可以跟网页进行交互了。 
DNS 解析 
真正的网址看上去并不像你输入到地址框中的那样美好且容易记忆。 
它们是一串数字，像 63.245.217.105。 
这叫做 {{Glossary(“IP Address”, “IP 地址”)}}，它代表了一个互联网上独特的位置。 
然而，它并不容易记忆，不是吗？ 
那就是域名系统（DNS）被发明的原因。 
它们是将你输入浏览器的地址（像 “mozilla.org”）与实际 IP 地址相匹配的特殊的服务器。 
网页可以通过 IP 地址直接访问。 
你可以通过在 DNS 查询工具 等工具中输入域名来查找网站的 IP 地址。 
数据包详解 
前面我们用“包”来描述了数据从服务器到客户端传输的格式。 
这是什么意思？ 
基本上，当数据在 Web 上传输时，是以成千上万的小数据块的形式传输的。 
大量不同的用户都可以同时下载同一个网页。 
如果网页以单个大的数据块形式传输，一次就只有一个用户下载，无疑会让 Web 非常没有效率并且失去很多乐趣。 
扩展阅读 
互联网是如何工作的 
HTTP — 一种应用级协议 
HTTP：让我们开始吧！ 

{{PreviousMenuNext(“Learn/Getting_started_with_the_web/Dealing_with_files”, “Learn/Getting_started_with_the_web/CSS_basics”, “Learn/Getting_started_with_the_web”)}} 
超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用来结构化 Web 网页及其内容的标记语言。 
网页内容可以是：一组段落、一个重点信息列表、也可以含有图片和数据表。 
正如标题所示，本文将对 HTML 及其功能做一个基本介绍。 
HTML 到底是什么？ 
HTML 不是一门编程语言，而是一种用于定义内容结构的标记语言。 
HTML 由一系列的{{Glossary(“element”, “元素”)}}组成，这些元素可以用来包围不同部分的内容，使其以某种方式呈现或者工作。 
一对{{Glossary(“tag”, “标签”)}}可以为一段文字或者一张图片添加超链接，将文字设置为斜体，改变字号，等等。 
例如，键入下面一行内容： 
My cat is very grumpy 
可以将这行文字封装成一个段落元素来使其在单独一行呈现： 
<p>My cat is very grumpy</p> 
HTML 元素详解 
让我们深入探索一下这个段落元素。 
HTML 元素 
这个元素的主要部分有： 
开始标签（Opening tag）：包含元素的名称（本例为 p），被大于号、小于号所包围。 
表示元素从这里开始或者开始起作用 —— 在本例中即段落由此开始。 
结束标签（Closing tag）：与开始标签相似，只是其在元素名之前包含了一个斜杠。 
这表示着元素的结尾 —— 在本例中即段落在此结束。 
初学者常常会犯忘记包含结束标签的错误，这可能会产生一些奇怪的结果。 
内容（Content）：元素的内容，本例中就是所输入的文本本身。 
元素（Element）：开始标签、结束标签与内容相结合，便是一个完整的元素。 
元素也可以有属性（Attribute）： HTML 属性 
属性包含了关于元素的一些额外信息，这些信息本身不应显现在内容中。 
本例中，class 是属性名称，editor-note 是属性的值。 
class 属性可为元素提供一个标识名称，以便进一步为元素指定样式或进行其他操作时使用。 
属性应该包含： 
在属性与元素名称（或上一个属性，如果有超过一个属性的话）之间的空格符。 
属性的名称，并接上一个等号。 
由引号所包围的属性值。 
备注： 不包含 ASCII 空格（以及 " ' ` = < >）的简单属性值可以不使用引号，但是建议将所有属性值用引号括起来，这样的代码一致性更佳，更易于阅读。 
嵌套元素 
也可以将一个元素置于其他元素之中 —— 称作嵌套。 
要表明猫咪非常暴躁，可以将“very”用 {{htmlelement(“strong”)}} 元素包围，爆字将突出显示： 
<p>My cat is <strong>very</strong> grumpy.</p> 
必须保证元素嵌套次序正确：本例首先使用 {{htmlelement(“p”)}} 标签，然后是 {{htmlelement(“strong”)}} 标签，因此要先结束 {{htmlelement(“strong”)}} 标签，最后再结束 {{htmlelement(“p”)}} 标签。 
这样是不对的： 
html example-bad <p>My cat is <strong>very grumpy.</p></strong> 
元素必须正确地开始和结束，才能清楚地显示出正确的嵌套层次。 
否则浏览器就得自己猜测，虽然它会竭尽全力，但很大程度不会给你期望的结果。 
所以一定要避免！ 
空元素 
不包含任何内容的元素称为空元素。 
比如 {{htmlelement(“img”)}} 元素： 
<img src="images/firefox-icon.png" alt="My test image" /> 
本元素包含两个属性，但是并没有 </img> 结束标签，元素里也没有内容。 
这是因为图像元素不需要通过内容来产生效果，它的作用是向其所在的位置嵌入一个图像。 
HTML 文档详解 
以上介绍了一些基本的 HTML 元素，但孤木不成林。 
现在来看看单个元素如何彼此协同构成一个完整的 HTML 页面。 
回顾 文件处理 小节中创建的 index.html 示例： 
<! 
doctype html> 
<html lang="en-US"> 
<head> 
<meta charset="utf-8" /> 
<meta name="viewport" content="width=device-width" /> 
<title>My test page</title> 
</head> 
<body> 
<img src="images/firefox-icon.png" alt="My test image" /> 
</body> 
</html> 
这里有： 
<! 
DOCTYPE html>——文档类型。 
这是必不可少的开头。 
混沌初分，HTML 尚在襁褓（大约是 1991/92 年）之时，这个元素用来关联 HTML 编写规范，以供自动查错等功能所用。 
而在当今，它作用有限，可以说仅用于保证文档正常读取。 
现在知道这些就足够了。 
<html></html>——{{htmlelement(“html”)}} 元素。 
该元素包含整个页面的所有内容，有时候也称作根元素。 
里面也包含了 lang 属性，写明了页面的主要语种。 
<head></head>——{{htmlelement(“head”)}} 元素。 
所有那些你加到页面中，且不向看客展示的页面成员，都以这个元素为容器。 
其中包含诸如提供给搜索引擎的{{Glossary(“keyword”, “关键字”)}}和页面描述、用作风格化页面的 CSS、字符集声明等等。 
<meta charset="utf-8">——该元素指明你的文档使用 UTF-8 字符编码，UTF-8 包括世界绝大多数书写语言的字符。 
它基本上可以处理任何文本内容。 
以它为编码还可以避免以后出现某些问题，没有理由再选用其他编码。 
<meta name="viewport" content="width=device-width">——视口元素可以确保页面以视口宽度进行渲染，避免移动端浏览器上因页面过宽导致缩放。 
<title></title>——{{htmlelement(“title”)}} 元素。 
该元素设置页面的标题，显示在浏览器标签页上，也作为收藏网页的描述文字。 
<body></body>——{{htmlelement(“body”)}} 元素。 
该元素包含期望让用户在访问页面时看到的全部内容，包括文本、图像、视频、游戏、可播放的音轨或其他内容。 
图像 
重温一下 {{htmlelement(“img”)}} 元素： 
<img src="images/firefox-icon.png" alt="My test image" /> 
像之前所讲，该元素通过包含图像文件路径的地址属性 src，可在所在位置嵌入图像。 
该元素还包括一个替换文字属性 alt，是图像的描述内容，用于当图像不能被用户看见时显示，不可见的原因可能是： 
用户有视觉障碍。 
视障用户可以使用屏幕阅读器来朗读 alt 属性的内容。 
有些错误使图像无法显示。 
可以试着故意将 src 属性里的路径改错。 
保存并刷新页面就可以在图像位置看到： 
图片内容为文字“测试图片” 
alt 属性的关键字即“描述文本”。 
alt 文本应向用户完整地传递图像要表达的意思。 
用 “测试图片” 来描述 Firefox 标志并不合适，修改成 “Firefox 标志：一只盘旋在地球上的火狐” 就好多了。 
可以试着为图像编写一些更好的 alt 文本。 
备注： 更多信息请参阅 无障碍访问。 
标记文本 
本段包含了一些最常用的文本标记 HTML 元素。 
标题（Heading） 
标题元素可用于指定内容的标题和子标题。 
就像一本书的书名、每章的大标题、小标题，等。 HTML 文档也是一样。 
HTML 包括六个级别的标题， {{htmlelement(“h1”)}}–{{htmlelement(“h6”)}} ，一般最多用到 3-4 级标题。 
<h1>主标题</h1> 
<h2>顶层标题</h2> 
<h3>子标题</h3> 
<h4>次子标题</h4> 
可以尝试在 {{htmlelement(“img”)}} 元素上面添加一个合适的标题。 
备注： 你可以看到第一级标题是有隐式的主题样式。 
不要使用标题元素来加大、加粗字体，因为标题对于 无障碍访问 和 搜索引擎优化 等问题非常有意义。 
要保持页面结构清晰，标题整洁，不要发生标题级别跳跃。 
如上文所讲，{{htmlelement(“p”)}} 元素是用来指定段落的。 通常用于指定常规的文本内容： 
<p>这是一个段落</p> 
试着添加一些文本（在 设计网站的外观 小节）到一个或几个段落中，并把它们放在你的 {{htmlelement(“img”)}} 元素下方。 
列表（List） 
Web 上的许多内容都是列表，HTML 有一些特别的列表元素。 
标记列表通常包括至少两个元素。 
最常用的列表类型为： 
无序列表（Unordered List）中项目的顺序并不重要，就像购物列表。 
用一个 {{htmlelement(“ul”)}} 元素包围。 
有序列表（Ordered List）中项目的顺序很重要，就像烹调指南。 
用一个 {{htmlelement(“ol”)}} 元素包围。 
列表的每个项目用一个列表项目（List Item）元素 {{htmlelement(“li”)}} 包围。 
比如，要将下面的段落片段改成一个列表： 
<p> 
At Mozilla, we're a global community of technologists, thinkers, and builders 
working together… 
</p> 
可以这样更改标记： 
<p>At Mozilla, we're a global community of</p> 
<ul> 
<li>technologists</li> 
<li>thinkers</li> 
<li>builders</li> 
</ul> 
<p>working together…</p> 
试着在示例页面中添加一个有序列表和无序列表。 
链接 
链接非常重要 — 它们赋予 Web 网络属性。 
要植入一个链接，我们需要使用一个简单的元素 — {{htmlelement(“a”)}} — a 是 “anchor” （锚）的缩写。 
要将一些文本添加到链接中，只需如下几步： 
选择一些文本。 
比如“Mozilla Manifesto”。 
将文本包含在 {{htmlelement(“a”)}} 元素内，就像这样： 
<a>Mozilla Manifesto</a> 
为此 {{htmlelement(“a”)}} 元素添加一个 href 属性，就像这样： 
<a href="">Mozilla Manifesto</a> 
把属性的值设置为所需网址： 
<a href="https://www.mozilla.org/zh-CN/about/manifesto/" 
>Mozilla Manifesto</a 
> 
如果网址开始部分省略了 https:// 或者 http://，可能会得到错误的结果。 
在完成一个链接后，可以试着点击它来确保指向正确。 
备注： href 这个名字可能开始看起来有点令人费解，代表超文本引用（ hypertext reference）。 
现在就为页面添加一个链接吧。 
小结 
如果你一直跟着这篇文章里的指导做的话，你应该完成了一个像下面这样的页面（也可以查看这里）： 
如果你遇到困难，你可以将 Github 上的完整示例代码与你的文件进行比较。 
在这里，我们只是介绍了一点点 HTML。 
要学习更多，访问我们的 HTML 学习主题页面 。 
{{PreviousMenuNext(“Learn/Getting_started_with_the_web/Dealing_with_files”, “Learn/Getting_started_with_the_web/CSS_basics”, “Learn/Getting_started_with_the_web”)}} 

{{LearnSidebar}} 
web 入门是一个简要的系列，向你介绍 web 开发的实用性。 
你将配置你需要的工具来构建一个简单的网页，并发布一份属于你自己的代码。 
你的第一个网站 
创建一个专业的网站需要大量的工作，所以如果你是 web 开发的新手，我们鼓励你从小事做起。 
你不可能立马再建一个 Facebook，但做一个自己的简单网站并不难，我们将由此开始。 
通过阅读下面列出的文章，你将从零开始获得你的第一个在线网页。 
让我们开始吧！ 
安装基本软件 
: 说到建设网站的工具，有很多可供选择的。 
如果你初入门径，你可能会被外面的一系列代码编辑器、框架和测试工具所迷惑。 
在这篇文章中，我们将逐步向你展示如何安装你需要的软件，以开始基本的 web 开发。 
你的网站会是什么样子？ 

{{LearnSidebar}}{{NextMenu(“Learn/Getting_started_with_the_web/What_will_your_website_look_like”, “Learn/Getting_started_with_the_web”)}} 
目前，最常用的浏览器是 Firefox 、Chrome、Opera、Safari、Internet Explorer 和 Microsoft Edge。 
有大量的 (S)FTP 程序可用，包括 Cyberduck、Fetch 和 FileZilla。 
这看起来是一个冗长的清单，但幸运的是，你可以在不了解这些东西的情况下开始进行 Web 开发。 
安装文本编辑器 
你的电脑上可能已经有一个基本的文本编辑器。 
默认情况下，Windows 是 Notepad ，macOS 则有 TextEdit。 
Linux 发行版有所不同；Ubuntu 下是 gedit 。 
对于 Web 开发，你可能可以做得比记事本或 TextEdit 更好。 
我们建议从 Visual Studio Code 开始，它是一个免费的编辑器，提供实时预览和代码提示。 
安装现代网络浏览器 
现在，我们将安装几个桌面网络浏览器来测试我们的代码。 
在下面选择你的操作系统，然后点击相关链接，下载你喜欢的浏览器： 
Linux：Firefox 、Chrome 、Opera 、Brave. 
Windows：Firefox 、Chrome 、Opera 、Internet Explorer 、Microsoft Edge 、Brave （Windows 10 默认带有 Edge；如果你有 Windows 7 或以上版本，你可以安装 Internet Explorer 11；否则，你应该安装一个替代浏览器）。 
macOS：Firefox 、Chrome 、Opera 、Safari 、Brave （macOS 和 iOS 默认带有 Safari 浏览器）。 
备注： Internet Explorer 与一些现代网络功能不兼容，它可能无法运行你的项目。 
安装本地 Web 服务器 
有些例子需要通过 Web 服务器才能成功运行。 
你可以在这找到该怎么做如何设置本地测试服务器？ 

{{PreviousMenuNext(“Learn/Getting_started_with_the_web/CSS_basics”, “Learn/Getting_started_with_the_web/Publishing_your_website”, “Learn/Getting_started_with_the_web”)}} 
JavaScript 是一门编程语言，可为网站添加交互功能（例如：游戏、动态样式、动画以及在按下按钮或收到表单数据时做出的响应等）。 
本文介绍了 JavaScript 的精彩之处和主要用途。 
JavaScript 到底是什么？ 
{{Glossary(“JavaScript”)}}（缩写：JS）是一门完备的动态编程语言。 
当应用于 {{Glossary(“HTML”)}} 文档时，可为网站提供动态交互特性。 
JavaScript 的应用场合极其广泛，简单到幻灯片、照片库、浮动布局和响应按钮点击，复杂到游戏、2D/3D 动画、大型数据库驱动程序等等。 
JavaScript 相当简洁，却非常灵活。 
开发者们基于 JavaScript 核心编写了大量实用工具，可以使 开发工作事半功倍。 
其中包括： 
浏览器应用程序接口（{{Glossary(“API”,“API”)}}）—— 浏览器内置的 API 提供了丰富的功能，比如：动态创建 HTML 和设置 CSS 样式、从用户的摄像头采集处理视频流、生成 3D 图像与音频样本等等。 
第三方 API —— 让开发者可以在自己的站点中整合其他内容提供者（Twitter、Facebook 等）提供的功能。 
第三方框架和库 —— 用来快速构建网站和应用。 
本节是一篇 JavaScript 简介，因此这个阶段不会对 JavaScript 语言和上述工具做过多的介绍。 
之后可以到 JavaScript 学习区 和 MDN 的其他地方学习更多细节。 
下面对语言核心做一个不完整介绍，期间还可以接触到一些浏览器 API 特性。 
“Hello World!” 
示例 
读到这里你一定很激动，诚然 —— JavaScript 是最振奋人心的 Web 技术之一，而且在娴熟驾驭之后，你的网站在功能和创新力上将达到一个新的维度。 
然而，JavaScript 比 HTML 和 CSS 学习起来更加复杂一点，所以必须一步一个脚印地学习。 
首先，来看看如何在页面中添加一些基本的 JavaScript 脚本来建造一个“Hello world!” 
示例（一切始于 Hello World）。 
警告： 如果你没有完成之前的课程实践，可下载 上一章节示例的压缩包 并在本地解压作出发点。 
首先，打开你的测试站点，创建一个名为 scripts 的文件夹。 
然后在其中创建一个名为 main.js 的文件。 
下一步，在 index.html 文件</body> 标签前的新行添加以下代码。 
<script src="scripts/main.js" defer></script> 
与 CSS 的 {{htmlelement(“link”)}} 元素类似，它将 JavaScript 引入页面以作用于 HTML（以及 CSS 等页面上所有内容）： 
现在将以下代码添加到 main.js 文件中： 
let myHeading = document.querySelector("h1"); 
myHeading.textContent = "Hello world!" 
; 
最后，保存 HTML 和 JavaScript 文件，用浏览器打开 index.html。 
可以看到如下内容： 
备注： 我们将 {{htmlelement(“script”)}} 放在 HTML 文件的底部附近的原因是浏览器会按照代码在文件中的顺序加载 HTML。 
如果先加载的 JavaScript 期望修改其下方的 HTML，那么它可能由于 HTML 尚未被加载而失效。 
因此，将 JavaScript 代码放在 HTML 页面的底部附近通常是最好的策略。 
发生了什么？ 
JavaScript 把页面的标题改成了“Hello world!” 。 
首先用 {{domxref(“Document.querySelector”, “querySelector()”)}} 函数获取标题的引用，并把它储存在 myHeading 变量中。 
这与 CSS 选择器的用法非常相像：若要对某个元素进行操作，首先得选择它。 
之后，把 myHeading 变量的属性 {{domxref(“Node.textContent”, “textContent”)}} （标题内容）修改为“Hello world!” 。 
备注： 上面用到的两个函数都来自 文档对象模型 (DOM) API，均用于控制文档。 
JavaScript 快速入门 
我们来学习一些 JavaScript 的核心特性，从而更好地理解它的运行机制。 
学习这些知识很有意义，因为这些原理普遍适用于所有编程语言，掌握好它们，可以做到融会贯通。 
警告： 学习本节时，请尝试将示例代码输入到 JavaScript 控制台里看看会发生什么。 
JavaScript 控制台的更多信息请查看 浏览器开发者工具。 
变量（Variable） 
{{Glossary(“Variable”, “变量”)}} 是存储值的容器。 
要声明一个变量，先输入关键字 let 或 var，然后输入合适的名称： 
let myVariable; 
备注： 行末的分号表示当前语句结束，不过只有在单行内需要分割多条语句时，这个分号才是必须的。 
然而，一些人认为每条语句末尾加分号是一种好的风格。 
分号使用规则的更多细节请参阅 JavaScript 分号使用指南（英文页面）。 
备注： 几乎任何内容都可以作为变量名，但还是有一些限制（请参阅 变量命名规则）。 
如果你不确定，还可以 验证变量名 是否有效。 
备注： JavaScript 对大小写敏感，myVariable 和 myvariable 是不同的。 
如果代码出现问题了，先检查一下大小写！ 
备注： 想要了解更多关于 var 和 let 的不同点，可以参阅 var 与 let 的区别。 
变量定义后可以进行赋值： 
myVariable = "李雷"; 
也可以将定义、赋值操作写在同一行： 
let myVariable = "李雷"; 
可以直接通过变量名取得变量的值： 
myVariable; 
变量在赋值后是可以更改的： 
let myVariable = '李雷'; 
myVariable = '韩梅梅'; 
注意变量可以有不同的 数据类型 ： 
变量 
解释 
示例 
{{Glossary(“String”)}} 
字符串（一串文本）：字符串的值必须用引号（单双均可，必须成对）括起来。 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/Getting_started_with_the_web/JavaScript_basics”, “Learn/Getting_started_with_the_web/How_the_Web_works”, “Learn/Getting_started_with_the_web”)}} 
在你已经写好了代码并且整理好了你网站的全部文件后，你需要将它们全部上线，这样别人才能看到。 
这篇文章将向你展示如何轻松地将你简单的示例代码传到网上。 
有哪些方法可供选择？ 
发布一个网页并不是三言两语就能简单说明的，这主要是因为我们有很多种方法去完成它。 
在这篇文章里我们并不准备讲述所有方法，而是从初学者的视角讨论以下三种常见的方式的利弊，然后带你看看我们将要使用的一种方法。 
获取主机服务和域名 
如果你想要完全控制你发布的网页，那么你将需要花钱购置： 
主机服务——在主机服务提供商的 Web 服务器上租用文件空间。 
将你网站的文件上传到这里，然后服务器会提供 Web 用户需求的内容。 
域名——一个可以让人们访问的独一无二的地址，比如 http://www.mozilla.org 或 http://www.bbc.co.uk。 
你可以从域名注册商租借域名。 
许多专业的网站通过这种方法接入互联网。 
此外，你将需要一个 {{Glossary(“FTP”, “文件传输协议”)}} 程序 ( 点击钻研在网络上做某些事情要花费多少：软件查看详细信息 ) 来将网站文件上传到服务器。 
不同的 FTP 程序涵盖了不同的范围，但是你通常需要使用主机服务提供商给你的详细信息（比如用户名、密码、主机名）登录到 Web 服务器。 
然后程序在两个窗口里分别显示本地文件和服务器文件，这样你就可以在它们之间进行传输： 
寻找主机服务和域名的建议 
我们不会推荐任何商业化的主机公司。 
要找到主机公司和域名注册商，只需要搜索 “网络主机服务” 和 “域名” 来找到一家出售域名的公司。 
所有这种类型的公司都允许你查看你想要的域名是否可用。 
你的家庭或办公 {{Glossary(“ISP”, “网络服务提供商”)}} 可能会提供一些受限制的的小型主机空间。 
有一些免费服务比如 Neocities ， Blogspot ，和 Wordpress 。 
重复一遍，一分钱一分货，不过它们对于你的初次实验可能会是很理想的。 
免费服务大部分也不需要 FTP 软件来上传文件——你只需要将文件拖入到它们网页的界面里。 
有时公司会打包提供主机服务和域名。 
使用在线工具如 GitHub 或 Google App Engine 
有一些工具能使你在线发布网站 : 
GitHub 是一个“社交编程”网站。 
它允许你上传代码库并储存在 Git 版本控制系统里。 然后你可以协作代码项目，系统是默认开源的，也就是说世界上任何人都可以找到你 GitHub 上的代码。 去使用 GitHub，从中学习并且提高自己吧！ 你也可以对别人的代码那样做！ 
GitHub 有一个非常有用的特点叫 GitHub pages，允许你将网站代码放在网上。 
Google App Engine 是一个让你可以在 Google 的基础架构上构建和运行应用的强劲平台——无论你是需要从头开始构建多级 web 应用还是托管一个静态网站。 
参阅How do you host your website on Google App Engine? 
以获取更多信息。 
不同于大部分其他托管服务，这类工具通常是免费的，不过你只能使用有限的功能。 
使用像 CodePen 这样基于 Web 的集成开发环境 
有许多 web 应用能够仿真一个网站开发环境。 你可以在这种应用——通常只有一个标签页——里输入 HTML、CSS 和 JavaScript 代码然后像显示网页一样显示代码的结果。 
通常这些工具都很简单，对学习很有帮助，而且至少有免费的基本功能，它们在一个独特的网址显示你提交的网页。 
不过，这些应用的基础功能很有限，而且应用通常不提供空间来存储图像等内容。 
使用一下以下几种工具，看看你最喜欢哪一个： 
JSFiddle 
Glitch 
JSBin 
CodePen 
通过 GitHub 发布 
现在，让我们通过 Github 页面告诉你公布的你的代码是如此的简单。 
首先， 注册一个 GitHub 账号， 并确认你的邮箱地址。 
接下来，你需要创建一个新的资源库 ( repository ) 来存放你的文件。 
在这个页面上，在 Repository name 输入框里输入 username.github.io，username 是你的用户名。 
比如，我们的朋友 bobsmith 会输入 bobsmith.github.io。 
同时勾选 Initialize this repository with a README，然后点击 Create repository。 
然后，将你的网站文件夹里的内容拖拽到你的资源库 ( repository )，再点击 Commit changes。 
备注： 确保你的文件夹有一个 index.html 文件。 
现在将你的浏览器转到 username.github.io 来在线查看你的网站。 
比如，如果用户名为 chrisdavidmills, 请转到 chrisdavidmills.github.io。 
备注： 你的网站可能需要几分钟的时间才能投入使用。 
如果它不能立即工作，你可能需要等待几分钟，然后再试一次。 
想要了解更多，请看 GitHub Pages Help. 
延展阅读 
什么是网络服务器？ 

{{learnsidebar}} 
这篇文章提供了一些有用的 Web 背景知识——它是如何产生的，什么是 Web 标准技术，它们是如何协同工作的，为什么“Web 开发人员”是一个很好的职业选择，以及你将在本课程中学习哪些最佳做法。 
Web 简史 
我们会简单叙述，因为别处已有很多关于 Web 历史的详尽说明，稍后我们会链接到它们（如果那你对更多细节内容感兴趣，也请试着在你惯用的搜索引擎中搜索“Web 的历史”以获取相关内容。） 
在 20 世纪 60 年代末期，美国军方开发了一个名为 ARPANET 的通信网络。 
这可以认为是 Web 的先驱，因为它基于 分组交换（packet switching） 进行工作，并且首次实现了 TCP/IP 协议族（TCP/IP protocol suite） 。 
这两种技术构成了互联网基础设施的基础。 
1980 年，Tim Berners-Lee（通常称之为 TimBL）写了一个叫 ENQUIRE 的笔记本程序，这个程序实现了不同节点之间链接的概念。 
听起来有点熟悉对吧？ 
快进到 1989 年，TimBL 在 CERN 撰写了 《Information Management: A Proposal》 和《HyperText》 ；这两个出版物共同为 Web 将如何工作做了铺垫。 
两个出版物获得了极大的关注，这足以说服 TimBL 的上司让他继续前进，并创建一个全球超文本系统。 
到 1990 年底，TimBL 已经创建了运行第一个版本的 Web 所需的所有东西—— HTTP，HTML，名为 WorldWideWeb 的第一个 Web 浏览器，一个 HTTP 服务器和一些用于查看的网页。 
在随后的几年中，随着多个浏览器的发布，数以千计 Web 服务器的建立，上百万网页的生成，Web 爆发式发展。 
OK，这只是对事件非常粗略的描述，但我向你说过会简单叙述。 
最后一个值得分享的重要事件在 1994 年，TimBL 建立了万维网联盟（World Wide Web Consortium，W3C），该组织汇集了来自许多不同技术公司的代表，共同制定 Web 技术规范。 
随后其他的技术像 CSS 和 JavaScript 出现了，Web 开始看起来更像我们现在所了解的 Web。 
Web 标准 
Web 标准是我们用来建立 Web 网站的技术。 
这些标准存在于名为规范的较长的技术文档中，该文档详细说明了技术应如何工作。 
这些文档对于学习如何使用它们所描述的技术并不是很有用（这就是我们建立像 MDN Web Docs 这样的网站的原因），而是旨在供软件工程师用来实现这些技术（通常在 Web 浏览器中）。 
例如，HTML Living Standard 描述了应如何实现 HTML（所有 HTML 元素及其关联的 API 和其他相关技术）。 
Web 标准是由标准机构创建的——这些机构邀请不同技术公司的人员聚集在一起，并就如何以最佳方式实现所有用例达成共识。 
W3C 是最著名的 Web 标准组织，但还有其他组织，例如WHATWG（负责 HTML 语言的现代化），ECMA（发布基于 JavaScript 的 ECMAScript 标准），Khronos（发布 3D 图形技术，例如 Web GL）等。 
“开放”标准 
Web 标准的关键方面之一，TimBL 和 W3C 从一开始就认同的一点，Web（和 Web 技术）应该自由地贡献和使用，并且不受专利/许可的约束。 
因此，任何人都可以编写代码免费建立网站，并且任何人都可以为编写规范的标准创建过程做出贡献。 
由于 Web 技术是开放的，因此在许多不同公司之间的协作中，这意味着没有一家公司可以控制它，这确实是一件好事。 
你不会希望任何一家公司突然决定将整个 Web 置于付费壁垒之后，或者发布每个人都必须购买以继续制作网站的新版 HTML，或者更糟糕的是，仅仅将他们不再感兴趣的网站关闭。 
真正起步需要花几个月的时间，然后你需要继续学习，继续练习和完善自己的技术，以使你的知识与 Web 平台上出现的所有新工具和功能步调一致。 
唯一不变的就是变化。 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/Getting_started_with_the_web/Installing_basic_software”, “Learn/Getting_started_with_the_web/Dealing_with_files”, “Learn/Getting_started_with_the_web”)}} 
本文将讲述在编写网站代码之前，需要进行什么样的规划和设计工作，包括“网站提供哪些信息？”、“用哪些字体和颜色？”、“网站是做什么的？” 
等。 第一步：计划 
做任何事情之前，都要先有一些想法。 
你的网站到底是做什么的？ 
一个网站基本上可以做任何事情，但对于第一个网站来说，最好简单一些。 
我们将从创建一个简单网页开始，它包含一个标题、一张图片和几个段落。 
首先，请考虑以下问题： 
网站的主题是什么？ 
你喜欢狗、上海、还是吃豆人？ 
基于所选主题要展示哪些信息？ 
写下标题和几段文字，再找个你想在网站上展示的图像。 
背景颜色用什么，或者，用高级一点的话来说，你的网站外观是什么样的？ 
使用哪种字体比较合适：正式的、卡通的、粗体还是瘦体？ 
备注： 复杂的网站需要更详细的指引，深入到颜色、字体、页面上元素的间距、适当的书写风格等等以及其他细节。 
这有时被称为设计指南、设计系统或品牌手册，可以在 Firefox Photon 设计系统中找到一个示例。 
绘制草图 
接下来，拿起笔和纸，大致勾勒出你所希望的网站样子。 
当然，这个简单的网页不需要太复杂的草图，但你现在应该养成这样做的习惯。 
画草图很有用——并且不需要梵高的手法！ 
画在纸上的一个粗略的网站草图 
备注： 即使在实际的复杂网站中，设计团队通常也是从粗略的草图开始设计的，再使用图形编辑器或 Web 技术建立数字模拟图。 
Web 团队通常包括一个平面设计师和一个{{Glossary(“UX”, “用户体验”)}}（UX）设计师。 
平面设计师把网站的视觉效果放在一起。 
用户体验设计师则以一种更抽象的模式来解决用户如何体验及与网站交互方面的问题。 
选定素材 
此时，就可以开始组织网页上的内容了。 
文本 
准备好刚才撰写的标题和文字。 
把这些东西放到旁边。 
主题颜色 
使用色彩选择器挑选心仪的颜色。 
当选中某种颜色时，会显示一个六位神秘代码，类似于 #660066。 
它是一个十六进制数，用于表示颜色。 
将其复制并暂存。 
MDN 网站上的颜色选择器，包含 RGB、HSL、HEX 格式 
图像 
访问 Google 图片搜索 来搜索合适的图片。 
当找到你想要的图像时，点击该图像以获得其放大的视图。 
右键单击图像（Mac 上为 Ctrl + 单击），选择将图像另存为…，并选择一个可靠的位置来保存你的图像。 
或者，从浏览器地址栏中复制图片的网址，以便以后使用。 
Google 图片搜索中的搜索结果 
请注意，网络上的大多数图片，包括谷歌图像中的图片，都是有版权的。 
为了减少侵权的可能性，可以使用谷歌的许可证过滤器。 
点击工具按钮，然后点击下面出现的使用权限选项。 
你应该选择知识共享许可这个选项。 
经知识共享许可过滤后的 Google 图片搜索结果 
字体 
和图片一样，很多字体都受版权保护，也就是说，你不可以在你的网站上随意使用它们。 Google Fonts 是 Google 旗下的网络服务，提供了许多字体许可。 
选好字体后，你有两种方式使用它： 
在你的代码中添加一个引用，从 Google 服务器加载这个字体。 
下载字体文件到你的系统内，自行挂载这个文件，并在你网站的代码中使用。 
备注： 在你的网站使用从 Google 服务器加载的字体可能会违反欧盟的数据隐私规定 GDPR，因为加载字体时会暴露用户的 IP 地址。 
如果你遇到这种潜在风险，需要选择第二种方式。 
另一个选择是使用 安全 Web 字体，如 Arial、Times New Roman、Courier New。 
{{PreviousMenuNext(“Learn/Getting_started_with_the_web/Installing_basic_software”, “Learn/Getting_started_with_the_web/Dealing_with_files”, “Learn/Getting_started_with_the_web”)}} 


以下技巧都是基于通用的知识和经验。 
直至今日，页面的大小仍是页面加载性能的最重要因素。 
If you use background images a lot in your CSS, you can reduce the number of HTTP lookups needed by combining the images into one, known as an image sprite. 
This technique works best with elements that will have limited dimensions, and will not work for every use of a background image. 
A CDN is a geographically distributed network of servers that work together to shorten the distance between the user and your website. 
CDNs store cached versions of your website and serve them to visitors via the network node closest to the user, thereby reducing latency. 
Further reading: 
Understanding CDNs 
每个独立的域名都会消耗 DNS 查找的时间，页面加载时间会随着独立域名数量、CSS 链接数量、JavaScript 还有图片资源的数量增加而增加。 
这条可能算不上实用，然而，在你的页面中尽量少的使用来自不同域名的资源链接。 缓存重用的内容 
自上次修改之后，这部分 header 指示将信息传递给用户代理（要加载这些信息的文件）。 
大部分网页服务器会自动追加 Last-Modified header 部分到静态页面（如 .html，.css），基于上次修改的日期储存在文件系统中。 
HTTP 304: Not Modified 
在页面最初显示时，会首先下载页面内容以及所需的 CSS 和 JavaScript，这样在页面加载时用户可以最快获得外观的反馈。 由于内容通常都是文本，有利于在传输过程中压缩，因此给用户以更快的响应。 
页面中任何具有动态特性的资源需要在页面被完全加载后才可以使用，所以最好在初始化时关闭动态特性（disable dynamic features），等页面加载完后再打开它。 
这样 JavaScript 就会在网页内容之后才加载，有助于提升页面加载的整体表现。 减少内联脚本的数量 
现在浏览器中一般使用现代的 W3C DOM 方法操作页面内容，优于使用document.write()的传统方法。 使用现代 CSS 和合法标记 
使用现代 CSS 减少标记（markup）的用量，可以减少对（spacer）图片的需求。 
例如，HTML Tidy 可以移除空白（whitespace）和可选的末尾标记（ending tags）；然而，在有严重的错误标记的网页中这些工具便无法工作。 给内容分块 
使用 table 布局是一种不应该再采用的传统方法，而应运用 floats, positioning, flexbox, 或 grids 来布局。 
Minify and compress SVG assets 
SVG produced by most drawing applications often contains unnecessary metadata which can be removed. Configure your servers, apply gzip compression for SVG assets. Minify and compress your images 
Large images cause your page to take more time to load. 
Consider compressing your images before adding them to your page, using compression features built into image-manipulation tools such as Photoshop, or using a specialized tool such as Compress Jpeg or Tiny PNG,. 指定图像和表格的大小 
如果浏览器可以即时决定你的照片（images）和表格（tables）宽高，它在展示网页时就不必进行内容重新排版。 
这不仅可以加速网页的显示，还能在网页完成加载的过程中防止恼人的布局改变。 
table-layout: fixed; 
用 <col> 和 <colgroup> 元素来指定列宽。 
合理的选择 user-agent 
为使页面设计得到极大提升，应确保在工程中指定一个合理的 user-agent。 不要奢求你的内容在所有浏览器中都完美的展现，特别是在那些低版本的浏览器中。 
需要注意一下，这篇文章当中的许多 tips 都是些技术性常识，可以不必担心浏览器的支持需求而应用到任何 user-agent 和网页中去。 
尽可能使用 async 和 defer 
确保 JavaScript 脚本兼容 async 和 defer，任何时候都要尽可能使用 async ，特别是当你有较多的 script 标签时。 

{{LearnSidebar}} 
下面的链接指向日常中需要用 HTML 解决的问题的解决方案。 
基本结构 
HTML 应用最基础的是文档结构。 
如果你是 HTML 新手那么你应该和我们一起从这里开始学习。 
如何创建 HTML 文档 
如何将网页分成有逻辑的部分 
如何设置一个适当的标题和段落结构 
基本文本语义 
HTML 专门为文档提供语义信息，因此，HTML 能够解答关于如何在文档中最好地传递消息的许多问题。 
如何用 HTML 创建列表项 
如何强调或凸显内容 
如何表明文本是重要的 
如何用 HTML 展示计算机代码 
如何注释图片和图标 
如何注解缩略语并使其可理解 
如何为网页添加引述和引用 
如何用 HTML 定义术语 
超链接 
使用 HTML 的主要原因之一，就是可以使用{{Glossary(“hyperlink”, “超链接”)}}来轻松导航，实现方式有以下几种： 
如何创建超链接 
如何创建导航菜单 
图像 & 多媒体 
如何在页面中添加图片 
如何在页面中添加视频 
脚本 & 样式 
HTML 仅仅建立了文档结构。 
为解决演示问题，可使用 {{glossary(“CSS”)}} 或脚本使页面具有交互功能。 
如何在网页中使用 CSS 
如何在网页中使用 JavaScript 
嵌入内容 
如何在网页中嵌入另一个页面 
不常见或进阶的问题 
除了基本问题，HTML 还有更丰富的功能，其提供了高级特性用于解决复杂问题。 
这些文章可以帮助你解决一些相对不常见的问题： 
表单 
表单是一种复杂的 HTML 结构，用于从网页向网络服务器发送数据。 
我们鼓励你仔细阅读完整指南。 
你可由此入门： 
如何创建一个简单的网页表单 
如何组织一个网页表单 
表格信息 
一些表格化信息/数据需用行和列整合到表格中去。 
而表格是最复杂的 HTML 结构之一，熟练掌握它并不容易： 
如何创建一张数据表格 
如何使 HTML 表格更具无障碍性 
数据表示 
如何用 HTML 表示数值和代码，参见上标和下标以及展示计算机代码 
如何使用 data 属性 
高级文本语义 
如何控制 HTML 换行 
如何标记内容的更改（文字的增加或删除）——参见 {{htmlelement(“ins”)}} 与 {{htmlelement(“del”)}} 元素。 
高级图像 & 多媒体 
如何为网页添加响应式图像 
如何为网页添加矢量图像 
如何在图像上添加 hit map 
国际化 
HTML 支持多语言，其提供了用于解决常见的国际化问题的工具。 
如何为单一网页添加多语言支持 
如何用 HTML 展现时间和日期 
性能 
如何写一个加载速度很快的 HTML 页面 

{{LearnSidebar}} 
HTML 是具有扩展性的设计，它初衷是数据应与特定的元素相关联，但不需要任何定义。 data-* 属性允许我们在标准、语义化的 HTML 元素中存储额外的信息，而不需要使用类似于非标准属性或者 DOM 额外属性之类的技巧。 
HTML 语法 
语法非常简单。 
所有在元素上以data-开头的属性为数据属性。 
比如说你有一篇文章，而你又想要存储一些不需要显示在浏览器上的额外信息。 
请使用 data 属性： 
<article 
id="electriccars" 
data-columns="3" 
data-index-number="12314" 
data-parent="cars"> 
... 
</article> 
JavaScript 访问 
在外部使用JavaScript去访问这些属性的值同样非常简单。 
你可以使用{{domxref(“Element.getAttribute”, “getAttribute()”)}}配合它们完整的 HTML 名称去读取它们，但标准定义了一个更简单的方法：{{domxref(“DOMStringMap”)}}你可以使用{{domxref(“HTMLElement.dataset”, “dataset”)}}读取到数据。 
为了使用dataset对象去获取到数据属性，需要获取属性名中data-之后的部分 (要注意的是破折号连接的名称需要改写为骆驼拼写法 (如”index-number”转换为”indexNumber”))。 
var article = document.querySelector("#electriccars"); 
article.dataset.columns; // "3" 
article.dataset.indexNumber; // "12314" 
article.dataset.parent; // "cars" 
每一个属性都是一个可读写的字符串。 
在上面的例子中，article.dataset.columns = 5. 将会调整属性的值为 5。 
CSS 访问 
注意，data 设定为 HTML 属性，他们同样能被CSS访问。 
比如你可以通过generated content使用函数{{cssxref(“attr”)}}来显示 data-parent 的内容： 
article::before { 
content: attr(data-parent); 
} 
你也同样可以在 CSS 中使用属性选择器根据 data 来改变样式： 
article[data-columns="3"] { 
width: 400px; 
} 
article[data-columns="4"] { 
width: 600px; 
} 
你可以在这个JSBin 里看到全部演示。 
Data 属性同样可以存储不断变化的信息，比如游戏的得分。 
使用 CSS 选择器与 JavaScript 去访问可以让你得到花俏的效果，这里你并不需要用常规的编写方案来编写代码。 
有关使用生成内容和 CSS 转换（JSBin 示例）的示例，请参阅此视频。 
数据值是字符串。 
必须在选择器中引用数值才能使样式生效。 
Issues 
不要在 data attribute 里储存需要显示及访问的内容，因为一些其他的技术可能访问不到它们。 
使用 dataset 会比使用 getAttribute() 读取数据来得慢。 
参见 
该文章源自 Using data attributes in JavaScript and CSS on hacks.mozilla.org. 
在 SVG 2 中也同样支持自定义 data 属性; 请参看{{domxref(“SVGElement.dataset”)}} 和{{SVGAttr(“data-*“)}}. 
How to use HTML5 data attributes (Sitepoint) 

{{LearnSidebar}} 
为了创建一个网站，你需要了解 {{Glossary(‘HTML’)}}——一项用于定义网页结构的基本技术。 
HTML 用于标识你的网页内容是应该被解析为段落、列表、头部、链接、图像、多媒体播放器、表单或是其他众多可用的元素之一，亦或是你定义的新元素。 
标注： 
想要成为一名前端工程师？ 
我们汇总了一门课程，其中包含你实现成为前端工程师目标所需要的所有基本信息。 
从这儿开始 
在开始这个主题的学习之前，你至少要基本熟悉使用电脑和被动地使用网络（即单纯地查看内容）。 
你应该设置好一个基础的工作环境，详细参照安装基础软件，并且理解如何新建和管理文件，详细参照文件处理——这两者都在 web 入门的零基础模块里。 
在尝试学习这个主题之前，建议先完成 web 入门主题，不过这并不是必要的。 
HTML 基础里大多数的文章在 HTML 介绍中也有涉及，不过要详细得多。 
在学习了 HTML 之后，你就可以继续学习其他进阶主题了，例如： 
CSS，以及如何用它装饰 HTML (例如：更改你的文本字号和字体，添加边框和阴影，将你的页面设计成多栏布局，添加动画和其他视觉效果。) 
JavaScript，以及如何用它为网页添加动态功能（例如：找到并在地图上绘制出你的地址，触发按钮时让 UI 元素显示或消失，将用户的数据本地储存在他们的电脑里等等。） 
模块 
这个主题由包含以下模块，建议从第一个开始，按顺序进行学习。 
HTML 介绍 
: 这一模块将为你铺路，帮你习惯一些重要的概念和语法，着眼于如何对文本应用 HTML，创造超链接，以及使用 HTML 构造一个网页。 
多媒体和嵌入 
: 这个模块带你探索如何使用 HTML 在你的网页里如何包含多媒体信息，例如用各种方法包含图片，以及嵌入视频、音频，甚至是嵌入其他完整的网页。 
HTML 表格 
: 在网页上用易于理解和{{glossary(“Accessibility”, “无障碍”)}}的方式来表示表格数据是一项挑战。 
这个模块包括了基本的表格标记及更多复杂的特性，例如实现标题和总结。 
解决常见的 HTML 问题 
使用 HTML 解决常见问题提供了一系列在创建网页过程中可能遇到的常见问题的解决方案：处理标题，添加图片或视频，强调内容，创建一个基础表单等等。 
参见 
web 表单 
: 本模块提供了一系列文章以助你掌握 web 表单的要领。 
web 表单是一种非常强大的用户交互工具–其最常见的应用是收集用户的数据，或允许他们控制用户界面。 
然而，由于历史和技术原因，想要充分发挥他们的潜能并不是一件易事。 
本模块将介绍 web 表单的所有基本要素，包括标记其 HTML 结构、表单控件的样式、验证表单数据以及向服务器提交数据。 
MDN 上的 HTML（超文本标记语言） 
: MDN 上 HTML 相关参考文档的主入口，涵盖了详细的元素和属性参考——比如说如果你想知道一个元素有什么属性或者一个属性有什么值，此页面是一个查询它们的好地方。 






{{LearnSidebar}}{{PreviousMenuNext(“Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML”, “Learn/HTML/Introduction_to_HTML/Creating_hyperlinks”, “Learn/HTML/Introduction_to_HTML”)}} 
HTML 的主要工作之一是赋予文本结构，使浏览器能够按照开发者的意图显示 HTML 文档。 
本文解释了 {{glossary(“HTML”)}} 如何通过添加标题和段落、强调单词、创建列表等方式来构造文本。 
前提： 
阅读 开始学习 HTML，了解基本的 HTML 知识。 

{{LearnSidebar}} 
就其核心而言，{{glossary(“HTML”)}} 是一种相当简单的、由不同{{glossary(“Element”, “元素”)}}组成的标记语言，它可以被应用于文本片段，使文本在文档中具有不同的含义（它是段落吗？ 
它是项目列表吗？ 
它是表格吗？），将文档结构化为逻辑块（文档是否有头部？ 
有三列内容？ 
有一个导航菜单？），并且可以将图片，影像等内容嵌入到页面中。 
本模块将介绍前两个用途，并且介绍一些 HTML 的基本概念和语法。 
前言 
尽管你无需事先拥有任何 HTML 相关知识以学习该模块，你仍至少需要熟悉一些使用电脑的基础知识，并会被动地使用网络（也就是看着它，浏览内容）。 
你需要配置基础的开发环境（详细说明请参见安装基本软件页面），并且懂得如何创建和管理文件（在处理文件页面中有详细说明） —— 它们都是我们纯新手 Web 开发入门模块的一部分。 
备注： 如果你正在一台你不能创建文件的设备上作业，那么你需要在在线编程工具上运行（大多数）代码示例，如 JSBin 或 Glitch 等。 
指南 
本模块包含以下文章，它们将带你了解 HTML 的所有基本理论，并为你提供充分的机会来测试一些技能。 
HTML 入门 
: 涵盖了 HTML 绝对基础知识以帮助你入门——定义元素、属性和其他重要术语，并展示了它们在语言中的位置。 
我们还展示了一个典型的 HTML 页面的结构和一个 HTML 元素的结构，并解释了一些重要的基本语言特征。 
一路下来，我们会与 HTML 一起玩耍，以激发你的兴趣！ 
head 标签中有什么？ 
HTML 中的元数据 
: 当页面被加载后，HTML 中的 head 部分是不会被显示在 Web 浏览器中的。 
它包含了许多信息，例如网页的标题 {{htmlelement(“title”)}}，指向 {{glossary(“CSS”)}} 的链接（如果你使用 CSS 来设计 HTML 内容的样式的话），指向自定义网站图标的链接和一些元数据（关于 HTML 本身的数据，例如它的作者和描述这个文档的关键字）。 
HTML 文本处理基础 
: HTML 的主要工作之一就是给予文本意义（也被叫做{{glossary(“Semantics”, “语义”)}}），以让浏览器知道如何正确的显示文本。 
这篇文章关注于如何用 HTML 将文本块分解为结构化的标题和段落、强调和加粗单词、创建列表以及其他内容。 
创建超链接 
: 超链接真的很重要——它们是“web”的意义所在。 
本文展示了创建超链接所需的语法，并讨论了创建超链接的最佳做法。 
高级文本排版 
: HTML 中还有许多没有在 HTML 文本处理基础页面中提到的其他元素可以用于排版文本。 
这里的元素不太为人所知，但了解这些元素仍然很有用。 
在这篇文章里，你将学习如何标记引文、描述列表、计算机代码和其他类似的文本、下标和上标、联系信息等。 
文档和网站结构 
: 除了定义页面的个别部分（例如“段落”或“图像”）外，HTML 也被用于定义网站的区域（例如“标题”、“导航菜单”和“主要内容”）。 
本文将探讨如何规划一个基本的网站结构，以及如何编写 HTML 来表示这个结构。 
调试 HTML 
: 光是编写 HTML 还好，但如果出了什么问题，而你找不到问题的来源怎么办？ 
本文将介绍一些可以帮上忙的工具。 
测验 
以下测验将测试你对上述指南中 HTML 基础知识的理解程度。 
标记信件 
: 我们迟早都要学会如何写信，而这也对测试我们的排版技能很有用！ 
在这个测验中，你需要标记一封信。 
结构化页面内容 
: 此测验将测试你能否使用 HTML 构建简单的内容页面，其中包含页眉、页脚、导航菜单、主要内容和侧边栏。 





body { 
font-family: "微软雅黑", Helvetica, Arial, sans-serif; 
margin: 10px; 
background: #f5f9fa; } 
h2 { 
font-size: 16px; 
} 
code, textarea { 
font-family: Consolas, Menlo, monospace; } 
.output { 
min-height: 200px; } 
.input { 
min-height: 100px; 
width: 95%; 
} 
.a11y-label { 
text-align: right; 
font-size: 0.7rem; 
width: 98%; } 
.controls { 
width: 96%; 
text-align: right; 
} body { 
font-family: "微软雅黑", Helvetica, Arial, sans-serif; 
margin: 10px; background: #f5f9fa; } 
h2 { 
font-size: 16px; 
} code, 
textarea { 
font-family: Consolas, Menlo, monospace; 
} .output { 
min-height: 200px; } 
.input { 
min-height: 100px; 
width: 95%; 
} 
.a11y-label { 
margin: 0; 
text-align: right; 
font-size: 0.7rem; 
width: 98%; 
.controls { 
width: 96%; 
text-align: right; } 
{{LearnSidebar}}{{NextMenu(“Learn/HTML/Multimedia_and_embedding/Video_and_audio_content”, “Learn/HTML/Multimedia_and_embedding”)}} 
在一开始时，Web 仅有文本，那真的是很无趣。 
幸运的是，没过多久网页上就能嵌入图片和其他有趣的内容了。 
虽然还有许多其他类型的多媒体，但是从地位比较低的{{htmlelement(“img”)}}元素开始是符合逻辑的，它常常被用来在网页中嵌入一张简单的图片。 
在这篇文章中，我们将看到怎样深入的使用它，包括基本的用{{htmlelement(“figure”)}}来添加说明文字，以及怎样把它和 CSS 背景图片链接起来。 
前提： 
掌握基本的电脑知识，安装基本软件，基本的文件处理知识，熟悉HTML 基础 
学习目标： 
学习如何在 HTML 页面插入简单的图片，为图片添加简单的说明，以及 CSS 背景图片与 HTML 图片的关系。 

{{LearnSidebar}} 
在这份教程中，到目前为止我们已经看到了许多的文字了。 
但是网页除了文本之外什么都没有，真的非常无聊，所以，让我们开始看看怎样用更多有趣的内容让网页动起来！ 
本模块要探索怎样用 HTML 来让你的网页包含多媒体，包括可以包含图像的不同方式，以及怎样嵌入视频，甚至是整个其他的网页。 
标注： 
想要成为一名前端工程师？ 
我们汇总了一门课程，其中包含你实现成为前端工程师目标所需要的所有基本信息。 
从这儿开始 
预备知识 
在你开始本模块之前，你应该已经拥掌握了关于 HTML 的基础知识，就是之前在HTML 简介中所述内容。 
如果你还没有看过那个模块（或者类似的），先去看看，然后再回来吧！ 
备注： 如果你正在一台你不能创建文件的设备上作业，那么你需要在在线编程工具上运行（大多数）代码示例，如 JSBin 或 Glitch 等。 
指南 
本模块包含以下的文章，你会了解到所有在网页上关于嵌入多媒体的基础知识。 
HTML 中的图片 
: 有一些其他类型的多媒体要考虑，但是从简单的 {{htmlelement(“img”)}} 元素开始是符合逻辑的，它常常被用来在网页中嵌入一个简单的图片。 
在这篇文章中，我们要看看怎样更深入的使用它，包括基础知识，使用 {{htmlelement(“figure”)}} 来为图片增加说明，以及怎样把它关联到 CSS 背景图片。 
视频和音频内容 
: 接下来，我们将看看怎样在我们的页面上用 HTML5 的 {{htmlelement(“video”)}} 和{{htmlelement(“audio”)}} 元素来嵌入视频和音频；包括基础知识，向不同的浏览器提供不同文件格式的访问方式，增加标题和副标题，以及增加对过时的浏览器的兼容。 
从 <object> 到 <iframe>——其他嵌入技术 
: 在这一节，我们将来了解一些另辟蹊径的内容，看一组元素，它们可以让你在页面中嵌入许多不同类型的内容： {{htmlelement(“iframe”)}}, {{htmlelement(“embed”)}} 和 {{htmlelement(“object”)}} 元素。 <iframe> 用来嵌入其他网页，而另外两者可以帮助你嵌入 PDF, SVG, 甚至是 Flash——一种逐渐退出历史舞台的技术，不过也许你还是能时不时的看到它。 
在页面中添加矢量图像 
: 矢量图像在一些特定场景中非常有用。 
不同于常见的格式，比如 PNG/JPG, 它们不会在放大的时候变得扭曲或者显示出像素格——它们可以在缩放时保持光滑。 
本文将为你介绍什么是矢量图像，以及如何在网页中添加流行的 {{glossary(“SVG”)}} 格式图像。 
响应式图片 
: 现在有许多不同的设备类型能够浏览网络——从手机到台式电脑——在现代网络世界中掌握的一个基本概念就是响应式设计。 
这是指创建可以自动更改其功能以适应不同屏幕尺寸，分辨率等的网页。 
稍后将在 CSS 模块中详细介绍这一点，但是现在我们将看看 HTML 可用于创建响应式图像的工具，包括 {{htmlelement(“picture”)}} 元素。 
测验 
以下测验将测试你对上述指南中涵盖的 HTML 基础知识的理解： 
Mozilla 启动页面 
: 在这个测验中，我们将测试你对本模块文章中讨论的一些技巧的了解，让你将一些图像和视频添加到一个关于 Mozilla 的时髦的页面！ 
参见 
在图像的顶部添加一个点阵图 
: 图像映射提供了一种机制，使图像的不同部分链接到不同的地方（想想地图，链接到有关你点击的每个不同国家的更多信息。） 
这种技术有时可能是有用的。 
网络素质基础 2) 
: 一个优秀的 Mozilla 基础课程，探讨并测试了多媒体和嵌入模块中谈到的一些技巧。 
深入了解撰写网页的基础知识，设计无障碍，共享资源，使用在线媒体和开放工作。 

{{LearnSidebar}}{{PreviousMenu(“Learn/HTML/Multimedia_and_embedding/Responsive_images”, “Learn/HTML/Multimedia_and_embedding”)}} 
在这个测验中，我们将测试你对于本模块文章所讨论的技术的掌握程度，让你将一些有关于 Mozilla 的图片和视频添加到一个漂亮的页面上！ 
前提： 
在开始这个测验之前，你应该了解了 多媒体与嵌入 模块的其他文章。 






{{LearnSidebar}} 
在 HTML 中一个很普通的任务是构建表格数据，有大量的元素和属性是来满足这种需求的。 
只需要一点儿的 CSS 来设定风格，HTML 让在 web 上显示表格数据变的很容易，例如你的学校的教学计划，你当地的游泳馆的时刻表，或者是关于你最爱的恐龙或足球队的统计数据。 
这个模块会教给你所有你需要知道的关于用 HTML 构建表格数据的知识。 
标注： 
想要成为一名前端工程师？ 
我们汇总了一门课程，其中包含你实现成为前端工程师目标所需要的所有基本信息。 
从这儿开始 
预备知识 
如果你还没有看过那个模块（或者类似的），先去看看，然后再回来吧！ 
备注： 如果你正在一台你不能创建文件的设备上作业，那么你需要在在线编程工具上运行（大多数）代码示例，如 JSBin 或 Glitch 等。 
指南 
本模块包含以下的文章，你将了解在 HTML 中创建表格的所有知识。 
HTML 表格基础 
: 本文将帮助你学习如何使用 HTML 格式，包括如行、列、表头、跨列的行或跨行的列等基本特性，以及如何将多行进行分组进行样式化。 
HTML 表格高级功能与无障碍 
: 在本模块第二篇文章中，我们将了解一些 HTML 表格的高级功能——比如表名称/表摘要，因为无障碍的原因，将表格内容划分为表头、主体以及脚部等章节。 
测验 
构造行星的数据结构 
: 在表格的测验中，我们向你提供了一些在我们太阳系的行星的数据，不妨你把它构造成一个 HTML 的表格吧。 

{{LearnSidebar}}{{PreviousMenu(“Learn/HTML/Tables/Advanced”, “Learn/HTML/Tables”)}} 
在我们的表格评定中，我们为你提供有关太阳系中行星的一些数据，并让你将其结构化成 HTML 表。 
前提： 

{{LearnSidebar}} 
欢迎来到 MDN 学习区。 
本系列文章旨在为零基础 Web 开发初学者提供指导和开始编写网站代码所需的所有内容。 
该教程并不是“从入门到精通”类型的教程，只能让你做到“从入门到适应”。 
在此之后，你应该能够以你自己的方式学习 MDN 的其他内容，并接触到其他中、高级资源。 
从零开始学习 Web 开发极具挑战性，该教程将为你提供详细的资料，手把手帮助你轻松愉快地学习。 
无论你是正在学习 Web 开发的学生（自学或参与课程）、寻找材料的老师、编程爱好者，亦或是仅仅想了解一点点 Web 技术，我们都希望你能感到宾至如归。 
标注： 
想要成为一名前端工程师？ 
我们汇总了一门课程，其中包含你实现成为前端工程师目标所需要的所有基本信息。 
点击开始 
学习起点 
零基础的初学者 
: 如果你完全没有 Web 开发经验，那么我们推荐从 Web 入门部分开始，该部分教程通过实践的方式向你介绍 Web 开发。 
有一定基础 
: 如果你已经具备了一定的开发知识，下一步就是深入学习 {{glossary(“HTML”)}} 和 {{glossary(“CSS”)}}。 先学习 HTML 入门，再学习 CSS 初步。 
学习脚本编写 
: 如果你已经完成了 HTML 和 CSS 入门课程，或是主要对编写代码感兴趣，可以继续学习 {{glossary(“JavaScript”)}} 或服务端开发。 
可通过 JavaScript 初步和服务端编程的第一步开始学习。 
框架与工具 
: 在掌握了原生 HTML、CSS、JavaScript 的要领后，就可以继续学习前端开发工具课程，并考虑开始研究 JavaScript 前端框架，以及网站服务端编程了。 
备注： 可在术语表中查询术语。 
此外，如果你对 Web 开发有具体问题，可以尝试在常见问题寻找答案。 
涵盖的主题 
以下列表包含了 MDN 学习区涵盖的所有主题： 
Web 入门 
: 为零基础初学者提供实用的 Web 开发入门简介。 
HTML 构建网站 
: HTML 是用于构建网页的内容并定义其含义或目的的语言。 
该专题将详细讲解 HTML。 
CSS 风格化站点 
: CSS 是用于对网页内容进行设计、布局或添加动画等行为的语言。 
该专题对 CSS 进行了全面介绍。 
JavaScript - 动态客户端脚本语言 
: JavaScript 是用于向网页添加动态功能的脚本语言。 
该专题涵盖有关编写和理解 JavaScript 代码所需的所有重点。 
Web 表单 - 操作用户数据 
: Web 表单是用于进行用户交互的强大工具 —— 其常用于收集用户数据和控制用户界面。 
该专题将对 Web 表单的结构、样式、交互要点进行介绍。 
无障碍 - 让每个人都能畅游网络 
: “无障碍”（Accessibility）是开发人员对让更多的人能够不受残疾、设备、地区等因素的限制访问 Web 内容做出的努力。 
该专题包含一切所需了解的信息。 
Web 性能优化 - 让网站更快做出响应 
: Web 性能是确保网络应用的快速下载并对用户操作进行快速响应的艺术，而无论用户的带宽大小、屏幕尺寸、网络状态好坏或是设备性能高低。 
工具与测试 
: 该专题涵盖了开发人员常用的效率工具，如跨浏览器测试工具、代码检查工具、代码格式化工具、转换工具、版本控制系统、部署工具、客户端 JavaScript 框架等。 
服务器端网站编程 
: 即使你专注于客户端的 Web 开发，了解服务器和服务端代码的运行机制仍然很有用。 
该专题简单介绍了服务端的运作机制，并包含了两份分别有关使用 Django（Python）和 Express（node.js）两个流行框架构建服务器端应用的教程。 
获取代码示例 
学习区的所有代码示例都可以在 GitHub 上的 MDN 学习区示例中文版 上寻得。 
如果你想把获取所有代码示例的副本，直接 包含最新 master 分支内容的压缩文件 即可。 
如果你希望以更灵活的方式复制代码仓库并随时更新本地副本，可参考以下更复杂的步骤： 
在电脑上安装 Github 底层使用的版本控制系统 Git。 
打开操作系统的命令提示符（Windows）或终端（Linux、macOS）。 
在命令提示符 / 终端中输入以下命令，即可将 roy-tian/learning-area 仓库拷贝到本地的 learning-area 文件夹： 
git clone https://github.com/roy-tian/learning-area 
然后即可使用访达（macOS）、文件资源管理器（Windows/Linux）或 cd 命令) 进入该目录，查找所需文件。 
你可以随时对本地 learning-area 目录与 GitHub 仓库中的 master 分支进行同步，具体步骤如下： 
在命令提示符 / 终端中使用 cd 指令进入 learning-area 文件夹。 
例如，当你在父目录时： 
cd learning-area 
执行以下命令以更新仓库： 
git pull 
联系我们 
如果你想就任何事宜联系我们，最好的方式是在论坛上留言。 
如果你认为网站上有任何错误或遗漏、请求新的学习主题、针对你不理解的部分请求帮助、或提出任何其他问题，我们都期待听到你的意见。 
如果你有兴趣帮助我们开发或改进社区内容，请阅读如何做出贡献部分并联系我们！ 
无论你是学生、老师、经验丰富的 Web 开发者、还是其他有兴趣通过帮助我们以提升自学经验的人，我们都不胜荣幸！ 
参见 
Mozilla 开发者新闻通讯 
: 我们为 Web 开发者编写的新闻报，对各水平开发者而言都是优秀的资源。 
学习 JavaScript 
: 为有进取心的 Web 开发人员准备的优秀资源——在互动环境中学习 JavaScript，其包含由自动评估系统提供指引的简短的课程和互动测试。 
前 40 节课为免费课程，而想要购买完整的付费课程只需一次性支付少量费用。 
揭开 Web 的面纱 
: 面向 Web 开发的零基础教学视频系列，由 Jérémie Patonnier 出品。 
Codecademy 
: 用于从零学习编程语言的优秀交互式网站。 
BitDegree 
: 用游戏的方式学习基础编程理论。 
主要针对初学者。 
Code.org 
: 基本的编程理论和实践，主要针对儿童与完全的初学者。 
EXLskills 
: 免费开放的学习技术技能的课程，由导师指导和基于项目的学习。 
freeCodeCamp.org 
: 用于学习 Web 开发的交互式网站，带有教程和项目。 
Web 学习路线图 
: 用于学习入门级 Web 开发素养与新时代常用技能，另分门别类地提供教学活动。 
Edabit 
: 上千个 JavaScript 交互式编程挑战。 


{{LearnSidebar}} 
在这个模块，我们将查看{{Glossary(“asynchronous”, “异步”)}} {{Glossary(“JavaScript”)}}，异步为什么很重要，以及怎样使用异步来有效处理潜在的阻塞操作，比如从服务器上获取资源。 
标注： 
想成为一名前端工程师？ 
我们汇总了一门课程，其中包含你实现目标所需要的所有基本信息。 
点击开始 
预备知识 
异步 JavaScript 是一个相当高级的话题，建议你先完成 JavaScript 第一步和创建 JavaScript 代码块 两个模块的学习后再来学习。 
备注： 如果你工作在一个无权创建自己文件的电脑/平板/其他设备上，你需要在一个在线编程工具上试验（大多数）代码示例，如 JSBin 或者 Glitch. 
指南 
异步 JavaScript 简介 
: 在这篇文章中我们将介绍 同步编程 和 异步编程 是什么，为什么我们总是需要异步编程技术，异步函数过去是怎样在 JavaScript 上实现的，以及这些方式的问题有哪些。 
如何使用 Promise 
: 我们将在这里介绍 Promise 并向你展示如何使用基于 Promise 的 API。 
我们也会介绍 async 和 await 关键字。 
应用一个基于 Promise 的 API 
: 本文概述了如何实现一个我们自己的基于 Promise 的 API。 
Worker 简介 
: Worker 使你能够在独立的线程中运行任务来保持你的主要代码的可响应性。 
在这篇文章中我们将把一个长时间运行的同步函数重写为使用 Worker 的示例。 
测验 
序列动画 
: 这个测验要求你使用 Promise 来播放一组特定序列的动画。 
参见 
由 Marijn Haverbeke 编写的电子书籍 Eloquent JavaScript 中的 异步编程。 

{{LearnSidebar}}{{NextMenu(“Learn/JavaScript/Asynchronous/Promises”, “Learn/JavaScript/Asynchronous”)}} 
在本文中，我们将解释什么是异步编程，为什么我们需要它，并简要讨论 JavaScript 历史上异步函数是怎样被实现的。 
前提： 
基本的计算机素养，以及对 JavaScript 基础知识的一定了解，包括函数和事件处理程序。 









{{LearnSidebar}} 
在这个模块中，我们将继续介绍 JavaScript 的关键基本特性，在这一章中我们将关注条件控制语句、循环语句、函数模块、事件等通用代码块。 
你可能在之前的的课程中见过这些模块，但仅仅是见过—在这篇模块中我们将明确讨论这些模块。 
预备知识 
在开始这部分模块之前，你应该熟悉基本的 HTML 和 CSS, 并且已经看完我们之前的模块：JavaScript 第一步。 
备注： 如果你在使用无法创建自己文件的电脑/平板/其他设备,你可以试试在线编辑器，例如 JSBin 或 Glitch. 
指南 
在代码中做决定 — 条件 
: 在任何程序语言中，程序需要根据不同的输入数据作出相应的选择并执行相关的操作。 
例如，在游戏中，如果玩家的生命值是 0，那么游戏就结束了。 
在天气应用中，如果在早上打开应用，则显示一个太阳升起的图片，如果在晚上打开，则显示星星和月亮。 
在这篇文章里我们将探索如何在 JS 中使用条件结构。 
循环语句 
: 有时候你需要在一个行中重复执行某一个任务。 
例如，查看一整列的名字。 
在程序中，循环能非常好的处理好这个问题。 
在本章中我们将介绍 JavaScript 的循环语句。 
函数 — 可重用的代码块 
: 在编码中的另一个基本概念是函数 (functions)。 
函数 允许你在定义的区块内存储一段代码用来执行一个单独的任务，然后调用该段代码时，你需要使用一个简短的命令，而不用重复编写多次该段代码。 
在这篇文章中我们将探讨函数的基本概念，如语法、如何调用定义的函数、作用域和参数。 
打造自己的函数 
: 本文结合前几篇文章中所涉及的基本理论，提供了一个实践经验。 
在这里你会得到一些实践，并且编写自己的自定义函数。 
随后，我们也将进一步解释一些与函数相关的有用的细节。 
函数返回值 
: 在这个课程中，我们要讨论的最后一个基本概念是返回值（通过返回值结束我们的函数）。 
有些函数在完成后不返回任何值，而有些函数返回。 
重要的是了解返回的值是什么，和如何在你的代码中使用他们，以及如何使自定义的函数返回需要的值。 
事件介绍 
: 事件是你正在编写的系统中发生的动作或事件，系统告诉你的是这些动作或事件，如果需要的话，你可以以某种方式对它们做出反应。 
例如，如果用户单击网页上的按钮，你可能希望通过显示信息框来响应该操作。 
在这最后一篇文章中，我们将重点讨论一些围绕事件有关的概念，看看他们如何在浏览器中工作。 
评估 
下面的评估将测试你对 JavaScript 基础知识的理解。 
图片画廊 
: 现在我们已经学习了构建 JavaScript 的基本代码块，我们会通过构建一个在很多网站上相当常见的项目——一个由 JavaScript 驱动的相册，来测试你循环、函数、条件语句和事件方面的知识。 


{{LearnSidebar}}{{PreviousMenuNext(“Learn/JavaScript/Building_blocks/Build_your_own_function”,“Learn/JavaScript/Building_blocks/Events”, “Learn/JavaScript/Building_blocks”)}} 
函数返回值 - 是本章中最后一个基础概念，让我们一起来瞧瞧.。 
有些函数在执行完毕后不会返回一个有用的值，但有些会，重要的是理解返回的是什么，怎样使用这些值在你的代码中，我们将在下面讨论这些。 
前提： 
基础的计算机知识，懂得基础的 HTML 和 CSS, JavaScript 第一步学习，函数- 可重用的代码块。 
目标： 
理解什么函数的返回值 , 和如何使用它们 
什么是返回值？ 
返回值意如其名，是指函数执行完毕后返回的值。 
你已经多次遇见过返回值，尽管你可能没有明确的考虑过他们。 
让我们一起回看一些熟悉的代码： 
var myText = "I am a string"; 
var newString = myText.replace("string", "sausage"); 
console.log(newString); 
// the replace() string function takes a string, 
// replaces one substring with another, and returns 
// a new string with the replacement made 
在第一篇函数文章中，我们确切地看到了这一块代码。 
我们对 myText 字符串调用 replace() 功能，并通过这两个参数的字符串查找，和子串替换它。 
当这个函数完成（完成运行）后，它返回一个值，这个值是一个新的字符串，它具有替换的功能。 
在上面的代码中，我们保存这个返回值，以作为newString变量的内容。 
如果你看看替换功能 MDN 参考页面，你会看到一个返回值。 
知道和理解函数返回的值是非常有用的，因此我们尽可能地包含这些信息。 
一些函数没有返回值就像 (在我们的参考页中，返回值在这种情况下被列出为空值 void 或未定义值 undefined 。). 
例如，我们在前面文章中创建的 displayMessage() function , 由于调用的函数的结果，没有返回特定的值。 
它只是让一个提示框出现在屏幕的某个地方——就是这样！ 
通常，返回值是用在函数在计算某种中间步骤。 
你想得到最终结果，其中包含一些值。 
那些值需要通过一个函数计算得到，然后返回结果可用于计算的下一个阶段。 
在自定义的函数中使用返回值 
要从自定义函数返回值，你需要使用…等待它… return 关键字。 
我们最近在random-canvas-circles.html示例中看到了这一点。 
我们的 draw() 函数绘制 100 随机圆在 HTML 的{{htmlelement(“canvas”)}}: 
function draw() { 
ctx.clearRect(0, 0, WIDTH, HEIGHT); 
for (var i = 0; i < 100; i++) { 
ctx.beginPath(); 
ctx.fillStyle = "rgba(255,0,0,0.5)"; 
ctx.arc(random(WIDTH), random(HEIGHT), random(50), 0, 2 * Math.PI); 
ctx.fill(); 
} 
} 
在每个循环迭代，random()函数调用了三次，分别生成当前圆的 x 坐标，一个随机值 Y 坐标和半径。 
random()函数接受一个参数 - 一个整数，返回 0 到这个整数之间的随机数。 
看起来像这样： 
function randomNumber(number) { 
return Math.floor(Math.random() * number); 
} 
这也可以写成下面这样： 
function randomNumber(number) { 
var result = Math.floor(Math.random() * number); 
return result; 
} 
但是第一个版本写得更快，而且更紧凑。 
我们每次调用函数都返回Math.floor(Math.random()*number)计算的数学结果。 
这个返回值出现在调用函数的位置上，并且代码继续。 
例如，如果我们运行下面的行： 
ctx.arc(random(WIDTH), random(HEIGHT), random(50), 0, 2 * Math.PI); 
这三次random()调用分别返回值 500, 200 和 35，实际上这一行这样运行： 
ctx.arc(500, 200, 35, 0, 2 * Math.PI); 
在运行该行之前，首先运行该行上的函数调用，并用其返回值替换该函数调用。 
主动学习：我们自己的返回值函数 
让我们着手编写具有我们自己的返回值的函数。 
首先，从 GitHub 的function-library.html文件复制一份本地副本。 
这是一个简单的 HTML 页面包含一个 {{htmlelement(“input”)}} 文本域和一个段落。 
还有一个 {{htmlelement(“script”)}} 元素，我们在两个变量中存储了对两个 HTML 元素的引用。 
这个小页面允许你在文本框中输入一个数字，并在下面的段落中显示不同的数字。 
在现有的两行 JavaScript 下面，添加以下函数定义： 
function squared(num) { 
return num * num; 
} 
function cubed(num) { 
return num * num * num; 
} 
function factorial(num) { 
var x = num; 
while (x > 1) { 
num *= x - 1; 
x--; 
} 
return num; 
} 
squared() 和 cubed() 功能是相当明显的 - 他们的平方或立方的数作为一个参数返回。 
factorial() 函数返回给定数字的阶乘。 
接下来，我们将包括一种打印输入到文本输入中的数字的信息的方法。 在现有函数下面输入以下事件处理程序： 
input.onchange = function () { 
var num = input.value; 
if (isNaN(num)) { 
para.textContent = "You need to enter a number!" 
; 
} else { 
para.textContent = num + 
" squared is " + squared(num) + ". " + num + " cubed is " + cubed(num) + ". " + 
num + " factorial is " + factorial(num) + "."; 
} 
}; 
这里我们创建一个onchange事件处理程序，当文本框上面的 change 事件被触发的之后，事件处理程序就会运行 - 就是说，一个新的值被输入到文本框并且被提交（就比如，输入一个值，然后按 Tab）。 
当这个匿名函数运行时，输入框中的值将被存储在num变量中。 
接下来，我们进行条件测试——如果输入的值不是数字，则在段落中打印错误消息。 
if 语句判断isNaN(num)表达式是否返回 true。 
我们用isNaN()函数测试num的值是否不是一个数字 - 如果不是数字，就返回true，否则返回false。 
如果测试返回 false，则数值是一个数字，所以我们在段落元素中打印出一个句子，说明数字的平方、立方体和阶乘是什么。 
这句话叫 squared()，cubed()，和 factorial() 函数来获得所需的值。 
保存你的代码，将其加载到浏览器中，然后尝试。 
备注： 如果你有麻烦让例子工作，对比GitHub 的已完成版检查你的代码（或看它在线运行），或寻求我们的帮助。 
在这一点上，我们希望你编写一个自己的几个函数，并将它们添加到库中。 
这个数的平方根或立方根，或一个圆的周长和半径是多少？ 
这个练习提出了一些重要的观点，除了研究如何使用返回语句之外。 
查看另一个将错误处理写入函数的示例。 
它是否提供了任何必要的参数通常是一个好主意，另一方面对可选参数提供默认值。 
这样，你的程序就不太可能出错了。 
关于创建函数库思想的思考。 
随着你深入到你的编程生涯，你将开始一次又一次地做同样的事情。 
这是一个好主意，开始保持你自己的实用工具库，你经常使用 - 你可以把它们复制到你的新代码，甚至只是把它应用到任何你需要的 HTML 页面。 
结论 
因此，我们让它 - 功能是有趣的，非常有用的，虽然有很多要谈论他们的语法和功能，相当容易理解的正确的文章学习。 
如果你有什么不明白的地方，可以再通读一遍，或者联系我们寻求帮助。 
参见 
Functions in-depth — 详细介绍更多高级功能相关信息的指南。 
Callback functions in JavaScript — 一个常见的 JavaScript 模式是把一个函数传递给另一个函数作为参数，然后在第一个函数中调用它。 
这有点超出了这门课的范围，但值得学习很久。 
{{PreviousMenuNext(“Learn/JavaScript/Building_blocks/Build_your_own_function”,“Learn/JavaScript/Building_blocks/Events”, “Learn/JavaScript/Building_blocks”)}} 

{{LearnSidebar}} 
{{PreviousMenu(“Learn/JavaScript/Client-side_web_APIs/Video_and_audio_APIs”, “Learn/JavaScript/Client-side_web_APIs”)}} 
现代 web 浏览器提供了很多在用户电脑 web 客户端存放数据的方法 — 只要用户的允许 — 可以在它需要的时候被重新获得。 
这样能让你存留的数据长时间保存，保存站点和文档在离线情况下使用，保留你对其站点的个性化配置等等。 
本篇文章只解释它们工作的一些很基础的部分。 
Prerequisites: 
JavaScript 基础 (查看 第一步, 构建的块, JavaScript 对象), 基础的客户端 API 
Objective: 
学习如何使用客户端存储 API 来存储应用数据。 



{{LearnSidebar}} 
当你给网页或者网页应用编写客户端的 JavaScript 时，你很快会遇上应用程序接口（API）—— 这些编程特性可用来操控网站所基于的浏览器与操作系统的不同方面，或是操控由其他网站或服务端传来的数据。 
在这个单元里，我们将一同探索什么是 API，以及如何使用一些在你开发中将经常遇见的 API。 
预备知识 
若想深入理解这个单元的内容，你必须能够以自己的能力较好地学完之前的几个章节 (JavaScript 第一步, JavaScript基础要件, 和JavaScript对象介绍). 
这几部分涉及到了许多简单的 API 的使用，如果没有它们我们将很难做一些实际的事情。 
在这个教程中，我们会认为你懂得 JavaScript 的核心知识，而且我们将更深入地探索常见的网页 API。 
若你知道 HTML 和 CSS 的基本知识，也会对理解这个单元的内容大有裨益。 
备注： 如果你正在使用一台无法创建你自身文件的电脑、平板或其他设备，你可以尝试使用一些在线网页编辑器如JSBin或者Glitch，来尝试编辑一些代码示例。 
向导 
Web API 简介 
: 首先，我们将从一个更高的角度来看这些 API —它们是什么，它们怎么起作用的，你该怎么在自己的代码中使用它们以及他们是怎么构成的？ 
我们依旧会再来看一看这些 API 有哪些主要的种类和他们会有哪些用处。 
操作文档 
: 当你在制作 WEB 页面和 APP 时，一个你最经常想要做的事就是通过一些方法来操作 WEB 文档。 
这其中最常见的方法就是使用文档对象模型 Document Object Model (DOM)，它是一系列大量使用了 {{domxref(“Document”)}} object 的 API 来控制 HTML 和样式信息。 
通过这篇文章，我们来看看使用 DOM 方面的一些细节，以及其他一些有趣的 API 能够通过一些有趣的方式改变你的环境。 
从服务器获取数据 
许多大网站如 Google Maps, Twitter, Facebook, PayPal 等，都提供他们的 API 给开发者们去使用他们的数据（比如在你的博客里展示你分享的推特内容）或者服务（如在你的网页里展示定制的谷歌地图或接入 Facebook 登录功能）。 
这篇文章提供了部分 canvas 的简介，以及让你更深入学习的资源。 
视频和音频 API : HTML5 能够通过元素标签嵌入富媒体——{{htmlelement(“video”)}} and {{htmlelement(“audio”)}}——而将有自己的 API 来控制回放，搜索等功能。 
本文解释了这些功能的基本原理。 

{{LearnSidebar}}{{NextMenu(“Learn/JavaScript/Client-side_Web_APIs/Manipulating_documents”, “Learn/JavaScript/Client-side_web_APIs”)}} 
首先，我们将从一个高层次看看 API - 它们是什么；他们如何工作；如何在代码中使用它们，以及它们是如何组织的。 
我们也将看看不同主要类别的 API 以及它们的用途。 
前提： 
基本计算机知识，对于 HTML 和 CSS 的基本理解（见JavaScript 第一步，创建 JavaScript 代码块，JavaScript 对象入门）。 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/JavaScript/Client-side_web_APIs/Introduction”, “Learn/JavaScript/Client-side_web_APIs/Fetching_data”, “Learn/JavaScript/Client-side_web_APIs”)}} 
在编写网页和应用程序时，你最想做的事情之一是以某种方式操纵文档结构。 
这通常是通过使用文档对象模型（DOM）来实现的，这是一套用于控制 HTML 和样式信息的 API，大量使用了 {{domxref(“Document”)}} 对象。 
在这篇文章中，我们将详细了解如何使用 DOM，以及其他一些有趣的 API，它们可以以有趣的方式改变你的环境。 
预备条件： 
基础的计算机常识，基本了解 HTML、CSS 和 JavaScript，包括 JavaScript 对象。 





{{LearnSidebar}} 
在第一个 JavaScript 板块，带领各位体验编写 JavaScript 程序前，首先回答一些基本问题：「什么是 JavaScript？」，「它看上去是什么样的？」，「它能做什么？」。 
此后，我们将详细讨论一些关键构件，例如变量、字符串、数值和数组。 
事前准备 
学习这个板块前，你不需要预先了解任何 JavaScript 知识，但你应当对 HTML 和 CSS 有所熟悉。 
我们建议学习 JavaScript 前，先完成以下板块阅读： 
开始使用 Web（包括 JavaScript 基础简介）。 
HTML 简介。 
CSS 简介。 
备注： 如果你无法在你使用的电脑/平板/其他设备上创建自己的文件，尝试使用在线编程应用来运行（大部分）代码示例，例如 JSBin 和 Glitch。 
学习指南 
什么是 JavaScript？ 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/JavaScript/First_steps/Variables”, “Learn/JavaScript/First_steps/Strings”, “Learn/JavaScript/First_steps”)}} 
在本次课程中，我们讨论 JavaScript 中的数学 — 我们如何使用 {{Glossary(“Operator”,“运算符”)}} 和其他功能来成功地操作数字以完成我们的请求。 
前提： 
基本的计算机知识，对 HTML 和 CSS 初步了解，知道 JavaScript 是什么。 

body { 
font-family: helvetica, sans-serif; 
width: 350px; 
border: 1px solid; 
padding: 1em; 
} label { 
font-weight: bold; } 
div { padding-bottom: 20px; } 
input[type="text"] { 
padding: 5px; 
width: 150px; } p { 
background: #ffc125; 
color: #5e2612; 
padding: 10px; 
visibility: hidden; } 
{{LearnSidebar}}{{PreviousMenu(“Learn/JavaScript/First_steps/Arrays”, “Learn/JavaScript/First_steps”)}} 
本节是一个小测验，要求你运用所学知识制作一个笑话生成器。 
祝玩的愉快！ 
前提： 
请读完本章所有小节的内容后再开始这个测验。 

} 
html { background-color: #0c323d; 
color: #809089; 
font-family: monospace; } body { max-width: 700px; } p { 
margin: 0; 
width: 1%; padding: 0 1%; 
font-size: 16px; 
line-height: 1.5; float: left; 
} 
.input p { margin-right: 1%; } .output p { width: 100%; 
} .input input { 
font-size: 16px; line-height: 1.5; 
font-family: monospace; padding: 0; 
background: #0c323d; color: #809089; } 
div { clear: both; } 
{{LearnSidebar}}{{PreviousMenuNext(“Learn/JavaScript/First_steps/Math”, “Learn/JavaScript/First_steps/Useful_string_methods”, “Learn/JavaScript/First_steps”)}} 
接下来，我们将把注意力转向文本片段——也就是编程中所说的字符串。 
前提： 
基本的计算机读写能力，对 HTML 和 CSS 的基本理解，对 JavaScript 的理解。 

{{learnsidebar}} 
本测试旨在评估读者对 存储所需信息 - 变量 一文的理解程度。 
备注： 可在下文的互动编辑器中尝试完成评估，也可借助 CodePen、jsFiddle、Glitch 等在线编程实用工具完成任务。 
备注： 以下示例中，如果代码存在错误，将在互动编译器的输出框中显示提示信息来帮助你完成，（如果使用下载版本，则在浏览器的 JavaScript 控制台显示） 
变量 1 
let para1 = document.createElement('p'); 
para1.textContent = myName; 
let para2 = document.createElement('p'); para2.textContent = myAge; 
section.appendChild(para1); section.appendChild(para2); 
<input id="reset" type="button" value="Reset" /> 
{{ EmbedLiveSample('变量 1', '100%', 420, '', '', 'hide-codepen-jsfiddle') }} 
> **标注：** [下载 任务 1 的起始版本](https://github.com/roy-tian/learning-area/blob/master/javascript/introduction-to-js-1/tasks/variables/variables1-download.html)，然后使用你自选的编辑器完成任务。 ## 变量 2 
<title>变量：任务2</title> <link 
href="https://roy-tian.github.io/learning-area/javascript/introduction-to-js-1/tasks/styles.css" /> </head> <body> 
<textarea class="playable playable-js" style="height: 220px;"> 
{{ EmbedLiveSample(‘变量 2’, ‘100%’, 360, ’‘,’‘, ’hide-codepen-jsfiddle’) }} 
岁。” 
尝试更新下方互动编辑器中的代码来实现预期效果： ```html hidden 
变量：任务3 
let para1 = document.createElement('p'); 
let para2 = document.createElement('p'); para1.textContent = `我是 ${myName}`; 
para2.textContent = `20 年后我 ${myAge + 20} 岁`; 
section.appendChild(para1); section.appendChild(para2); 
<input id="reset" type="button" value="Reset" /> 
``` 
{{ EmbedLiveSample(‘变量 3’, ‘100%’, 420, ’‘,’‘, ’hide-codepen-jsfiddle’) }} 
标注： 下载 任务 3 的起始版本，然后使用你自选的编辑器完成任务。 了解更多 
可以在互动编辑器中完成上面的练习。 
可借助 CodePen、jsFiddle、Glitch 等在线编程实用工具完成任务。 
在那里你可以自行编写代码，也可以使用上文中所给的初始代码。 
在 MDN 论坛学习区寻求他人的评估和帮助。 
你发表的文章应包括： 
一个描述性的标题，比如《请为“变量 1”水平测试进行评估》 


* { 
box-sizing: border-box; 
} html { 
background-color: #0c323d; 
color: #809089; 
font-family: monospace; 
} 
max-width: 700px; 
} 
p { 
margin: 0; 
width: 1%; 
padding: 0 1%; 
font-size: 16px; 
line-height: 1.5; 
float: left; 
} .input p { 
margin-right: 1%; 
} .output p { 
width: 100%; } 
.input input { 
width: 96%; 
float: left; 
border: none; 
font-size: 16px; 
line-height: 1.5; 
font-family: monospace; 
padding: 0; 
background: #0c323d; 
color: #809089; 
} 
div { 
clear: both; 
{{LearnSidebar}}{{PreviousMenuNext(“Learn/JavaScript/First_steps/What_went_wrong”, “Learn/JavaScript/First_steps/Math”, “Learn/JavaScript/First_steps”)}} 
在读完之前的一些文章之后，你现在应该大概知道了 JavaScript 是什么，你能用它干什么，它是怎么跟其他 web 技术协同工作的，以及从上层来看，它有哪些主要特性。 
在本文中，我们将深入了解真正的基础知识，学习如何使用 JavaScript 最基础的构建单元——变量。 
前提： 
电脑基础知识，了解基本的 HTML 和 CSS，了解 JavaScript 是什么。 



{{LearnSidebar}} 
以下链接指向撰写 JavaScript 代码时可能遇见的问题。 
初学者常见的错误 
正确的拼写和使用 
如果你的代码不工作或浏览器抱怨某些东西是未定义的，请检查你是否正确拼写了所有的变量名称，函数名称等。 
导致问题的一些常见的内置浏览器函数有： 
正确 
错误 
getElementsByTagName() 
getElementbyTagName() 
getElementsByName() 
getElementByName() 
getElementsByClassName() 
getElementByClassName() 
getElementById() 
getElementsById() 
分号的位置 
必须确保没有错误地放置分号，例如： 
正确 
错误 
elem.style.color = 'red'; 
elem.style.color = 'red;' 
函数 
函数有很多容易出错的地方。 
最常见的错误之一是函数被声明了却没有被调用。 
例如： 
function myFunction() { 
alert("This is my function."); 
} 
这个函数不会执行，除非你调用它，例如： 
myFunction(); 
name: "Chris", 

{{LearnSidebar}} 
{{Glossary(“JavaScript”)}} 编程语言允许你在 Web 页面上实现复杂的功能。 
如果你看到一个网页不仅仅显示静态的信息，而是显示依时间更新的内容，或者交互式地图，或者 2D/3D 动画图像，或者滚动的视频播放器，等等——你基本可以确定，这需要 JavaScript 的参与。 
学习路线 
很多人认为，与相关技术如 HTML 和 CSS 相比，学习 JavaScript 更为困难。 
在尝试学习 JavaScript 之前，我们强烈建议你首先至少熟悉上述这两种技术，一些其他知识可能也会有帮助。 
你可以从以下模块开始学习之旅： 
开始了解 Web 
HTML 入门 
CSS 入门 
拥有其他编程语言的经验也许会有帮助。 
熟悉 JavaScript 的基本概念之后，你将具备学习更多高级主题的能力，比如这些： 
深入理解 JavaScript，如 JavaScript 指南中的内容 
Web APIs 
模块 
本主题包含以下模块，我们建议你按照下列顺序阅读。 
JavaScript 第一步 
: 作为 JavaScript 学习的第一个模块，在开始编写第一段代码之前，我们首先回答一些基础的问题，比如“JavaScript 是什么？”、“它的代码长什么样？”、以及“它能做什么？”。 
之后我们会详细讨论一些 JavaScript 的关键功能，比如变量、字符串、数字、数组等。 
构建 JavaScript 代码块 
: 在这个模块中，我们继续介绍 JavaScript 的关键的基础功能，并逐渐将注意力转移到常见类型的代码块，比如条件语句、循环、函数、以及事件等。 
你应该已经遇到过这些概念，而这里我们将正式学习。 
JavaScript 对象初识 
: 在 JavaScript 中，绝大多数东西都是对象；从作为 JavaScript 核心功能的字符串和数组，到建立在 JavaScript 之上的浏览器 API，无一不是对象。 
你甚至可以自己创建对象，将相关的函数和变量封装打包。 
想要进一步学习 JavaScript 语言知识、写出高效的代码的话，理解这种面向对象的特性是必不可少的。 
这个模块将帮助你了解“对象”，我们将详细介绍对象的设计思想和语法、如何创建对象，并解释 JSON 数据是什么、如何使用。 
异步 JavaScript 
: 这个模块介绍异步 JavaScript：为什么重要，如何用它来处理 可能引起阻塞的操作（比如从服务器获取资源） 
客户端 Web API 
: 为网站或应用编写客户端 JavaScript 脚本时，你很难不用到 Web API 接口。 这些接口允许你一定程度上操纵网页所运行在的浏览器和操作系统、甚至来自其他网站和服务的数据。 
在这个模块中，我们将了解有哪些 API，并学习使用开发过程中最常见的 API。 
解决常见的 JavaScript 问题 
解决常见的 JavaScript 问题 提供一些链接，解释如何使用 JavaScript 来解决创建网页时非常常见的问题。 
参见 
Coding math 
: 由 Keith Peters 制作的一个优秀的视频教程系列，向你传授高效编程所需的必备技能。 




{{LearnSidebar}} 
在 JavaScript 中，大多数事物都是对象，从作为核心功能的字符串和数组，到建立在 JavaScript 之上的浏览器 {{Glossary(“API”, “API”)}} 。 
你甚至可以自己创建对象，将相关的函数和变量高效地封装打包成便捷的数据容器。 
对于进一步学习 JavaScript 语言知识而言，理解这种面向对象（object-oriented, OO）的特性是必不可少的，所以，我们提供了这个模块来帮助你了解这一切。 
这里我们会先详细介绍对象的理论和语法，再介绍如何创建对象。 
预备知识 
开始这个模块之前，你应当已经对 HTML 和 CSS 有所了解。 
我们建议你通读 HTML 入门和 CSS 入门模块，再开始了解 JavaScript。 
详细了解 JavaScript 对象之前，你应当已经对 JavaScript 基础有所熟悉。 
尝试这个模块之前，请通读 JavaScript 第一步 和 JavaScript 基础要件 
备注： 如果你无法在当前使用的电脑/平板/其他设备上创建自己的文件，可以使用在线编程网站如 JSBin 或 Glitch，来试验文章中的（大多数）代码。 
指南 
对象基础 
: 在了解 JavaScript 对象的第一篇文章中，我们将介绍 JavaScript 对象的语法，并回顾先前课程中讲过的某些 JavaScript 功能。 你会发现，你已经在使用的很多功能本质上都是对象。 
适合初学者的面向对象 JavaScript 
: 了解基础后，我们将关注面向对象 JavaScript (OOJS)。 
本文将介绍面向对象编程 (OOP) 的基本理论，然后讲解 JavaScript 如何通过构造器 (constructor) 函数模拟对象类别 (class)、如何创建对象实例 (instance)。 
对象原型 
: 通过原型 (prototype) 这种机制，JavaScript 中的对象从其他对象继承功能特性；这种继承机制与经典的面向对象编程语言不同。 
JavaScript 中的继承 
: 了解了 OOJS 的大多数细节之后，本文将介绍如何创建“子”对象类别（构造器）并从“父”类别中继承功能。 
使用 JSON 数据 
: JavaScript Object Notation (JSON) 是一种将结构化数据表达为 JavaScript 对象的标准格式，其常用于在网站上表达或传输数据（比如：从服务器向客户端发送数据，使之显示在网页上）。 
你会经常遇到它，因此本文将告诉你如何在 JavaScript 中使用 JSON 数据，包括访问 JSON 对象中的数据条目、编写自己的 JSON 数据等等。 
构建对象实战 
: 在前面的文章中我们了解了 JavaScript 对象基本理论和语法，为你打下坚实的基础。 
本文中你需要进行实战练习，通过构建自定义 JavaScript 对象的实践过程，编写一个有趣而又多彩的程序——“彩色弹跳球”。 
学习评估 
向“弹跳球”演示程序添加新功能 
: 在这个评估中，你需要以上一篇文章中的“弹跳球”演示为起点，向这个演示程序新增一些有趣的功能。 





{{learnsidebar}} 
这个测试的目的是为了评估你是否已经理解了我们的 JavaScript 中的类这一文章。 
备注： 你可以尝试在下方的交互式编辑器，但是若你下载源码并使用在线工具（例如 CodePen、jsFiddle 或 Glitch）来尝试这些任务，可能会更有帮助。 
如果你遇到了困难，请联系我们以寻求帮助——见本页面底部的评估或进一步帮助。 
备注： 在下方的示例中，如果你的代码中存在错误内容，这些错误将在页面的结果面板中显示，以此来帮助你想出解决方案（若是下载的版本，请进入浏览器的 JavaScript 控制台）。 
面向对象的 Javascript 1 
在这个任务中，我们为你提供了 Shape 类的初始定义。 
它有三个属性：name、sides 和 sideLength。 
这个类只模拟了所有边长都相同的形状，例如：正方形或等边三角形。 
我们希望你： 
向这个类添加构造函数。 
构造函数接受 name、sides 和 sideLength 属性的参数，并对它们进行初始化。 
向这个类添加一个新的 calcPerimeter() 方法，用于计算它的周长（形状外边缘的长度），并将结果记录到控制台中。 
创建 Shape 类的一个新的实例，名为 square。 
将其 name 属性值设为 square，sides 属性值设为 4，sideLength 属性值设为 5。 
调用 calcPerimeter() 方法，以查看它是否按预期将计算结果记录到浏览器的控制台中。 
将其 name 属性值设为 triangle，sides 属性值设为 3，sideLength 属性值设为 3。 
调用 triangle.calcPerimeter()，以查看它是否正常工作。 
尝试更新下面的实时代码，以重现完成的示例： 
{{EmbedGHLiveSample(“learning-area/javascript/oojs/tasks/oojs/oojs1.html”, ‘100%’, 400)}} 
标注： 
下载此任务的初始代码，以便在你自己的编辑器或在线编辑器中尝试。 
面向对象的 Javascript 2 
接下来，我们希望你创建一个继承自 Shape 的 Square 类，并添加一个 calcArea() 方法，用于计算正方形的面积。 
同时，设置构造函数，以便 Square 对象实例的 name 属性自动设置为 square，sides 属性自动设置为 4。 
因此，在调用构造函数时，你只需要提供 sideLength 属性。 
创建一个使用适当属性值的 Square 类的实例，名为 square，并调用它的 calcPerimeter() 和 calcArea() 方法，以表明其是否正常工作。 
尝试更新下面的实时代码，以重现完成的示例： 
{{EmbedGHLiveSample(“learning-area/javascript/oojs/tasks/oojs/oojs2.html”, ‘100%’, 400)}} 
标注： 
下载此任务的初始代码，以便在你自己的编辑器或在线编辑器中尝试。 
评估或进一步帮助 
你可以在上面的交互式编辑器中练习这些示例。 
如果你希望对自己的工作成果进行打分评估，或者遇到了困难并希望寻求帮助： 
将你完成的内容放到在线、可分享的编辑器，如：CodePen、jsFiddle 或 Glitch。 
你可以自行编写代码，或使用上面小节中链接的初始文件。 
在 MDN Discourse forum Learning category 中发贴寻求打分评估或帮助。 
你的贴子需要包含： 
一个描述的标题，如：“Assessment wanted for OOJS 1 skill test”。 

{{learnsidebar}} 
你花一些时间学习一套新技能是很好的，但采用一些更好的做法可以让你的学习更加高效。 
有时，你也会陷入困境并感到沮丧，即使是专业的 Web 开发人员也会经常这样，因此，了解最有效的方法，尝试获得帮助，以便你能够继续工作，是值得付出的。 
本文在这两个方面提供了一些提示和提示，可帮助你从学习 Web 开发中获得更多内容，并进一步阅读，以便你能够找到有关每个子主题的详细信息。 
有效学习 
让我们直接思考一下有效的学习。 
不同的学习方法 
有趣的是，你的大脑学习东西有两种主要方式——专注和分散学习： 
重点学习是你传统上可能与学术科目联系在一起的东西。 
你专注于一个低级的话题，并解决它带来的具体问题。 
你专注于一个狭窄的区域。 
分散学习更多的是与围绕更广领域的高层次思维有关。 
你让你的头脑游荡更广，似乎在不同事物之间随机联系。 
这更多的是你在洗澡时或喝咖啡休息时的想法。 
从神经科学家对大脑活动所做的研究中，我们发现，你不能同时参与两种学习或思考的方式。 
那么，你应该选择哪一个呢？ 
你可能认为集中学习更适合学习，但在现实中，两者都很重要。 
专注思维对于将精力集中在特定主题上，深入解决问题，以及提高你对所需技术的掌握——加强大脑中存储信息的神经通路——都很棒。 
然而，当你试图理解新学科或解决以前没有遇到的新问题时，它并不善于理解”大局”，并解锁新的神经通路。 
为此，你需要漫不由多的思考。 
这与焦点正好相反——你让你的大脑在更广阔的环境中游荡，四处寻找你之前没有的联系，接触新事物（或新事物的新组合），然后你可以关注这些事物，加强它们，并开始真正理解它们的意思。 
这就是为什么在进入具体细节之前，先阅读一些介绍性材料，以便对一个领域有一个高度的了解，这通常是好的。 
这也是为什么你有时真的可以陷入一个问题，但随后找出答案，当你去喝咖啡休息（或散步）。 
你可以： 
知道如何使用工具 A 解决问题 A。 
知道如何用工具 B 解决问题 B。 
不知道如何解决问题 C。 
假设你一直专注于问题 C，然后感到沮丧，因为你无法思考如何解决它。 
但是，在散步获得新鲜空气后，你可能会发现，当你的头脑徘徊，你突然使工具 A 和工具 B 之间的连接，并意识到你可以使用它们一起解决问题 C！ 
它并不总是这么简单，但它也令人惊讶的是多少次，这确实发生了。 
这也凸显了在电脑前学习时定期休息的重要性。 
不同的学习材料 
也值得看看可用的不同类型的学习材料，看看哪些材料对你来说最有效。 
文本文章 
你会发现很多书面文章在网上教你有关网页设计。 
例如，像本课程的多数课程一样。 
有些文章将是教程，教你某种技术或重要概念（如”学习如何创建视频播放器”或”学习 CSS 框模型”），有些文章将是参考材料，允许你查找你可能忘记的细节（如”CSS 属性的语法是什么”？ background 
MDN Web 文档对这两种类型都非常好 - 你当前位于的区域非常适合学习技术和概念，我们还有几个巨大的参考部分，允许你查找任何你不记得的语法。 
网上还有其他几个伟大的资源，我们将在下面提及其中一些资源。 
备注： 上面的文本应该给你一个重要的事实 - 你不应该记住一切！ 
专业的 Web 开发人员使用 MDN Web 文档等工具查找他们一直忘记的内容。 
正如你会发现，学习 Web 开发更多的是关于问题解决和学习模式，而不是学习大量语法。 
视频资料 
还有一些网站上有视频学习内容。 
很明显 YouTube 是一个不错的网站，它有很多频道，比如 Mozilla Layout Land、 MozillaDeveloper 和 Google ChromeDevelopers 提供许多有用的视频。 
许多人更喜欢文本文章来进行更深入的学习和参考资料，喜欢视频来快速理解概念和新功能，但你更喜欢从中学习什么实际上取决于你自己。 
这里没有对错的说法。 
交互式的代码演练场 
你可能是那种喜欢简单指令的人，更喜欢直接开始操纵代码。 
这也是一种合理的方法，一些学习网站倾向于采用这种方法。 例如像 Codecademy 这类网站中，教程主要由交互式代码编辑器组成，你必须直接编写代码并查看是否达到了预期的结果。 
许多 MDN Web 文档参考页面中也提供了交互式的示例，你可以在其中更改代码，并查看实时结果的变化。 
在你的计算机上或者在像 JSBin、Codepen 或 Glitch 这样的在线代码编辑器中创建自己的代码示例也是可以的。 
事实上，当你在学习时，你会被要求去做这些事情本身就是属于课堂的一部分！ 
备注： 在线代码编辑器对于共享你编写的代码也非常有用，例如，如果你正在与不在同一位置的其他人协作学习，或者正在向他人发送代码以寻求帮助。 
你可以与他们共享代码示例的网址，以便他们可以查看。 
备注： 与其他学习方法相比，你可能更喜欢一种学习方法，但实际上，你最终可能得到的是一种混合方法。 
你可能还会想出另外其他的方法，而不是我们上面提到的三种。 
制定一个计划 
制定一个计划来帮助你通过学习实现你想要实现的目标是个好主意。 
定一个目标 
这听起来很傻，但为什么不从一句话开始，说出你想要实现的目标呢？ 
以下内容有不同的见识，但都是现实可行的： 
我想在两年后成为一名专业的 Web 开发者。 
我想学习足够的知识，为我当地的业余网球俱乐部建立一个网站。 
我想学习 HTML 和 CSS，这样我就可以扩展我的工作角色，接管更新我们公司网站上的内容。 
下面是一些不切实际的想法： 
我想在三个月内从一个完全的初学者变成一名高级 Web 开发人员。 
我想创办自己的公司，建立一个社交网络，在两年内超越 Facebook。 
你需要什么才能到达那里？ 
一旦你制定了目标，研究一下实现目标需要什么是个好想法。 
例如： 
我需要的工具： 
接入互联网 
一些笔和纸 
我需要的知识： 
它可以简单到： 
如果我假设有两周的假期，我打算每周为此学习 10 个小时 (在晚上和周末有空的时候)，所以我会这样安排时间。” 
当然，你能在这上面花多少时间取决于你的情况。 
在 12 月学习完 JavaScript 基础知识 
在明年的 4 月份前搭建好一个示例网站 等等。 
经常想一想你取得了多大的进步，在需要的时候及时调整你的计划。 保持动力 
将这些基本要素纳入你的时间表，确保你除此之外没有安排更多的学习时间。 奖励你自己。 
你应该尝试在每一次的学习之后安排一些有趣的事情，前提是你必须在完成学习任务之后。 
这不是每个人的选择，但如果可能的话，试着和其他人一起学习。 
那些感激的喊声会激励你前进。 
例如，如果你正在考虑“构建一个简单的两栏网站”的任务，你可以将其分解如下： 组织 HTML 结构 
制定基本的网站排版 
然后你可以进一步分解它。 例如，“实现水平导航菜单”可以写成： 
删除不必要的默认设置，如列表间距和项目符号。 
例如，专业的 web 开发人员已经创建了很多水平导航菜单，所以他们会立即开始考虑这样的解决方案： 
要使所有内容水平放置在一条线上，最简单的现代方法是使用 flexbox： ul { display: flex; } 
另外，网络上有 开发者工具，它使你可以查看用在 web 上构建任何网站的代码。 
如果你手头没有解决方案，一个好的研究方法是在网络某处地方找到具有类似功能的网站，并找出它们是如何做到的。 
你练习解决问题越多，你的大脑在该区域的神经通路就越强大，也就越容易回忆起特定问题的细节和逻辑。 
继续修补代码，并进行更多练习。 如果你没有问题要解决，可以在网上查一些测试，多上一些课程，或者问问你的朋友和家人（或当地的学校或教堂），他们是否希望你为他们做些什么。 寻求帮助 
需要学习的一项重要技能是高效网络搜索的技巧——你需要在你最喜欢的搜索引擎中使用哪些搜索词来找到你需要的文章？ 
例如： 
在元素的背景中创建线性渐变 
示例搜索可能看起来像： 
<video> 在 iOS 浏览器中播放不起作用。 
在 MDN 的这一部分中，我们提供了关于 web 开发基础知识的大部分问题的答案。 
Sitepoint Forums 
然而，在 Twitter 或 Facebook 等社交网站上寻找有用的群组也是有意义的。 
meetup.com 是一个很好的地方，可以找到当地的身体聚会，你也可以尝试搜索你当地的媒体/网站上的内容。 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/Performance/html”, “Learn/Performance/business_case_for_performance”, “Learn/Performance”)}} 
页面在样式没有渲染完毕的情况下被绘制，在样式渲染完毕后又被刷新，这大概是很糟糕的用户体验。 
因此，除非浏览器知道当前不需要该 CSS，否则该 CSS 将阻止渲染。 
浏览器一旦下载了 CSS 并建立了 CSS 对象模型，就可以绘制页面。 
浏览器遵循特定的渲染路径：绘制只发生在布局之后，而布局发生在渲染树创建之后，这又需要 DOM 和 CSSOM 树。 
为了优化 CSSOM 的构建，要删除不必要的样式，对其进行最小化、压缩和缓存，并将页面加载时不需要的 CSS 分割到其他文件中，以减少 CSS 渲染阻塞。 
阻塞渲染优化 
CSS 可以使用媒体查询将样式应用在特定条件下。 
媒体查询对于响应式 Web 设计非常重要，可以帮助我们优化关键渲染路径。 
浏览器会阻塞渲染，直到它解析完全部的样式，但不会阻塞渲染它认为不会使用的样式，例如打印样式表。 
通过基于媒体查询将 CSS 分成多个文件，可以防止在下载未使用的 CSS 期间阻止渲染。 
为了创建非阻塞 CSS 链接，将不会立即使用的样式（例如打印样式）移动到单独的文件中，将 <link> 元素添加到 HTML 中，并添加媒体查询，在这种情况下说明它是打印样式表。 
<!-- 加载和解析 styles.css 是阻塞渲染的 --> 
<link rel="stylesheet" href="styles.css" /> 
<!-- 加载和解析 print.css 是非阻塞渲染的 --> 
<link rel="stylesheet" href="print.css" media="print" /> 
<!-- 加载和解析 mobile.css 在大型屏幕上是非阻塞渲染的 --> 
<link 
rel="stylesheet" 
href="mobile.css" 
media="screen and (max-width: 480px)" /> 
默认情况下，浏览器假设每个指定的样式表都是阻塞渲染的。 
通过添加 media 属性附加媒体查询，告诉浏览器何时应用样式表。 
当浏览器看到一个它知道只会用于特定场景的样式表时，它仍会下载样式，但不会阻塞渲染。 
通过将 CSS 分成多个文件，主要的阻塞渲染文件（本例中为 styles.css）的大小变得更小，从而减少了渲染被阻塞的时间。 
在 GPU 上渲染动画 
浏览器针对处理 CSS 动画进行了优化，可以很好地处理触发重排（因此也导致重绘）的动画属性。 
为了提高性能，可以将被动画化的节点从主线程移到 GPU 上。 
将导致合成的属性包括 3D 变换（transform: translateZ()、rotate3d() 等）、动画变换、opacity、position: fixed、will-change 和 filter。 
一些元素，例如 <video>、<canvas> 和 <iframe>，也位于各自的图层上。 
将元素提升为图层（也称为合成）时，动画转换属性将在 GPU 中完成，从而改善性能，尤其是在移动设备上。 
will-change 属性 
CSS will-change 属性告诉浏览器元素的哪些属性需要修改，使浏览器能够在元素实际更改之前设置优化，通过在实际更改前执行耗时的工作以提升性能。 
备注： will-change 是作为最后的手段来处理现有的性能问题的。 
它不应该被用来预测性能问题。 
will-change: opacity, transform; 
font-display 属性 
根据 @font-face 规则，font-display 属性定义了浏览器如何加载和显示字体文件，允许文本在字体加载或加载失败时显示回退字体。 
可以通过依靠折中无样式文本闪现使文本可见替代白屏来提高性能。 
@font-face { 
font-family: someFont; 
src: url(/path/to/fonts/someFont.woff) format("woff"); 
font-weight: 400; 
font-style: normal; 
font-display: fallback; 
} 
contain 属性 
CSS 属性 {{cssxref(‘contain’)}} 允许作者表示一个元素及其内容尽可能独立于文档树的其他部分。 
这允许浏览器为 DOM 的有限区域而不是整个页面重新计算布局、样式、绘画、尺寸或它们的任何组合。 
总结 
{{PreviousMenuNext(“Learn/Performance/html”, “Learn/Performance/business_case_for_performance”, “Learn/Performance”)}} 
参见 
CSS 动画性能 

{{LearnSidebar}} 
构建一个网站需要 HTML、CSS 和 JavaScript。 
为了构建人们需要的、能吸引和留住用户的网站和应用，你需要创建一个良好的用户体验。 
良好用户体验的一部分是确保内容能够快速加载并响应用户交互。 
这就是所谓的 web 性能，在这个模块中，你将会学到构建性能良好的网站所需要的知识。 
我们的初学者学习材料的其余部分尽量坚持网络最佳实践，如性能和无障碍，然而，专门关注此类主题也是不错的，并确保你熟悉它们。 
学习途径 
虽然了解 HTML、CSS 和 Javascript 是实现许多网页性能提升建议的必要条件，但了解如何构建应用却不是理解和衡量网页性能的必要先决条件。 
然而，我们建议你在学习本模块之前，至少通过学习我们的 web 入门模块，获得一个网络开发的基本概念。 
更深入进行以下主题也很有必要，这些模块包括： 
HTML 入门 
CSS 初步 
JavaScript 初步 
一旦你完成了这个模块的学习，你可能会对深入研究网络性能感到兴奋——你可以在我们的 MDN 网络主要性能部分找到很多进一步的教学内容，包括性能 API 的概述、测试和分析工具，以及性能瓶颈问题。 
指南 
本专题包含以下指南。 
以下是建议的学习顺序；你肯定应该从第一个开始。 
为什么要提升 web 性能 
: 本文讨论了为什么网络性能对无障碍、用户体验和你的商业目标很重要。 
什么是 web 性能？ 


{{LearnSidebar}}{{PreviousMenuNext(“Learn/Performance/what_is_web_performance”, “Learn/Performance/Measuring_performance”, “Learn/Performance”)}} 
感知性能 是用户对网站速度的感受。 
用户如何看待性能与任何客观统计数据一样重要，甚至更重要，但它是主观的，并且不易测量。 
感知性能是用户视角，而不是指标。 
本文简要介绍了感知性能，着眼于用户的感知，以及可以使用哪些客观工具来衡量这类主观因素。 
前提： 
基础计算机知识，基本软件安装， 客户端 web 技术的基础知识 
目标 
基本了解用户对 Web 性能的看法。 

有很多的理由告诉你为什么你的网站需要尽可能好的性能。 
下面是关于最佳实践，工具，API 以及链接的简明介绍，它为每个主题提供了更多的信息。 
意识到对用户来说什么是真正重要的也至关重要，他可能不是绝对意义上的时间而是用户感知的时间。 
最佳实践 
从学习浏览器的关键渲染路径开始。 
了解这些会帮助你通晓如何提升浏览器的性能。 
使用resource hints例如rel=preconnect, rel=dns-prefetch, rel=prefetch, and rel=preload 
压缩 Js 代码至最小。 
只为当前页面加载需要使用到的 js 代码 
CSS性能因素 
在你的服务器（或者 CDN）上使用 HTTP/2协议 
使用 CDN 托管静态资源，这样可以显著减少加载时间 
使用gzip, Brotli 或者 Zopfli压缩你的资源 
图片优化（如果可以，尽可能使用 css 动画或者 svg） 
在超出应用视口范围的部分使用懒加载，如果你这么做了，为 SEO 制定一个后备计划（例如为 bot traffic 渲染整个页面） 
工具 
学习使用Firefox Dev Tools来分析你的网站。 
Pagespeed Insights 可以分析你的页面并且给出一些通用的建议来提升网站性能。 
Lighthouse 可以给你一份有关你网站的包括性能，SEO 和无障碍等多个方面的详细分类。 
使用 Webpagetest.org检测页面在不同真实设备类型和地点时候的速度。 
trics. 
定义一个绩效预算（performance budget）。 
APIs 
收集用户指标通过 https://github.com/akamai/boomerang 。 
或者通过window.performance.timing 直接收集。 
不该做的事（坏的实践） 
将任何东西都下载下来 
使用未经压缩的媒体文件 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/Performance/why_web_performance”, “Learn/Performance/Perceived_performance”, “Learn/Performance”)}} 


Background 
默认情况下，许多 web 服务器会为那些未知内容类型的文件配置一个默认 MIME 类型text/plain 或者application/octet-stream 。 
主要原因是用户使用 Gecko-based 的浏览器，而这种浏览器只相信由 web 服务器和 web 应用所发布的 MIME 类型 What are MIME types? 
MIME 类型的示例如下： 
text/html 对于一般网页 
text/plain 对于一般文本 
text/css 对于级联样式表 
text/javascript 对于脚本 
application/octet-stream 意味着“下载这个文件” 
application/x-java-applet 对于 Java applets 
application/pdf 对于 PDF 文档 Technical Background 
完整的 MIME 类型列表可在 IANA | MIME Media Types 查看。 
在HTTP specification 中定义了能够描述在 web 中使用的媒体类型的 MIME 超集。 
Why are correct MIME types important? 
对于某些浏览器，例如 IE，它尝试允许 web 服务器对于错误配置通过其源码猜测它可能的正确 MIME 类型。 
这种做法将会避免许多由 web 管理员他们的错误。 
因为当内容的 MIME 类型错误，IE 将会用可能正确的 MIME 类型来继续处理内容。 
例如你设置一个img的类型为text/plain ,IE 可能会设置它为正确的 MIME 类型images/* 
出于安全原因，使用正确的 MIME 类型的服务内容也是重要的；恶意内容可能会影响用户的计算机，假装它是一个安全类型文档，实际上不是。 
备注： 从历史角度，只要 HTML 文档请求处理 CSS 文件，Firefox 能够正常加载 CSS 即使它设置了错误的 MIME 类型。 处于安全原因，Gecko 2.0 对于从请求文档不同来源加载的样式表，将不再这样做。 
如果 CSS 来自于不同来源，你必须设置它的正确 MIME 类型 (text/css). 
Gecko 1.9.1.11 (Firefox 3.5.11) 和 Gecko 1.9.2.5 (Firefox 3.6.5) 同样实施这种安全措施，但是提高它的实用性。 
如果样式表中的第一行看起来是一个很好的 CSS 构造，则存在允许加载的临时启发式算法。 
在 Firefox 4 中已经删除了启发式，你必须正确设置text/css 的 MIME 类型，才能够识别 CSS。 
为何浏览器不应该猜测 MIME 类型 
除了违返了 HTTP 规范，让浏览器去猜测正确的 MIME 类型是一个差劲的策略。 
原因如下 
失去控制 
假如浏览器忽略报告的 MIME 类型，web 管理员和用户不在对内容如何进行处理有发言权了。 
例如，面对 web 开发员的网址可能希望发送某些实例 HTML 文档，同时通希望能够以 text/html或者 text/plain 的 MIME 类型进行数据的处理和显示 或者 作为一个源代码。 
如果浏览器猜测它的正确 MIME 类型为 text/html 那么开发员不在有权利进行选择了。 安全性 
一些内容类型，例如可执行程序，本质上是不安全的。 
原因是经过规范化的 MIME 类型都有经过严格规定浏览器如何对这类类型的文件进行操作。 
MIME 类型猜测导致 IE 浏览器的安全漏洞（通过利用 IE 能够将错误的 MIME 类型 修改为正确的类型）。 
这绕过了正常的下载对话框，导致 InternetExplorer 猜测内容是可执行程序，然后在用户的计算机上运行。 
如何确定服务器发送内容的 MIME 类型 
通过开发者工具的 ContentType 查看 MIME 类型。 
根据标准，通过一个 meta 标签来设置 MIME 类型 例如 <meta http-equiv="Content-Type" content="text/html"> 当包含{{HTTPHeader(“Content-Type”)}} 时则忽略 meta 标签 
如何为你的内容确定正确的 MIME 类型 
这里有几种方法来确定文件的正确 MIME 类型 
如果你的内容是通过供应商软件应用创建的，那么你可以阅读供应商文档确认不同媒体文件的 MIME 值 
通过查看完整的 MIME 类型表 IANA | MIME Media Types registry 
如果使用插件 netscape gecko 显示媒体类型，请安装插件，然后查看“帮助”>“关于插件”菜单，以查看哪些 MIME 类型与媒体类型相关联。 
搜索文件扩展名 FILExt 或者File extensions reference ，确认扩展名和哪种类型的 MIME 相关联 
基本的方法是配置你的服务器发送正确的 HTTP ContentType类型给每个文档 
如果你正在使用 Apache Web 服务器，只需将此示例.htaccess 文件复制到包含要使用正确 MIME 类型发送的文件的目录中。 
如果你有一个完整的文件子目录，只需将文件放在父目录中；你不需要将它放在每个子目录中。 
如果你使用的是 Microsoft IIS, 请参阅IANA | MIME Media Types registry这篇文章。 
如果你使用服务器端脚本生成内容，通常可以在脚本顶部附近添加一行。 
你可以从 Perl，PHP，ASP 或 Java 提供 HTML 以外的内容 - 只需相应地更改 MIME 类型即可。 
对于 Perl CGI，你应该在文档其他行之前输出 print "Content-Type: text/html\n\n";。 
如果你正在使用 CGI 模块，你可以使用 print $cgi->header('text/html'); 代替，其中 $cgi 是对 CGI 实例的引用。 
对于 PHP，你应该在文档其他行之前输出 header('Content-Type: text/html');。 
对于 ASP, 你应该在文档其他行之前输出response.ContentType = "text/html";。 
对于 Java servlet, 你需要在doGet 或 doPost 方法之前输出response.setContentType("text/html"); ，其中 response 是对 HttpServletResponse的引用。 
Related Links 
IANA | MIME Media Types 
Hypertext Transfer Protocol — HTTP/1.1 
Microsoft - Appendix A: MIME Type Detection in Internet Explorer 
Microsoft - Security Update, March 29, 2001 
Microsoft - Security Update, December 13, 2001 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/Server-side/Django/Models”, “Learn/Server-side/Django/Home_page”, “Learn/Server-side/Django”)}} 
好了，我们已经为本地图书馆网站 LocalLibrary 创建了模型，我们接下来使用 Django 管理站点去添加 一些“真“书数据。 
首先我们展示如何用管理站点注册模型，然后展示如何登录和创建一些数据。 
本文最后，我们介绍你可以进一步改进管理站点的建议。 
前提： 
完成： Django Tutorial Part 3: 使用模型。 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/Server-side/Django/Sessions”, “Learn/Server-side/Django/Forms”, “Learn/Server-side/Django”)}} 
在本教程中，我们将向你展示如何允许用户使用自己的帐户登录到你的网站，以及如何根据用户是否已登录及其权限来控制他们可以执行和查看的内容。 
作为演示的一部分，我们将扩展LocalLibrary网站，添加登录页面和注销页面，以及用户和员工特定的页面以查看已借阅的图书。 
前提： 
完成之前的所有教程主题，包括Django 教程 7：Sessions 框架。 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/Server-side/Django/Testing”, “Learn/Server-side/Django/web_application_security”, “Learn/Server-side/Django”)}} 
现在，你已经创建（并测试）了一个令人敬畏的LocalLibrary网站，如果你希望将其安装在公共 Web 服务器上，以便图书馆工作人员和成员可以通过 Internet 访问它。 
本文概述了如何找到主机来部署你的网站，以及你需要做什么才能让你的网站准备好生产。 
前提： 
完成所有先前的教程，包括： 
在线教学 10：测试 Django 的 Web 应用 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/Server-side/Django/Introduction”, “Learn/Server-side/Django/Tutorial_local_library_website”, “Learn/Server-side/Django”)}} 
现在，你知道什么是 Django。 
那么我们将向你展示如何在 Windows，Linux（Ubuntu）和 Mac OSX 上设置和测试 Django 开发环境—无论你常用哪种操作系统，本文能给你开发 Django 应用所需的一切。 
前提： 





{{LearnSidebar}} 
Django 是使用 Python 语言编写的一个广受欢迎且功能完整的服务器端网站框架。 
本模块将为你展示为什么 Django 能够成为一个广受欢迎的服务器端框架，如何设置开发环境，以及如何开始创建你自己的网络应用。 
开始学习本模块并不需要任何 Django 知识。 
但你要理解什么是服务器端网络编程、什么是网络框架，最好能够阅读我们的服务端网站编程的第一步模块。 
最好能有基本的编程概念并了解 Python 语言，但其并不是理解本教程的核心概念的必然条件。 
备注： 对于初学者来说，Python 是最容易阅读和理解的编程语言之一。 
也就是说，如果你想更好的理解本教程，网上有很多免费书籍及免费教程可供参考学习（建议初学者查看 Python 官网的 Python for Non Programmers 教程）。 
指南 
Django 简介 
: 在第一篇关于 Django 的文章里，我们会回答”什么是 Django?“,并概述这个网络框架的特殊之处。 
我们会列出主要的功能，包括一些高级的功能特性，这些高级特性我们在这部分教程里没有时间详细说明。 
在你设置好 Django 应用并开始把玩它之前，我们会展示 Django 应用的一些主要模块，让你明白 Django 应用能做什么。 
创建 Django 开发环境 
: 现在你知道 Django 是做什么的，我们会展示怎样在 Windows, Linux(Ubuntu) 和 Mac OS X 上创建和测试 Django 的开发环境—不管你是用什么操作系统，这篇文章会教给你能够开发 Django 应用所需要的开发环境。 
Django 教程 1:本地图书馆网站 
: 我们实用教程系列的第一篇文章会解释你将学习到什么，并提供”本地图书馆”网站这个例子的概述。 我们会在接下来的文章里完成并不断的进化这个网站。 
Django 教程 2:创建网站的框架 
: 这篇文章会教你怎样创建一个网站的”框架”. 以这个网站为基础，你可以填充网站特定的 settings,urls, models,views 和 templates 
Django 教程 3:使用模型 
: 这篇文章会为 本地图书馆 网站定义数据模板—数据模板是我们为应用存储的数据结构。 
并且允许 Django 在数据库中存储数据 (以后可以修改). 
文章还简要的介绍了一些你可以获得数据模板的方法。 
Django Tutorial Part 4: Django 管理站点 
: 现在我们已经为本地图书馆网站创建了模型，我们将使用 Django 管理站点 添加一些‘真实的’的图书数据。 
首先，我们将向你介绍如何使用管理站点注册模型，然后我们介绍如何登录和创建一些数据。 
最后我们展示一些进一步改进管理站点的演示方法。 
Django Tutorial Part 5: 创建我们的主页 
: 我们现在可以添加代码来展示我们的第一次完整页面—本地图书馆主页，来显示我们对每个模型类型有多少条记录，并提供我们其他页面的侧边栏导航链接。 
一路上，我们将获得编写基本 URL 地图和视图，从数据库获取记录以及使用模版的实践经验。 
Django Tutorial Part 6: 通用列表和详细视图 
: 本教程扩展了我们的本地图书馆网站，添加书籍和作者和详细页面。 
在这里，我们将了解基于类的通用视图，并展示如何减少常用代码用例的代码量。 
我们还将更详细地深入理解 URL 处理，显示如何执行基本模式匹配。 
Django Tutorial Part 7: 会话框架 
: 本教程扩展本地图书馆网站，向主页添加了一个基于会话的访问计数器。 
这是个比较简单的例子，但它显示如何使用会话框架为你自己的站点中的匿名用户提供一致的行为。 
Django Tutorial Part 8: 用户身份验证和权限 
: 本教程，我们将向你展示如何允许用户使用自己的账户登录到你的网站，以及如何根据他们是否登录及其权限来控制他们可以做什么和看到什么。 
作为此次演示的一部分，我们将扩展本地图书馆网站，添加登录和注销页面以及用户和工作人员特定页面，以查看已借用的书籍。 
Django Tutorial Part 9: 使用表单 
: 本教程，我们将向你展示如何使用 Django 中的HTML 表单，特别是编写创建表单，更新和删除模型实例的最简单方法。 
作为此次演示的一部分，我们将扩展本地图书馆网站，以便图书馆员可以使用我们自己的表单 (而不是使用管理应用程序) 来更新书籍，创建，更新和删除作者。 
Django Tutorial Part 10:测试 Django Web 应用程序 
: 随着网站的的发展，手工测试越来越难测试—不仅要测试更多，而且随着组件之间的相互作用变得越来越复杂，一个领域的一个小的变化可能需要许多额外的测试来验证其对其他领域的影响。 
减轻这些问题的一种方法是编写自动化测试，每次更改时都可以轻松可靠地运行。 
本教程将介绍如何使用 Django 的测试框架对你的网站进行单元测试自动化。 
Django Tutorial Part 11: 将 Django 部署到生产 
: 现在，你已创建（并测试）一个酷的 本地图书馆网站，你将要把它安装在公共 Web 服务器上，以便图书馆员工和成员可以通过 Internet 访问。 
本文概述了如何找到主机来部署你的网站，以及你需要做什么才能使你的网站准备好进行生产。 
Django web 应用程序安全 
: 保护用户数据是任何网站设计的重要组成部分，我们以前解释了 Web 安全文章中一些更常见的安全威胁—本文提供了 Django 内置如何保护处理这种危险的实际演示。 
评估 
以下评估将测试你对如何使用 Django 创建网站的理解，如上述指南中所述。 
DIY Django mini blog 
: 在这个评估中，你将使用你从本单元中学到的一些知识来创建自己的博客。 

{{LearnSidebar}}{{NextMenu(“Learn/Server-side/Django/development_environment”, “Learn/Server-side/Django”)}} 
在这第一 Django 文章中，我们将回答“什么是 Django”这个问题，并概述这个网络框架有什么特性。 
我们将描述主要功能，包括一些高级功能，但我们并不会在本单元中详细介绍。 
我们还会展示一些 Django 应用程序的主要构建模块（尽管此时你还没有要测试的开发环境）。 
前提： 
基本的电脑知识。 
对 服务器端网站编程的一般了解, 特别是 网站中客户端 - 服务器交互的机制. 
目标： 
了解 Django 是什么，它提供了哪些功能，以及 Django 应用程序的主要构建块。 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/Server-side/Django/skeleton_website”, “Learn/Server-side/Django/Admin_site”, “Learn/Server-side/Django”)}}这篇文章展示了如何为我们的 LocalLibray（本地图书馆）网站定义 models。 
它解释了一个模型是什么，它是怎么被声明的，和其中的一些主要域类型。 
Prerequisites: 
Django Tutorial Part 2: Creating a skeleton website. 
Objective: 
能够设计并创建你自己的数据模型，并为其合适地选择域。 



{{LearnSidebar}}{{PreviousMenuNext(“Learn/Server-side/Django/Forms”, “Learn/Server-side/Django/Deployment”, “Learn/Server-side/Django”)}} 
随着网站的增长，他们越来越难以手动测试。 
不仅要进行更多的测试，而且随着组件之间的交互变得越来越复杂，一个区域的小改变可能会影响到其他区域，所以需要做更多的改变来确保一切正常运行，并且在进行更多更改时不会引入错误。 
减轻这些问题的一种方法是编写自动化测试，每当你进行更改时，都可以轻松可靠地运行测试。 
本教程演示如何使用 Django 的测试框架自动化你的网站的单元测试。 
前提： 
完成之前的所有教程主题，包括 Django 教程 9：使用表单。 

{{LearnSidebar}}{{PreviousMenuNext(“Learn/Server-side/Django/development_environment”, “Learn/Server-side/Django/skeleton_website”, “Learn/Server-side/Django”)}} 
我们实战教程系列的第一篇教程会解释你将学到什么。 
并提供一个“本地图书馆”的例子作为概述。 
在接下来的教程里，我们会不断完善和改进这个网站。 
前提： 
阅读 Django 介绍。 
在接下来的文章里你需要 创建 Django 开发环境. 
目标： 
介绍教程里使用的网站应用，让读者明白要讨论的主题。 


{{LearnSidebar}}{{PreviousMenu(“Learn/Server-side/Express_Nodejs/forms”, “Learn/Server-side/Express_Nodejs”)}} 
现在你已经创建（并测试）了一个不错的 本地图书馆 网站了，你打算把它发布到一个公共网络服务器，这样图书馆职工和网络上的其他成员就可以访问它了。 
这篇文章总结了你可以怎样找到一台主机部署你的网站，以及你需要为站点准备到生产环境做什么。 
前提： 
完成前面所有的指南主题，包括 Express Tutorial Part 6: Working with forms. 
目标： 
学习你可以怎样以及在哪里部署一个 Express 应用到生产环境。 


作者细节页面需要呈现指定作者Author的信息，使用 _id 字段的值（自动产生）识别，接着是这个作者的所有书本物件Book的列表。 
控制器 
打开 /controllers/authorController.js。 
在档案最上方，加入底下几行，引入 async 和 Book 模组 (作者细节页面需要它们)。 var async = require("async"); 
var Book = require("../models/book"); 
找到 exported author_detail() 控制器方法，并用底下代码置换。 
// Display detail page for a specific Author. 
exports.author_detail = function (req, res, next) { async.parallel( 
{ author: function (callback) { 
Author.findById(req.params.id).exec(callback); 
}, authors_books: function (callback) { 
Book.find({ author: req.params.id }, "title summary").exec(callback); }, }, 
return next(err); 
if (results.author == null) { 
// No results. 
var err = new Error("Author not found"); 
err.status = 404; 
return next(err); 
} 
res.render("author_detail", { 
title: "Author Detail", 
author: results.author, 
author_books: results.authors_books, 
}); 
}; 
此处的控制器方法使用 async.parallel()，用平行的方式，查询作者 Author和相应的书本实例，并附加上绘制本页面的回调，如果 2 个要求都成功完成，就运行回调。 
这个方式，就跟前面的种类细节页面所说明的完全相同。 
视图 
创建 /views/author_detail.pug ，並複制貼上底下的文字。 
extends layout 
block content 
h1 Author: #{author.name} 
p #{author.date_of_birth} - #{author.date_of_death} 
div(style='margin-left:20px;margin-top:20px') 
h4 Books 
dl 
each book in author_books 
dt 
a(href=book.url) #{book.title} 
dd #{book.summary} 
else 
p This author has no books. 
本模板里的所有事物，都在先前的章节演示过了。 
它看起來像是？ 
运行本应用，并打开浏览器访问 http://localhost:3000/。 
选择 All Authors 连结，然后选择一个作者。 
如果每个东西都设定正确了，你的网站看起来应该会像底下的截图。 
Author Detail Page - Express Local Library site 
备注： 作者的出生与死亡日期的外观很丑！ 
我们将在本文最后的自我挑战处理它。 
下一步 
回到 Express 教程 5: 呈现图书馆数据 
继续教程 5 的下一个部分 : 书本实例细节页面和自我挑战 

作者列表页面，需要呈现数据库中所有作者的列表，有每位作者的名字，并连结到作者详细内容页面。 
出生与死亡日期应该在名字后面，并且在同一列。 
控制器 
作者列表控制器函数，需要获取所有作者实例的列表，然后将这些实例传递给模板进行渲染。 
打开 /controllers/authorController.js。 
在文件顶部附近，找到导出的 author_list() 控制器方法，并将其替换为以下代码（更改后的代码以粗体显示）。 
// Display list of all Authors. 
exports.author_list = function (req, res, next) { Author.find() 
.sort([["family_name", "ascending"]]) .exec(function (err, list_authors) { if (err) { return next(err); } //Successful, so render 
res.render("author_list", { 
title: "Author List", 
author_list: list_authors, 
}); 
}); 
该方法使用模型的 find(), sort() 和 exec() 函数，以返回所有 Author 对象，并按 family_name 的字母顺排列。 
传递给 exec() 方法的回调被调用，并将传入任何错误（或 null）作为第一个参数，或者成功时，传入所有作者列表。 
如果出现错误，则调用带有错误值的下一个中间件函数，如果没有错误，则呈现 author_list（.pug）模板，传递页面标题 title，和作者列表（author_list）。 
视图 
打开 /views/author_list.pug ，用底下文字取代它的内容。 
extends layout 
block content 
h1= title 
ul 
each author in author_list 
li 
a(href=author.url) #{author.name} 
| (#{author.date_of_birth} - #{author.date_of_death}) 
else 
li There are no authors. 
运行本应用，并打开浏览器访问 http://localhost:3000/ 。 
然后选择所有作者 All authors 连结。 
如果每个东西都设定正确了，页面看起来应该像底下的截图。 
Author List Page - Express Local Library site 
备注： 作者生命日期的外观是丑陋的！ 
你可以使用我们用于BookInstance 列表的相同方法（将生命周期的虚拟属性，添加到 Author 模型），来改进此方法。 
但是，这次缺少日期，除非严格模式生效，否则将忽略对不存在的属性的引用。 
moment()返回当前时间，并且你不希望将缺少的日期格式化为就像今天一样。 
例如： 
return this.date_of_birth ? 
moment(this.date_of_birth).format('YYYY-MM-DD') : ''; 
种类列表页面—自我挑战！ 
在这个部分，你应该实作你自己的种类列表页面。 
该页面应显示数据库中所有种类的列表，每个种类都链接到其关联的详细信息页面。 
预期结果的屏幕截图如下所示。 
Genre List - Express Local Library site 
种类列表控制器功能，需要获取所有种类实例的列表，然后将这些实例传递给模板进行渲染。 
你需要在 /controllers/genreController.js 中编辑genre_list()。 
实现方式几乎与author_list()控制器完全相同。 
按名称以上升顺序，对结果进行排序。 
要呈现的模板，应命名为 genre_list.pug。 
要呈现的模板应该传递变量title（‘Genre List’）和种类列表genre_list（从Genre.find()回调返回）。 
该视图应与上面的屏幕截图/要求相匹配（这应该与作者列表视图具有非常相似的结构/格式，除了种类没有日期）。 
下一步 
回到 Express 教程 5: 呈现图书馆数据 
继续教程 5 下一個部分：种类细节页面 


书本实例细节页面 
BookInstance细节页面，需要呈现每一个BookInstance的信息，用 _id 字段值（自动产生）做识别。 
它包含了 Book 名称 (也是一个连结，连到 书本细节页面)，接着是纪录中的其他的信息。 
控制器 
打开 /controllers/bookinstanceController.js，找到 exported bookinstance_detail() 控制器方法，并替换以下代码。 
// Display detail page for a specific BookInstance. 
exports.bookinstance_detail = function (req, res, next) { 
BookInstance.findById(req.params.id) 
.populate("book") 
return next(err); 
} if (bookinstance == null) { 
// No results. 
var err = new Error("Book copy not found"); 
err.status = 404; 
return next(err); 
} 
res.render("bookinstance_detail", { 
title: "Book:", 
bookinstance: bookinstance, 
}); 
}); 
该方法使用从 URL（使用路由）中提取的特定书本实例的 ID，调用BookInstance.findById()，并通过请求参数（req.params.id），在控制器中访问。 
然后调用populate()来获取相关Book的详细信息。 
视图 
创建 /views/bookinstance_detail.pug，并复制到下面的内容中。 
extends layout 
block content 
h1 ID: #{bookinstance._id} 
p #[strong Title:] 
a(href=bookinstance.book.url) #{bookinstance.book.title} 
p #[strong Imprint:] #{bookinstance.imprint} 
p #[strong Status:] 
if bookinstance.status=='Available' 
span.text-success #{bookinstance.status} 
else if bookinstance.status=='Maintenance' 
span.text-danger #{bookinstance.status} 
else 
span.text-warning #{bookinstance.status} 
if bookinstance.status! 
='Available' 
p #[strong Due back:] #{bookinstance.due_back} 
本模组中的所有东西，都在先前的章节演示过了。 
它看起來像是？ 
运行本应用，并打开浏览器访问 http://localhost:3000/。 
选择 All book-instances 连结，然后选择其中一本。 
如果每个东西都设定正确了，你的网站看起来应该像是底下的截图。 
BookInstance Detail Page - Express Local Library site 
下一步 

接下来，我们将实作图书馆中所有书本实例 (BookInstance) 的列表页面。 
这个页面需要包含与每个 BookInstance (链接到其详细信息页面) 关联的书本 Book 标题，以及BookInstance模型中的其他信息，包含每个副本的状态，印记和唯一 ID。 
唯一 ID 的文字，应该链接到 BookInstance 详细信息页面。 
控制器 
BookInstance列表控制器函数，需要获取所有书本实例的列表，填充关联的书本信息，然后将列表传递给模板以进行呈现。 
打开 /controllers/bookinstanceController.js。 
找到导出的 bookinstance_list() 控制器方法，并用以下代码替换它（更改后的代码以粗体显示）。 
// Display list of all BookInstances. 
exports.bookinstance_list = function (req, res, next) { BookInstance.find() 
.populate("book") .exec(function (err, list_bookinstances) { if (err) { return next(err); } // Successful, so render 
res.render("bookinstance_list", { 
title: "Book Instance List", 
bookinstance_list: list_bookinstances, 
}); 
}); 
此方法使用模型的find()函数，返回所有BookInstance对象。 
然后它将一个调用，以菊花链方式连接到populate()，附加书本book字段，这将使用完整的Book文档，替换每个BookInstance存储的书本 ID。 
成功时，传递给查询的回调，会呈现 bookinstance_list (.pug) 模板，并将标题title和书籍实例列表bookinstance_list作为变量传递。 
视图 
创建 /views/bookinstance_list.pug ，並複制貼上底下的文字。 
extends layout 
block content 
h1= title 
ul 
each val in bookinstance_list 
li 
a(href=val.url) #{val.book.title} : #{val.imprint} - 
if val.status=='Available' 
span.text-success #{val.status} 
else if val.status=='Maintenance' 
span.text-danger #{val.status} 
else 
span.text-warning #{val.status} 
if val.status! 
='Available' 
span (Due: #{val.due_back} ) 
else 
li There are no book copies in this library. 
这个視图与其他視图非常相似。 
它扩展了布局，替换内容區块，显示从控制器传入的标题 title，并遍历 bookinstance_list 中的所有书籍副本。 
对于每个副本，我们都会显示它的状态（用颜色编码），如果书本不可用，则显示其预期返回日期。 
這裡引入了一个新功能 — 我们可以在标签之后使用点符号表示法，來指定一個类別。 
因此，span.text-success 将被编译为 <span class="text-success">（也可以用 Pug 编写为 span(class="text-success")）. 
它看起來像是？ 
运行本应用，打开浏览器访问 http://localhost:3000/，然后选择 All book-instances 连结。 
假如每个东西都设定正确了，你的网站看起来应该像是底下的截图。 
BookInstance List Page - Express Local Library site 
下一步 
回到 Express 教程 5: 呈现图书馆数据 
继续教程 5 下个部分：日期格式化与使用 moment 

接下做我们将实作书本列表页面。 
这个页面需要呈现数据库中所有书本的列表，包含每本书的作者、标题，标题将成为一个超连结，连到书本详细内容页面。 
控制器 
书本列表控制器函数，需要获取数据库中所有Book对象的列表，然后将这些对象传给模板进行呈现。 
打开 /controllers/bookController.js. 
找到导出的 book_list() 控制器方法，并替换為下面的代码。 
// Display list of all Books. 
exports.book_list = function (req, res, next) { 
Book.find({}, "title author") 
.populate("author") 
.exec(function (err, list_books) { 
return next(err); 
res.render("book_list", { title: "Book List", book_list: list_books }); 
}); 
该方法使用模型的find()函数返回所有Book对象，选择仅返回标题title和作者author，因为我们不需要其他字段（它也会返回_id和虚拟字段）。 
这里我们还调用Book上的populate() ，指定作者author字段 — 这将用完整的作者信息，替换存储的书本作者 id。 
成功时，传递给查询的回调，将呈现 book_list(.pug) 模板，将标题title和book_list（包含作者的書本列表）作为变量传递。 
视图 
创建 /views/book_list.pug 并复制底下的文字。 
extends layout 
block content 
h1= title 
ul 
each book in book_list 
li 
a(href=book.url) #{book.title} 
| (#{book.author.name}) 
else 
li There are no books. 
這个视图扩展了 layout.pug 基本模板，并覆盖了名为 ‘content’ 的區块 block 。 
它显示我们从控制器传入的标题title（通过render()方法），然后使用each-in-else语法，遍历book_list变量。 
为每本图书创建一个列表项，以显示书名，并作为书的详细信息页面的链接，后面跟着作者姓名。 
如果book_list中没有书，则执行else子句，并显示文字“没有书” ‘There are no books.’。 
备注： 我们使用 book.url ，为每本书提供详细记录链接（我们已经实现了此路由，但尚未实现此页面）。 
这是 Book 模型的一个虚拟属性，它使用模型实例的 _id 字段，生成唯一的 URL 路径。 
在这里，我們感兴趣的是，每本书被定义为两行，第二行使用管道（上面高亮显示）。 
这种方法是必要的，因为如果作者姓名位于上一行，那么它将成为超链接的一部分。 
它看起來像是？ 
运行本应用 (参见 测试路由 有相关的命令) ，并打开你的浏览器，访问 http://localhost:3000/。 
然后选择 所有书本 连结。 
如果每样东西都设定正确了，你的网站看起来应该像底下的截图。 
Book List Page - Express Local Library site 
下一步 
回到 Express 教程 5: 呈现图书馆数据 
继续教程 5 下个部分：书本实例列表页面 

我们模型的日期预设呈现很难看：Tue Dec 06 2016 15:49:58 GMT+1100 (AUS Eastern Daylight Time)。 
在本节中，我们将展示如何更新上一节中的 書本實例 BookInstance 列表页面，以更友好的格式显示due_date字段：December 6th, 2016。 
我们将使用的方法，是在我们的BookInstance模型中，创建一个返回格式化日期的虚拟屬性。 
我们将使用moment 来做实际的格式化，这是一个轻量级 JavaScript 日期库，用于解析，验证，操作和格式化日期。 
备注： 我们可以直接在 Pug 模板中，使用 moment 格式化字符串，或者可以在许多其他地方格式化字符串。 
使用虚拟属性，可以使我们获得格式化的日期，這与我们当前获取 due_date 的方式完全相同。 
安装 moment 
在项目的根目录，输入下列命令 
npm install moment 
创建虚拟属性 
打开 ./models/bookinstance.js. 
在此页面最上方，引用 moment 
var moment = require("moment"); 
在 url 属性后面，加入虚拟属性 due_back_formatted 。 
BookInstanceSchema.virtual("due_back_formatted").get(function () { 
return moment(this.due_back).format("MMMM Do, YYYY"); 
}); 
备注： 格式化方法可以使用几乎任何模式显示日期。 
moment 文档中，可以找到表示不同日期组件的语法。 
更新视图 
打开 /views/bookinstance_list.pug ，然后用 due_back_formatted 取代 due_back 。 
if val.status! 
='Available' 
//span (Due: #{val.due_back} ) 
span (Due: #{val.due_back_formatted} ) 
这就是本章节的全部了。 
如果你访问侧边栏的 All book-instances，你应该会看到所有的归还日期都更吸引人了！ 
下一步 
回到 Express 教程 5: 呈现图书馆数据 
继续教程 5 下一個部分：作者列表页面、种类列表页面、与自我挑战 

种类细节页面，需要利用_id 字段值 (自动生成) ，以呈现特定种类实例的信息。 
此页面应该呈现种类名称，各个种类的所有书本列表 (每本书都连结到书本的细节页面)。 
控制器 
打开 /controllers/genreController.js ，并在档案最上方引用 async 和 Book 模组。 
var Book = require("../models/book"); 
找到导出的 genre_detail() 控制器方法，并将其替换为以下代码。 
// Display detail page for a specific Genre. 
exports.genre_detail = function (req, res, next) { async.parallel( { 
genre: function (callback) { Genre.findById(req.params.id).exec(callback); 
}, genre_books: function (callback) { 
Book.find({ genre: req.params.id }).exec(callback); }, 
}, function (err, results) { if (err) { 
return next(err); 
} if (results.genre == null) { 
// No results. 
var err = new Error("Genre not found"); 
err.status = 404; 
return next(err); 
} 
res.render("genre_detail", { 
title: "Genre Detail", 
genre: results.genre, 
genre_books: results.genre_books, 
}); 
}; 
它还用于获取符合当前种类的所有Book对象，就是在种类字段中具有种类 ID 的那些 Book.find({ 'genre': req.params.id })。 
这是来自 req.params.id 的 mongoose 错误。 要解决这个问题，首先需要在 genreController.js 页面上要求 mongoose，如下所示： var mongoose = require("mongoose"); 

我们创建的第一个页面，是网站的主页面，可以从网站的根目录 ('/') ，或者 catalog 的根目录 (catalog/) 访问。 
这将呈现一些网站的静态文字描述，以及动态计算数据库中不同记录类型的“计数”。 
我们已经为主页创建了一个路由。 
为了完成页面，我们需要更新控制器函数，以从数据库中提取记录的“计数”，并创建一个可用于呈现页面的视图（模板）。 
路由 
在 前面的教程，我们创建 index 页面路由。 
此处要提醒的是，所有的路由函式，都定义在 /routes/catalog.js: 
// GET catalog home page. 
router.get("/", book_controller.index); //This actually maps to /catalog/ because we import the route with a /catalog prefix 
在 /controllers/bookController.js 中，定义回调函数参数 (book_controller.index) ： 
exports.index = function (req, res, next) { 
res.send("NOT IMPLEMENTED: Site Home Page"); 
}; 
我们扩展这个控制器函数，以从我们的模型获取信息，然后使用模板（视图）渲染它。 
控制器 
索引控制器函数需要获取以下有关信息，即数据库中有多少Book，BookInstance，可用的BookInstance，Author和Genre记录，将这些数据渲染到模板中，以创建 HTML 页面，然后将其返回到 HTTP 响应中。 
// ... do something if there is an err 
// ... do something with the count if there was no error }); 
打开 /controllers/bookController.js. 
var Book = require('../models/book') 
exports.index = function(req, res, next) { 
res.send('NOT IMPLEMENTED: Site Home Page'); 
} 
用以下代码片段替换上面的所有代码。 
这要做的第一件事，是导入 (require()) 所有模型（以粗体突出高亮显示）。 
我们需要这样做，是因为我们将使用它们来获取记录的计数。 
然后它会导入异步模块 async。 
var Book = require("../models/book"); 
var Author = require("../models/author"); 
var Genre = require("../models/genre"); 
var BookInstance = require("../models/bookinstance"); 
var async = require("async"); 
exports.index = function (req, res) { 
async.parallel( { 
book_count: function (callback) { 
Book.count({}, callback); // Pass an empty object as match condition to find all documents of this collection }, 
book_instance_count: function (callback) { 
BookInstance.count({}, callback); 
}, book_instance_available_count: function (callback) { 
BookInstance.count({ status: "Available" }, callback); }, 
author_count: function (callback) { 
Author.count({}, callback); 
}, 
genre_count: function (callback) { 
Genre.count({}, callback); }, }, 
function (err, results) { 
res.render("index", { 
title: "Local Library Home", 
error: err, 
data: results, 
}); 
}; 
async.parallel() 方法传递一个对象，其中包含用于获取每个模型计数的函数。 
这些函数都是在同一时间开始的。 
当这些函数全部完成时，最终回调将与结果参数中的计数（或错误）一起被调用。 
成功时，回调函数调用 res.render()，指定名为 ‘index’ 的视图（模板），以及一个对象包含了要插入其中的数据（这包括我们模型计数的结果对象）。 
数据以键值对的形式提供，可以使用键在模板中访问。 
备注： 上面的async.parallel()裡的回调函数有点不寻常，因为不管是否出现错误，我们都会渲染页面（通常你可能使用单独的执行路径来处理错误的显示）。 
视图 
打开 /views/index.pug，并用底下文字取代它的内容。 
extends layout 
block content 
h1= title 
p Welcome to #[em LocalLibrary], a very basic Express website developed as a tutorial example on the Mozilla Developer Network. 
h1 Dynamic content 
else p The library has the following record counts: 
ul 
li #[strong Books:] ! 
{data.book_count} 
li #[strong Copies:] ! 
{data.book_instance_count} 
li #[strong Copies available:] ! 
{data.book_instance_available_count} 
li #[strong Authors:] ! 
{data.author_count} 
li #[strong Genres:] ! 
{data.genre_count} 
这个视图很简单。 
我们扩展了 layout.pug 基本模板，覆盖了名为 ‘content’ 的模块 block。 
第一个h1标题，将是传递给render()函数的title 变量的转义文本 — 请注意 ‘h1=’ 的使用方式，将使得接下來的文本，被视为 JavaScript 表达式。 
然后我们放入一个介绍本地图书馆的段落。 
在动态内容标题下，我们检查从render()函数传入的错误变量，是否已定义。 
如果是这样，我们列出这个错误。 如果不是，我们从data变量中，获取并列出每个模型的副本数量。 



模板是一个文字档，定义了一个输出档的结构或者排版，使用定位符号表示，当模板被绘制时，资料将插入到何处（在 Express，模板被称为视图）。 
Express 模板选择 
Express 可以与许多不同的模板渲染引擎一起使用。 
在本教程中，我们使用Pug（以前称为 Jade）作为模板。 
这是最流行的 Node 模板语言，并且官方将自身描述为“用于编写 HTML，语法干净且空格敏感，受 Haml影响很大”。 
不同的模板语言使用不同的方法，来定义布局和标记数据的占位符 — 一些使用 HTML 来定义布局，而另一些则使用可以编译为 HTML 的不同标记格式。 
你应该看到 Pug 模块作为依赖项，包含在网站的 package.json文件中，以及 app.js文件中的以下配置设置。 设置告诉我们，使用 Pug 作为视图引擎，Express 应该在 /views子目录中搜索模板。 // View engine setup. 
app.set("views", path.join(__dirname, "views")); app.set("view engine", "pug"); 
如果查看 views 目录，你将看到项目默认视图的 .pug 文件。 这包括需要用自己的内容替换的主页（index.pug）和基本模板（layout.pug）的视图。 
/express-locallibrary-tutorial //the project root /views 
error.pug index.pug 
h1= title p This is a line with #[em some emphasis] and #[strong strong text] markup. 
p This line has un-escaped data: !{' <em> is emphasised</em>'} and escaped data: #{'<em> is not emphasised</em>'}. | This line follows on. 
// You can add single line JavaScript comments and they are generated to HTML comments //- Introducing a single line JavaScript comment with "//-" ensures the comment isn't rendered to HTML p A line with a link 
a(href='/catalog/authors') Some link text 
p. Pug is a terse and simple template language with a 
strong focus on performance and powerful features. 
script(type='text/javascript'), link(rel='stylesheet', href='/stylesheets/style.css') 
p This line has an un-escaped string: !{' <em> is emphasised</em>'}, an escaped string: #{'<em> is not emphasised</em>'}, and escaped variables: #{title}. 
a(href='http://someurl/') Link text | Plain text 
if title 
doctype html 
html head 
title= title 
block content 
extends标记，标识要使用的基本模板，然后我们使用 block section_name ，来指示我们将覆盖的部分的新内容。 extends layout block content h1= title p Welcome to #{title} 下一步 回到 Express 教程 5: 呈现图书馆数据 继续教程 5 下一个部分：图书馆基本模板 

本章节演示，如何为创建作者对象Author定义一个页面。 
导入验证和清理方法 
为了在种类表单使用 express 验证器，我们必须用 require 导入我们想用的函式。 
打开 /controllers/authorController.js，并在档案最上方加入底下几行： const { body, validationResult } = require("express-validator/check"); 
const { sanitizeBody } = require("express-validator/filter"); 
控制器—get 路由 
找到导出的 author_create_get()控制器方法，并替换为底下代码。 
这里单纯呈现 author_form.pug 视图，传送 title 变数。 
// Display Author create form on GET. 
exports.author_create_get = function (req, res, next) { 
res.render("author_form", { title: "Create Author" }); 
}; 
控制器—post 路由 
找到导出的 author_create_post() 控制器方法，并替换为底下代码。 
// Handle Author create on POST. 
exports.author_create_post = [ 
// Validate fields. 
body("first_name") 
.isLength({ min: 1 }) 
.trim() 
.withMessage("First name must be specified.") 
.isAlphanumeric() 
.withMessage("First name has non-alphanumeric characters."), 
body("family_name") 
.isLength({ min: 1 }) 
.trim() 
.withMessage("Family name must be specified.") 
.isAlphanumeric() 
.withMessage("Family name has non-alphanumeric characters."), 
body("date_of_birth", "Invalid date of birth") 
.optional({ checkFalsy: true }) 
.isISO8601(), 
body("date_of_death", "Invalid date of death") 
.optional({ checkFalsy: true }) 
.isISO8601(), 
// Sanitize fields. 
sanitizeBody("first_name").trim().escape(), 
sanitizeBody("family_name").trim().escape(), 
sanitizeBody("date_of_birth").toDate(), 
sanitizeBody("date_of_death").toDate(), 
// Process request after validation and sanitization. 
(req, res, next) => { 
// Extract the validation errors from a request. 
const errors = validationResult(req); 
if (! 
errors.isEmpty()) { 
// There are errors. 
Render form again with sanitized values/errors messages. 
res.render("author_form", { 
title: "Create Author", 
author: req.body, 
errors: errors.array(), 
}); 
return; 
} else { 
// Data from form is valid. 
// Create an Author object with escaped and trimmed data. 
if (err) { return next(err); 
} // Successful - redirect to new author record. 
res.redirect(author.url); }); 
} 
}, 
]; 
此代码的结构和行为，几乎与创建Genre对象完全相同。 
首先，我们验证并清理数据。 
如果数据无效，那么我们将重新显示表单，以及用户最初输入的数据，和错误消息列表。 
如果数据有效，那么我们保存新的作者记录，并将用户重定向到作者详细信息页面。 
备注： 与Genre post 处理程序不同，我们不会在保存之前，检查Author对象是否已存在。 
可以说，我们应该这样做，尽管现在我们可以有多个具有相同名称的作者。 
验证代码演示了几个新功能： 
我们可以用菊花链式连接验证器，使用withMessage()指定在前一个验证方法失败时，显示的错误消息。 
这使得在没有大量代码重复的情况下，提供特定的错误消息变得非常容易。 
// Validate fields. 
body('first_name').isLength({ min: 1 }).trim().withMessage('First name must be specified.') 
.isAlphanumeric().withMessage('First name has non-alphanumeric characters.'), 
我们可以使用optional()函数，仅在输入字段时运行后续验证（这允许我们验证可选字段）。 
例如，下面我们检查可选的出生日期是否符合 ISO8601 标准（checkFalsy 旗标，表示我们接受空字符串或null作为空值）。 
body('date_of_birth', 'Invalid date of birth').optional({ checkFalsy: true }).isISO8601(), 
参数从请求中作为字符串接收。 
我们可以使用toDate()（或toBoolean()等）将这些转换为正确的 JavaScript 类型。 sanitizeBody('date_of_birth').toDate(), 
视图 
创建 /views/author_form.pug 并复制贴上以下文字。 
extends layout 
block content 
h1=title 
form(method='POST' action='') 
div.form-group 
label(for='first_name') First Name: 
input#first_name.form-control(type='text' placeholder='First name (Christian) last' name='first_name' required='true' value=(undefined===author ? 
'' : author.first_name) ) 
label(for='family_name') Family Name: 
input#family_name.form-control(type='text' placeholder='Family name (surname)' name='family_name' required='true' value=(undefined===author ? 
'' : author.family_name)) 
div.form-group 
label(for='date_of_birth') Date of birth: 
input#date_of_birth.form-control(type='date' name='date_of_birth' value=(undefined===author ? 
'' : author.date_of_birth) ) 
button.btn.btn-primary(type='submit') Submit 
if errors 
ul 
for error in errors 
li! 
= error.msg 
此视图的结构和行为与genre_form.pug模板完全相同，因此我们不再对其进行描述。 
备注： 某些浏览器不支持 input type=“date”，因此你不会获得日期选取部件或默认的dd/mm/yyyy占位符，而是获取一个空的纯文本字段。 
一种解决方法，是明确添加属性placeholder='dd/mm/yyyy'，以便在功能较少的浏览器上，仍然可以获得有关所需文本格式的信息。 
自我挑战：加入死亡日期 
上面的模板少了一个输入字段 date_of_death 。 
依照跟生日表单同样的模式，创建此字段！ 
它看起來像是？ 
运行本应用，打开浏览器访问网址http://localhost:3000/，然后点击创建新作者 Create new author 连结。 
如果每个东西都设定正确了，你的网站看起应该像底下的截图。 
在你输入一个值之后，它应该会被储存，并且你将被带到作者详细信息页面。 
Author Create Page - Express Local Library site 
备注： 如果你尝试使用日期的各种输入格式，你可能会发现格式yyyy-mm-dd行为不正常。 
这是因为 JavaScript 将日期字符串，视为包含 0 小时的时间，但另外将该格式的日期字符串（ISO 8601 标准）视为包括 0 小时 UTC 时间，而不是本地时间。 
如果你的时区在 UTC 以西，则日期显示（即本地）将在你输入的日期之前一天。 
这是我们在这里没有解决的几个复杂问题之一（例如多字姓和有多个作者的书本）。 
下一步 
回到 Express 教程 6: 使用表单 
继续教程 6 的下一个部分：创建书本表单 

此子文档显示如何定义页面/表单以创建Book对象。 
这比相同的作者Author或种类Genre页面稍微复杂一点，因为我们需要在我们的书本表单中，获取并显示可用的作者和种类记录。 
导入验证和清理方法 
打开 /controllers/bookController.js，并在文件顶部添加以下行： const { body, validationResult } = require("express-validator/check"); 
const { sanitizeBody } = require("express-validator/filter"); 
控制器—get 路由 
找到导出的book_create_get() 控制器方法，并将其替换为以下代码。 
// Display book create form on GET. 
exports.book_create_get = function (req, res, next) { 
// Get all authors and genres, which we can use for adding to our book. 
async.parallel( { authors: function (callback) { 
Author.find(callback); 
Genre.find(callback); }, 
}, 
} res.render("book_form", { 
title: "Create Book", 
authors: results.authors, 
genres: results.genres, 
}); 
}; 
这使用异步模块 async（在教程 5：显示数据库中的数据），来获取所有作者和种类对象。 
然后将它们作为名为authors和genres的变量（以及页面标题title），传递给视图book_form.pug。 
控制器—post 路由 
找到导出的book_create_post()控制器方法，并将其替换为以下代码。 
// Handle book create on POST. 
exports.book_create_post = [ 
// Convert the genre to an array. 
(req, res, next) => { 
if (! 
(req.body.genre instanceof Array)) { 
if (typeof req.body.genre === "undefined") req.body.genre = []; 
else req.body.genre = new Array(req.body.genre); 
} 
next(); 
}, 
// Validate fields. 
body("title", "Title must not be empty.").isLength({ min: 1 }).trim(), 
body("author", "Author must not be empty.").isLength({ min: 1 }).trim(), 
body("summary", "Summary must not be empty.").isLength({ min: 1 }).trim(), 
body("isbn", "ISBN must not be empty").isLength({ min: 1 }).trim(), 
// Sanitize fields (using wildcard). 
sanitizeBody("*").trim().escape(), 
sanitizeBody("genre.*").escape(), 
// Process request after validation and sanitization. 
(req, res, next) => { 
// Extract the validation errors from a request. 
const errors = validationResult(req); 
// Create a Book object with escaped and trimmed data. 
var book = new Book({ 
title: req.body.title, 
author: req.body.author, 
summary: req.body.summary, 
isbn: req.body.isbn, 
genre: req.body.genre, 
}); 
if (! 
errors.isEmpty()) { 
// There are errors. 
Render form again with sanitized values/error messages. 
// Get all authors and genres for form. 
async.parallel( { authors: function (callback) { 
Author.find(callback); 
Genre.find(callback); }, 
}, 
} // Mark our selected genres as checked. 
for (let i = 0; i < results.genres.length; i++) { 
if (book.genre.indexOf(results.genres[i]._id) > -1) { 
results.genres[i].checked = "true"; 
} 
} 
res.render("book_form", { 
title: "Create Book", 
authors: results.authors, 
genres: results.genres, book: book, 
errors: errors.array(), 
}); 
} else { 
// Data from form is valid. 
Save book. 
book.save(function (err) { 
if (err) { return next(err); 
} 
}); } 
]; 
此代码的结构和行为，几乎与创建种类Genre或作者Author对象完全相同。 
首先，我们验证并清理数据。 
如果数据无效，那么我们将重新显示表单，以及用户最初输入的数据，和错误消息列表。 
如果数据有效，我们将保存新的Book记录，并将用户重定向到Book详细信息页面。 
与其他表单处理代码相关的第一个主要区别，是我们使用通配符，一次修剪和转义所有字段（而不是单独清理它们）： 
sanitizeBody('*').trim().escape(), 
表单返回一个Genre项的数组（而对于其他字段，它返回一个字符串）。 
为了验证信息，我们首先将请求转换为数组（下一步需要）。 
// Convert the genre to an array. 
(req, res, next) => { 
if(! 
(req.body.genre instanceof Array)){ 
if(typeof req.body.genre==='undefined') 
req.body.genre=[]; else 
req.body.genre=new Array(req.body.genre); 
} 
next(); 
}, 
然后，我们在清理器中使用通配符（*）来单独验证每个种类数组条目。 
下面的代码显示了 - 这转换为“清理关键种类genre下的每个项目”。 
sanitizeBody('genre.*').trim().escape(), 
与其他表单处理代码的最终区别，在于我们需要将所有现有的种类和作者传递给表单。 
为了标记用户已经检查过的种类，我们遍历所有种类，并将checked='true'参数，添加到我们的 POST 数据中（如下面的代码片段中所示）。 
// Mark our selected genres as checked. 
for (let i = 0; i < results.genres.length; i++) { 
if (book.genre.indexOf(results.genres[i]._id) > -1) { 
results.genres[i].checked = "true"; 
} 
} 
视图 
创建 /views/book_form.pug，并复制下面的文本。 
extends layout 
block content 
h1= title 
form(method='POST' action='') 
div.form-group 
label(for='title') Title: 
input#title.form-control(type='text', placeholder='Name of book' name='title' required='true' value=(undefined===book ? 
'' : book.title) ) 
div.form-group 
label(for='author') Author: 
select#author.form-control(type='select', placeholder='Select author' name='author' required='true' ) 
for author in authors 
if book 
option(value=author._id selected=(author._id.toString()==book.author ? 
'selected' : false) ) #{author.name} 
else 
option(value=author._id) #{author.name} 
div.form-group 
label(for='summary') Summary: 
input#summary.form-control(type='textarea', placeholder='Summary' name='summary' value=(undefined===book ? 
'' : book.summary) required='true') 
div.form-group 
label(for='isbn') ISBN: 
input#isbn.form-control(type='text', placeholder='ISBN13' name='isbn' value=(undefined===book ? 
'' : book.isbn) required='true') 
div.form-group 
label Genre: 
div 
for genre in genres 
div(style='display: inline; padding-right:10px;') 
input.checkbox-input(type='checkbox', name='genre', id=genre._id, value=genre._id, checked=genre.checked ) 
label(for=genre._id) #{genre.name} 
button.btn.btn-primary(type='submit') Submit 
if errors 
ul 
for error in errors 
li! 
= error.msg 
视图结构和行为与 genre_form.pug 模板几乎相同。 
主要区别在于，我们如何实现选择类型字段：作者Author和种类Genre。 
种类集合显示为复选框，使用我们在控制器中设置的检查值checked，来确定是否应该选中该框。 

本章节演示如何定义一个页面/表单，以创建BookInstance 物件。 
这很像我们用来创建书本 Book 物件的表单。 
导入验证和清理方法 
打开 /controllers/bookinstanceController.js，并在档案最上方加入以下几行： 
const { sanitizeBody } = require("express-validator/filter"); 
控制器—get 路由 
在档案最上方，用 require 导入书本模型 (因为每个BookInstance 都有关连的 Book)。 
var Book = require("../models/book"); 
找到导出的 bookinstance_create_get() 控制器方法，并替换为底下代码。 
// Display BookInstance create form on GET. 
exports.bookinstance_create_get = function (req, res, next) { 
Book.find({}, "title").exec(function (err, books) { if (err) { 
res.render("bookinstance_form", { 
title: "Create BookInstance", 
book_list: books, 
}); 
}); 
控制器取得所有书本的列表 (book_list) 并将它传送到视图 bookinstance_form.pug (里面附加上 title)。 
控制器—post 路由 
找到导出的 bookinstance_create_post() 控制器方法，并替换为底下代码。 
// Handle BookInstance create on POST. 
exports.bookinstance_create_post = [ 
// Validate fields. 
body("book", "Book must be specified").isLength({ min: 1 }).trim(), 
body("imprint", "Imprint must be specified").isLength({ min: 1 }).trim(), 
// Sanitize fields. 
sanitizeBody("book").trim().escape(), 
sanitizeBody("imprint").trim().escape(), 
sanitizeBody("status").trim().escape(), 
sanitizeBody("due_back").toDate(), 
// Process request after validation and sanitization. 
(req, res, next) => { 
// Extract the validation errors from a request. 
const errors = validationResult(req); 
// Create a BookInstance object with escaped and trimmed data. 
var bookinstance = new BookInstance({ 
book: req.body.book, 
imprint: req.body.imprint, 
status: req.body.status, 
due_back: req.body.due_back, 
}); 
if (! 
errors.isEmpty()) { 
// There are errors. 
Render form again with sanitized values and error messages. 
Book.find({}, "title").exec(function (err, books) { if (err) { 
res.render("bookinstance_form", { 
title: "Create BookInstance", 
book_list: books, 
selected_book: bookinstance.book._id, 
errors: errors.array(), 
bookinstance: bookinstance, }); 
}); 
return; 
} else { 
// Data from form is valid. 
bookinstance.save(function (err) { 
if (err) { return next(err); 
} 
}); 
]; 
此代码的结构和行为，与创建其他对象的结构和行为相同。 
首先，我们验证数据，并為数据做無害化處理。 
如果数据无效，我们会重新显示表單，以及用户最初输入的数据，還有错误消息列表。 
如果数据有效，我们保存新的BookInstance记录，并将用户重定向到详细信息页面。 
视图 
创建 /views/bookinstance_form.pug ，并复制贴上以下代码。 
extends layout 
block content 
h1=title 
form(method='POST' action='') 
div.form-group 
label(for='book') Book: 
select#book.form-control(type='select' placeholder='Select book' name='book' required='true') 
for book in book_list 
if bookinstance 
option(value=book._id selected=(bookinstance.book.toString()==book._id.toString() ? 
'selected' : false)) #{book.title} 
div.form-group 
label(for='imprint') Imprint: 
input#imprint.form-control(type='text' placeholder='Publisher and date information' name='imprint' required='true' value=(undefined===bookinstance ? 
'' : bookinstance.imprint)) 
div.form-group 
label(for='due_back') Date when book available: 
input#due_back.form-control(type='date' name='due_back' value=(undefined===bookinstance ? 
'' : bookinstance.due_back)) 
div.form-group 
label(for='status') Status: 
select#status.form-control(type='select' placeholder='Select status' name='status' required='true') 
option(value='Maintenance') Maintenance 
option(value='Available') Available 
option(value='Loaned') Loaned 
option(value='Reserved') Reserved 
button.btn.btn-primary(type='submit') Submit 
if errors 
ul 
for error in errors 
li! 
= error.msg 
这个视图的结构和行为，几乎等同于 book_form.pug 模板，因此我们就不再重覆说明一次了。 
备注： 以上的模板将状态值 (Maintenance, Available, 等等) 写死在代码里，而且不能 “记忆” 使用者的输入值。 
如果你愿意的话，考虑重新实作此列表，当表单被重新呈现时，从控制器传入选项数据，并设定选中的值。 
它看起來像是？ 
运行本应用，打开浏览器访问网址 http://localhost:3000/。 
然后点击创建新书本实例 Create new book instance (copy) 连结。 
如果每个东西都设定正确了，你的网站看起应该像底下的截图。 
在你提交一个有效的 BookInstance 之后，它应该会被储存，并且你将被带到详细信息页面。 
下一步 
回到 Express 教程 6: 使用表单 
继续教程 6 的下一个部分：删除作者表单 

